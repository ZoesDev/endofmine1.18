declare class Text {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static string(text: any): Internal.Text
    notifyAll(): void
    static yellow(text: any): Internal.Text
    static darkBlue(text: any): Internal.Text
    notify(): void
    static translate(key: string): Internal.Text
    static translate(key: string, objects: any[]): Internal.Text
    static red(text: any): Internal.Text
    static gold(text: any): Internal.Text
    static aqua(text: any): Internal.Text
    static gray(text: any): Internal.Text
    static white(text: any): Internal.Text
    hashCode(): number
    static darkRed(text: any): Internal.Text
    static of(object: any): Internal.Text
    static darkPurple(text: any): Internal.Text
    static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text
    static green(text: any): Internal.Text
    static darkGreen(text: any): Internal.Text
    static black(text: any): Internal.Text
    static lightPurple(text: any): Internal.Text
    static darkAqua(text: any): Internal.Text
    static blue(text: any): Internal.Text
    equals(arg0: any): boolean
    static keybind(keybind: string): Internal.Text
    static darkGray(text: any): Internal.Text
    toString(): string
    get class(): Internal.Class<any>;
    constructor();
}
declare interface Utils {
    getSystemTime(): number
    listOrSelf(o: any): Internal.ListJS
    getStat(id: ResourceLocation): Internal.Stat<ResourceLocation>
    parseDouble(object: any, def: number): number
    emptyList<T>(): Internal.List<T>
    getRandom(): Internal.Random
    randomOf(random: Internal.Random, objects: Internal.Collection<any>): any
    emptyMap<K, V>(): Internal.Map<K, V>
    copy(o: any): any
    id(namespace: string, path: string): ResourceLocation
    id(id: ResourceLocation): ResourceLocation
    listOf(o: any): Internal.ListJS
    rollChestLoot(id: ResourceLocation, entity: Internal.EntityJS): Internal.ListJS
    rollChestLoot(id: ResourceLocation): Internal.ListJS
    getServer(): Internal.ServerJS
    newCountingMap(): Internal.CountingMap
    createConsole(name: string): Internal.ConsoleJS
    newMap(): Internal.MapJS
    newList(): Internal.ListJS
    getClientLevel(): Internal.LevelJS
    parseInt(object: any, def: number): number
    isWrapped(o: any): boolean
    getLevel(level: net.minecraft.world.level.Level): Internal.LevelJS
    regex(s: any): Internal.Pattern
    regex(pattern: string, flags: number): Internal.Pattern
    newRandom(seed: number): Internal.Random
    queueIO(runnable: Internal.Runnable): void
    toTitleCase(s: string): string
    mapOf(o: any): Internal.MapJS
    getSound(id: ResourceLocation): Internal.SoundEvent
}
declare const Utils: Utils;
declare class Vec3 implements Internal.Position {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    hashCode(): number
    notifyAll(): void
    equals(arg0: any): boolean
    toString(): string
    notify(): void
    readonly x : number;
    readonly y : number;
    readonly z : number;
    get class(): Internal.Class<any>;
    constructor(arg0: Internal.Vector3f);
    constructor(arg0: number, arg1: number, arg2: number);
}
declare class Rarity {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    hashCode(): number
    notifyAll(): void
    equals(arg0: any): boolean
    toString(): string
    notify(): void
    static readonly RARE : Rarity;
    static readonly EPIC : Rarity;
    static readonly UNCOMMON : Rarity;
    static readonly COMMON : Rarity;
    readonly rarity : Internal.Rarity;
    get class(): Internal.Class<any>;
}
declare class Hand extends Internal.Enum<any> {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static valueOf(arg0: string): Hand
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
    notifyAll(): void
    static values(): Hand[]
    compareTo(arg0: any): number
    compareTo(arg0: Hand): number
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Hand>>
    notify(): void
    getDeclaringClass(): Internal.Class<Hand>
    hashCode(): number
    equals(arg0: any): boolean
    name(): string
    toString(): string
    ordinal(): number
    static readonly MAIN_HAND : Hand;
    static readonly OFF_HAND : Hand;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<Hand>;
}
declare class DecorationGenerationStep extends Internal.Enum<any> {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static valueOf(arg0: string): DecorationGenerationStep
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
    notifyAll(): void
    static values(): DecorationGenerationStep[]
    compareTo(arg0: any): number
    compareTo(arg0: DecorationGenerationStep): number
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<DecorationGenerationStep>>
    notify(): void
    getDeclaringClass(): Internal.Class<DecorationGenerationStep>
    hashCode(): number
    equals(arg0: any): boolean
    name(): string
    toString(): string
    ordinal(): number
    static readonly RAW_GENERATION : DecorationGenerationStep;
    static readonly UNDERGROUND_STRUCTURES : DecorationGenerationStep;
    static readonly LOCAL_MODIFICATIONS : DecorationGenerationStep;
    static readonly TOP_LAYER_MODIFICATION : DecorationGenerationStep;
    static readonly UNDERGROUND_DECORATION : DecorationGenerationStep;
    static readonly LAKES : DecorationGenerationStep;
    static readonly SURFACE_STRUCTURES : DecorationGenerationStep;
    static readonly STRONGHOLDS : DecorationGenerationStep;
    static readonly FLUID_SPRINGS : DecorationGenerationStep;
    static readonly VEGETAL_DECORATION : DecorationGenerationStep;
    static readonly UNDERGROUND_ORES : DecorationGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<DecorationGenerationStep>;
}
declare interface Color {
    rgba(r: number, g: number, b: number, a: number): Internal.Color
    of(o: any): Internal.Color
    createMapped(o: any, names: string[]): Internal.Color
    readonly BLUE_DYE : Internal.Color;
    readonly GOLD : Internal.Color;
    readonly GRAY : Internal.Color;
    readonly MAGENTA_DYE : Internal.Color;
    readonly BLUE : Internal.Color;
    readonly DARK_AQUA : Internal.Color;
    readonly TEXT : Internal.Map<string, Internal.ChatFormatting>;
    readonly DYE : Internal.Map<string, Internal.DyeColor>;
    readonly WHITE_DYE : Internal.Color;
    readonly DARK_RED : Internal.Color;
    readonly LIGHT_PURPLE : Internal.Color;
    readonly BROWN_DYE : Internal.Color;
    readonly BLACK : Internal.Color;
    readonly GRAY_DYE : Internal.Color;
    readonly NONE : Internal.Color;
    readonly LIGHT_BLUE_DYE : Internal.Color;
    readonly AQUA : Internal.Color;
    readonly WHITE : Internal.Color;
    readonly LIGHT_GRAY_DYE : Internal.Color;
    readonly BLACK_DYE : Internal.Color;
    readonly RED_DYE : Internal.Color;
    readonly PURPLE_DYE : Internal.Color;
    readonly GREEN_DYE : Internal.Color;
    readonly PINK_DYE : Internal.Color;
    readonly DARK_BLUE : Internal.Color;
    readonly GREEN : Internal.Color;
    readonly CYAN_DYE : Internal.Color;
    readonly RED : Internal.Color;
    readonly DARK_PURPLE : Internal.Color;
    readonly ORANGE_DYE : Internal.Color;
    readonly YELLOW_DYE : Internal.Color;
    readonly DARK_GREEN : Internal.Color;
    readonly YELLOW : Internal.Color;
    readonly LIME_DYE : Internal.Color;
    readonly DARK_GRAY : Internal.Color;
    readonly MAP : Internal.Map<string, Internal.Color>;
}
declare const Color: Color;
declare class Vec3i implements Internal.Comparable<Vec3i> {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    getX(): number
    getY(): number
    getZ(): number
    hashCode(): number
    notifyAll(): void
    equals(arg0: any): boolean
    toString(): string
    compareTo(arg0: Vec3i): number
    compareTo(arg0: any): number
    notify(): void
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: number, arg1: number, arg2: number);
}
declare interface NBTIO {
    read(path: Internal.Path): Internal.CompoundTag
    write(path: Internal.Path, nbt: Internal.CompoundTag): void
}
declare const NBTIO: NBTIO;
declare class Block {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static getBlock(id: ResourceLocation): Internal.Block
    notifyAll(): void
    static custom(predicate: Internal.BlockPredicate): Internal.BlockPredicate
    static getTypeList(): Internal.List<string>
    notify(): void
    static getMaterial(): Internal.Map<string, Internal.MaterialJS>
    static getTaggedIds(tag: ResourceLocation): Internal.List<string>
    hashCode(): number
    equals(arg0: any): boolean
    toString(): string
    static getFacing(): Internal.Map<string, Internal.Direction>
    static id(id: ResourceLocation, properties: Internal.Map<string, any>): Internal.BlockIDPredicate
    static id(id: ResourceLocation): Internal.BlockIDPredicate
    static entity(id: ResourceLocation): Internal.BlockEntityPredicate
    get typeList(): Internal.List<string>;
    get material(): Internal.Map<string, Internal.MaterialJS>;
    get facing(): Internal.Map<string, Internal.Direction>;
    get class(): Internal.Class<any>;
    constructor();
}
declare class EquipmentSlot extends Internal.Enum<any> {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static valueOf(arg0: string): EquipmentSlot
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
    notifyAll(): void
    static values(): EquipmentSlot[]
    compareTo(arg0: any): number
    compareTo(arg0: EquipmentSlot): number
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<EquipmentSlot>>
    notify(): void
    getDeclaringClass(): Internal.Class<EquipmentSlot>
    hashCode(): number
    equals(arg0: any): boolean
    name(): string
    toString(): string
    ordinal(): number
    static readonly CHEST : EquipmentSlot;
    static readonly HEAD : EquipmentSlot;
    static readonly OFFHAND : EquipmentSlot;
    static readonly MAINHAND : EquipmentSlot;
    static readonly LEGS : EquipmentSlot;
    static readonly FEET : EquipmentSlot;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<EquipmentSlot>;
}
declare class BiomeDictionary {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static printTags(biome: ResourceLocation): void
    static getBiomeType(o: any): Internal.BiomeDictionary$Type
    static printBiomes(type: Internal.BiomeDictionary$Type): void
    hashCode(): number
    static addTypes(biomes: ResourceLocation[], tags: Internal.BiomeDictionary$Type[]): void
    notifyAll(): void
    equals(arg0: any): boolean
    toString(): string
    notify(): void
    get class(): Internal.Class<any>;
    constructor();
}
declare interface BlockStatePredicate {
    test(arg0: Internal.BlockState): boolean
    getBlockStates(): Internal.Collection<Internal.BlockState>
    of(o: any): BlockStatePredicate
    fromString(s: string): BlockStatePredicate
    check(targetStates: Internal.List<Internal.OreConfiguration$TargetBlockState>): boolean
    getBlocks(): Internal.Collection<Internal.Block>
    getBlockIds(): Internal.Set<ResourceLocation>
    asRuleTest(): Internal.RuleTest
    ruleTestOf(o: any): Internal.RuleTest
    readonly AIR_ID : ResourceLocation;
}
declare const BlockStatePredicate: BlockStatePredicate;
declare interface AABB {
    ofBlock(pos: BlockPos): Internal.AABB
    ofSize(vec3: Vec3, x: number, y: number, z: number): Internal.AABB
    ofSize(x: number, y: number, z: number): Internal.AABB
    of(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.AABB
    wrap(o: any): Internal.AABB
    ofBlocks(pos1: BlockPos, pos2: BlockPos): Internal.AABB
    readonly CUBE : Internal.AABB;
    readonly EMPTY : Internal.AABB;
}
declare const AABB: AABB;
declare class CarvingGenerationStep extends Internal.Enum<any> implements Internal.StringRepresentable {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static valueOf(arg0: string): CarvingGenerationStep
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
    notifyAll(): void
    static values(): CarvingGenerationStep[]
    compareTo(arg0: any): number
    compareTo(arg0: CarvingGenerationStep): number
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<CarvingGenerationStep>>
    notify(): void
    getDeclaringClass(): Internal.Class<CarvingGenerationStep>
    hashCode(): number
    equals(arg0: any): boolean
    name(): string
    toString(): string
    ordinal(): number
    static readonly LIQUID : CarvingGenerationStep;
    static readonly AIR : CarvingGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<CarvingGenerationStep>;
}
declare class Fluid {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    notifyAll(): void
    static water(): Internal.FluidStackJS
    static water(amount: number): Internal.FluidStackJS
    notify(): void
    static lava(): Internal.FluidStackJS
    static lava(amount: number): Internal.FluidStackJS
    static getType(id: ResourceLocation): Internal.Fluid
    hashCode(): number
    equals(arg0: any): boolean
    static of(o: Internal.FluidStackJS, amount: number): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS, nbt: Internal.CompoundTag): Internal.FluidStackJS
    static getEmpty(): Internal.FluidStackJS
    static exists(id: ResourceLocation): boolean
    toString(): string
    static getTypes(): Internal.List<string>
    static readonly LAVA_ID : ResourceLocation;
    static readonly WATER_ID : ResourceLocation;
    get types(): Internal.List<string>;
    get class(): Internal.Class<any>;
    get empty(): Internal.FluidStackJS;
    constructor();
}
declare class JavaMath {
    getClass(): Internal.Class<any>
    static multiplyFull(arg0: number, arg1: number): number
    static copySign(arg0: number, arg1: number): number
    static copySign(arg0: number, arg1: number): number
    static cos(arg0: number): number
    static log1p(arg0: number): number
    static expm1(arg0: number): number
    static rint(arg0: number): number
    static atan(arg0: number): number
    static nextUp(arg0: number): number
    static nextUp(arg0: number): number
    static sqrt(arg0: number): number
    static decrementExact(arg0: number): number
    static decrementExact(arg0: number): number
    static absExact(arg0: number): number
    static absExact(arg0: number): number
    static exp(arg0: number): number
    static atan2(arg0: number, arg1: number): number
    static signum(arg0: number): number
    static signum(arg0: number): number
    static tan(arg0: number): number
    static sinh(arg0: number): number
    static toDegrees(arg0: number): number
    static ceil(arg0: number): number
    static acos(arg0: number): number
    static getExponent(arg0: number): number
    static getExponent(arg0: number): number
    static addExact(arg0: number, arg1: number): number
    static addExact(arg0: number, arg1: number): number
    static multiplyHigh(arg0: number, arg1: number): number
    static ulp(arg0: number): number
    static ulp(arg0: number): number
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static scalb(arg0: number, arg1: number): number
    static scalb(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static log(arg0: number): number
    static log10(arg0: number): number
    notifyAll(): void
    static nextAfter(arg0: number, arg1: number): number
    static nextAfter(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    notify(): void
    static cbrt(arg0: number): number
    static random(): number
    static tanh(arg0: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static negateExact(arg0: number): number
    static negateExact(arg0: number): number
    hashCode(): number
    static hypot(arg0: number, arg1: number): number
    static pow(arg0: number, arg1: number): number
    static sin(arg0: number): number
    static floor(arg0: number): number
    static subtractExact(arg0: number, arg1: number): number
    static subtractExact(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static toIntExact(arg0: number): number
    static nextDown(arg0: number): number
    static nextDown(arg0: number): number
    static toRadians(arg0: number): number
    static cosh(arg0: number): number
    static IEEEremainder(arg0: number, arg1: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static round(arg0: number): number
    static round(arg0: number): number
    static incrementExact(arg0: number): number
    static incrementExact(arg0: number): number
    static floorDiv(arg0: number, arg1: number): number
    static floorDiv(arg0: number, arg1: number): number
    static floorDiv(arg0: number, arg1: number): number
    equals(arg0: any): boolean
    toString(): string
    static asin(arg0: number): number
    static fma(arg0: number, arg1: number, arg2: number): number
    static fma(arg0: number, arg1: number, arg2: number): number
    static readonly E : 2.718281828459045;
    static readonly PI : 3.141592653589793;
    get class(): Internal.Class<any>;
}
declare class Item {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    notifyAll(): void
    static getTypeList(): Internal.ListJS
    static getItem(id: ResourceLocation): Internal.Item
    static findGroup(id: string): Internal.CreativeModeTab
    static fireworks(properties: Internal.Map<string, any>): Internal.FireworksJS
    notify(): void
    static clearListCache(): void
    hashCode(): number
    static getList(): Internal.ListJS
    equals(arg0: any): boolean
    static of(in_: Internal.ItemStackJS): Internal.ItemStackJS
    static of(in_: object): Internal.ItemStackJS
    static of(in_: string): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, count: number, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: object, count: number, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: string, count: number, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, count: number): Internal.ItemStackJS
    static of(in_: object, count: number): Internal.ItemStackJS
    static of(in_: string, count: number): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, tag: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: object, tag: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: string, tag: Internal.CompoundTag): Internal.ItemStackJS
    static getEmpty(): Internal.ItemStackJS
    static exists(id: ResourceLocation): boolean
    static isItem(o: any): boolean
    toString(): string
    static withChance(in_: Internal.ItemStackJS, c: number): Internal.ItemStackJS
    static withChance(in_: object, c: number): Internal.ItemStackJS
    static withChance(in_: string, c: number): Internal.ItemStackJS
    static withNBT(in_: Internal.ItemStackJS, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static withNBT(in_: object, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static withNBT(in_: string, nbt: Internal.CompoundTag): Internal.ItemStackJS
    get typeList(): Internal.ListJS;
    get list(): Internal.ListJS;
    get class(): Internal.Class<any>;
    get empty(): Internal.ItemStackJS;
    constructor();
}
declare class BlockPos extends Vec3i {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    getX(): number
    getY(): number
    getZ(): number
    hashCode(): number
    notifyAll(): void
    equals(arg0: any): boolean
    toString(): string
    compareTo(arg0: Vec3i): number
    compareTo(arg0: any): number
    notify(): void
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: Vec3);
    constructor(arg0: Internal.Position);
    constructor(arg0: Vec3i);
    constructor(arg0: number, arg1: number, arg2: number);
}
declare interface Facing {
    readonly ALL : Internal.Map<string, Internal.Direction>;
    readonly DOWN : Internal.Direction;
    readonly south : Internal.Direction;
    readonly north : Internal.Direction;
    readonly WEST : Internal.Direction;
    readonly down : Internal.Direction;
    readonly east : Internal.Direction;
    readonly NORTH : Internal.Direction;
    readonly west : Internal.Direction;
    readonly up : Internal.Direction;
    readonly UP : Internal.Direction;
    readonly SOUTH : Internal.Direction;
    readonly EAST : Internal.Direction;
}
declare const Facing: Facing;
declare class JsonIO {
    static writeJsonHash(stream: Internal.DataOutputStream, element: Internal.JsonElement): void
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static toPrimitive(element: Internal.JsonElement): any
    static read(path: Internal.Path): Internal.MapJS
    notifyAll(): void
    static getJsonHashBytes(json: Internal.JsonElement): number[]
    static parse(string: string): any
    static primitiveOf(o: any): Internal.JsonPrimitive
    notify(): void
    hashCode(): number
    equals(arg0: any): boolean
    static of(o: any): Internal.JsonElement
    static toArray(element: Internal.JsonElement): Internal.JsonArray
    static toPrettyString(json: Internal.JsonElement): string
    static parseRaw(string: string): Internal.JsonElement
    static toString(json: Internal.JsonElement): string
    toString(): string
    static copy(element: Internal.JsonElement): Internal.JsonElement
    static toObject(json: Internal.JsonElement): any
    static write(path: Internal.Path, json: Internal.JsonElement): void
    static readonly GSON : Internal.Gson;
    get class(): Internal.Class<any>;
    constructor();
}
declare interface NBT {
    longArrayTag(v: number[]): Internal.Tag
    b(v: number): Internal.Tag
    byteArrayTag(v: number[]): Internal.Tag
    fromTag(t: Internal.Tag): any
    d(v: number): Internal.Tag
    listTag(list: Internal.List<any>): Internal.Tag
    listTag(): Internal.Tag
    f(v: number): Internal.Tag
    compoundTag(map: Internal.Map<string, any>): Internal.Tag
    compoundTag(): Internal.Tag
    toTag(v: any): Internal.Tag
    i(v: number): Internal.Tag
    shortTag(v: number): Internal.Tag
    l(v: number): Internal.Tag
    floatTag(v: number): Internal.Tag
    s(v: number): Internal.Tag
    la(v: number[]): Internal.Tag
    longTag(v: number): Internal.Tag
    ia(v: number[]): Internal.Tag
    intArrayTag(v: number[]): Internal.Tag
    doubleTag(v: number): Internal.Tag
    intTag(v: number): Internal.Tag
    byteTag(v: number): Internal.Tag
    stringTag(v: string): Internal.Tag
    ba(v: number[]): Internal.Tag
}
declare const NBT: NBT;
declare class Ingredient {
    getClass(): Internal.Class<any>
    static customNBT(in_: Internal.ItemStackJS, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS
    static customNBT(in_: object, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS
    static customNBT(in_: string, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS
    static customNBT(in_: Internal.IngredientJS, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static getAll(): Internal.IngredientJS
    static isIngredient(o: any): boolean
    notifyAll(): void
    static custom(in_: Internal.ItemStackJS, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static custom(in_: object, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static custom(in_: string, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static custom(in_: Internal.IngredientJS, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static custom(predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static getNone(): Internal.IngredientJS
    notify(): void
    static matchAny(objects: any): Internal.IngredientJS
    hashCode(): number
    equals(arg0: any): boolean
    static of(object: any): Internal.IngredientJS
    static of(object: any, count: number): Internal.IngredientJS
    toString(): string
    static registerCustomIngredientAction(id: string, callback: Internal.CustomIngredientActionCallback): void
    get all(): Internal.IngredientJS;
    get none(): Internal.IngredientJS;
    get class(): Internal.Class<any>;
    constructor();
}
declare interface UUID {
    digits(sb: Internal.StringBuilder, val: number, digits: number): void
    toString(id: Internal.UUID): string
    fromString(o: any): Internal.UUID
}
declare const UUID: UUID;
declare class ResourceLocation implements Internal.Comparable<ResourceLocation>, Internal.ResourceLocationAccess, Internal.SpecialEquality {
    getClass(): Internal.Class<any>
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    notifyAll(): void
    setPath(arg0: string): void
    compareTo(arg0: ResourceLocation): number
    compareTo(arg0: any): number
    notify(): void
    getNamespace(): string
    hashCode(): number
    equals(arg0: any): boolean
    compareNamespaced(arg0: ResourceLocation): number
    getPath(): string
    toString(): string
    setNamespace(arg0: string): void
    specialEquals(o: any, shallow: boolean): boolean
    get path(): string;
    get namespace(): string;
    get class(): Internal.Class<any>;
    set path(arg0: string);
    set namespace(arg0: string);
    constructor(arg0: string);
    constructor(arg0: string, arg1: string);
}
declare class Platform {
    static isDevelopmentEnvironment(): boolean
    getClass(): Internal.Class<any>
    static isClientEnvironment(): boolean
    wait(arg0: number, arg1: number): void
    wait(): void
    wait(arg0: number): void
    static getName(): string
    static getInfo(modID: string): Internal.PlatformWrapper$ModInfo
    static getMods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>
    notifyAll(): void
    static isForge(): boolean
    static isLoaded(modId: string): boolean
    notify(): void
    static isFabric(): boolean
    hashCode(): number
    static getList(): Internal.Set<string>
    equals(arg0: any): boolean
    static getModVersion(): string
    toString(): string
    static getMcVersion(): string
    get mods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    get modVersion(): string;
    get developmentEnvironment(): boolean;
    get forge(): boolean;
    get fabric(): boolean;
    get mcVersion(): string;
    get clientEnvironment(): boolean;
    get name(): string;
    get list(): Internal.Set<string>;
    get class(): Internal.Class<any>;
    constructor();
}
declare namespace com.simibubi.create.foundation.mixin.accessor {
    interface LivingEntityAccessor {
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
    }
}
declare namespace com.mojang.blaze3d.platform {
    class Window implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        handler$bge000$startQuartz(arg0: Internal.WindowEventHandler, arg1: Internal.ScreenManager, arg2: Internal.DisplayData, arg3: string, arg4: string, arg5: Internal.CallbackInfo): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace vazkii.botania.mixin {
    interface AccessorEntity {
        callUnsetRemoved(): void
    }
}
declare namespace net.blay09.mods.netherportalfix.mixin {
    interface LivingEntityAccessor {
        getLastPos(): BlockPos
    }
}
declare namespace net.minecraft.client.model {
    abstract class Model {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace Internal {
    class OptionalLong {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: number): number
        notify(): void
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalLong
        getAsLong(): number
        orElseGet(arg0: Internal.LongSupplier): number
        stream(): Internal.LongStream
        hashCode(): number
        ifPresent(arg0: Internal.LongConsumer): void
        ifPresentOrElse(arg0: Internal.LongConsumer, arg1: Internal.Runnable): void
        static of(arg0: number): Internal.OptionalLong
        equals(arg0: any): boolean
        toString(): string
        get asLong(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Encoder <A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>
        fieldOf(arg0: string): Internal.MapEncoder<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<A>
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>
    }
    interface PrivilegedExceptionAction <T> {
        run(): T
    }
    class DisplayMode {
        getClass(): Internal.Class<any>
        getRefreshRate(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getHeight(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: Internal.DisplayMode): boolean
        equals(arg0: any): boolean
        getBitDepth(): number
        toString(): string
        getWidth(): number
        notify(): void
        static readonly BIT_DEPTH_MULTI : -1;
        static readonly REFRESH_RATE_UNKNOWN : 0;
        get refreshRate(): number;
        get bitDepth(): number;
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Dialog$ModalExclusionType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Dialog$ModalExclusionType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Dialog$ModalExclusionType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Dialog$ModalExclusionType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dialog$ModalExclusionType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Dialog$ModalExclusionType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly APPLICATION_EXCLUDE : Internal.Dialog$ModalExclusionType;
        static readonly NO_EXCLUDE : Internal.Dialog$ModalExclusionType;
        static readonly TOOLKIT_EXCLUDE : Internal.Dialog$ModalExclusionType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dialog$ModalExclusionType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Fluid extends Internal.ForgeRegistryEntry<any> implements Internal.IForgeFluid {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAttributes(): Internal.FluidAttributes
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Fluid
        setRegistryName(arg0: string): Internal.Fluid
        setRegistryName(arg0: string, arg1: string): Internal.Fluid
        getTags(): Internal.Set<ResourceLocation>
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: Internal.Material): boolean
        notify(): void
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.Fluid>
        toString(): string
        readonly delegate : () => Internal.Fluid;
        get registryType(): Internal.Class<Internal.Fluid>;
        get attributes(): Internal.FluidAttributes;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TileObserver {
        tileUpdate(arg0: Internal.WritableRenderedImage, arg1: number, arg2: number, arg3: boolean): void
    }
    interface LongToIntFunction {
        applyAsInt(arg0: number): number
    }
    class Insets implements Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        set(arg0: number, arg1: number, arg2: number, arg3: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        notify(): void
        top : number;
        left : number;
        bottom : number;
        right : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PartialModel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): ResourceLocation
        static onModelRegistry(arg0: Internal.ModelRegistryEvent): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        get(): Internal.BakedModel
        toString(): string
        static onModelBake(arg0: Internal.ModelBakeEvent): void
        notify(): void
        get location(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Task extends Internal.QuestObject {
        getClass(): Internal.Class<any>
        autoSubmitOnPlayerTick(): number
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        submitTask(teamData: Internal.TeamData, player: Internal.ServerPlayer): void
        submitTask(teamData: Internal.TeamData, player: Internal.ServerPlayer, craftedItem: Internal.ItemStack): void
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        submitItemsOnInventoryChange(): boolean
        getPath(): string
        clearCachedData(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        editedFromGUI(): void
        hasTag(tag: string): boolean
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        formatMaxProgress(): string
        onEditButtonClicked(gui: Internal.Runnable): void
        getChildren(): Internal.Collection<Internal.QuestObject>
        addMouseOverText(list: Internal.TooltipList, teamData: Internal.TeamData): void
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getIngredient(): any
        getType(): Internal.TaskType
        getAltTitle(): Internal.Component
        getMaxProgress(): number
        onButtonClicked(button: Internal.Button, canClick: boolean): void
        deleteSelf(): void
        consumesResources(): boolean
        cacheProgress(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addTitleInMouseOverText(): boolean
        readNetData(buffer: Internal.FriendlyByteBuf): void
        deleteChildren(): void
        notifyAll(): void
        notify(): void
        drawGUI(teamData: Internal.TeamData, matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getQuestFile(): Internal.QuestFile
        getButtonText(): Internal.MutableComponent
        formatProgress(teamData: Internal.TeamData, progress: number): string
        checkOnLogin(): boolean
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        hideProgressNumbers(): boolean
        canInsertItem(): boolean
        disableToast : boolean;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        readonly quest : Internal.Quest;
        get buttonText(): Internal.MutableComponent;
        get ingredient(): any;
        get codeString(): string;
        get maxProgress(): number;
        get questFile(): Internal.QuestFile;
        get type(): Internal.TaskType;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecipeSerializer <T> extends Internal.IForgeRegistryEntry<Internal.RecipeSerializer<any>> {
        getRegistryType(): Internal.Class<Internal.RecipeSerializer<any>>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): Internal.RecipeSerializer<any>
    }
    class CopyNameFunction$NameSource extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.CopyNameFunction$NameSource
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.CopyNameFunction$NameSource[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.CopyNameFunction$NameSource): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.CopyNameFunction$NameSource>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly KILLER_PLAYER : Internal.CopyNameFunction$NameSource;
        static readonly KILLER : Internal.CopyNameFunction$NameSource;
        static readonly BLOCK_ENTITY : Internal.CopyNameFunction$NameSource;
        static readonly THIS : Internal.CopyNameFunction$NameSource;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Widget {
    }
    interface IBlockRenderProperties {
        getFogColor(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: Internal.Vector3d, arg5: number): Internal.Vector3d
        addDestroyEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.ParticleEngine): boolean
        addHitEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: Internal.HitResult, arg3: Internal.ParticleEngine): boolean
    }
    interface Multimap <K, V> {
        containsEntry(arg0: any, arg1: any): boolean
        keys(): Internal.Multiset<K>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        asMap(): Internal.Map<K, Internal.Collection<V>>
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: any): boolean
        get(arg0: K): Internal.Collection<V>
        keySet(): Internal.Set<K>
    }
    class HoverEvent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelSimulatedReader {
    }
    class HashMap <K, V> extends Internal.AbstractMap<any, any> implements Internal.Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        notifyAll(): void
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V, arg2: V): boolean
        replace(arg0: K, arg1: V): V
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any, arg1: any): boolean
        remove(arg0: any): V
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PropertyChangeListener extends Internal.EventListener {
        propertyChange(arg0: Internal.PropertyChangeEvent): void
    }
    class UnboundedMapCodec <K, V> implements Internal.BaseMapCodec<K, V>, Internal.Codec<Internal.Map<K, V>> {
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>
        encode(arg0: any, arg1: Internal.DynamicOps<any>, arg2: any): Internal.DataResult<any>
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>
        getClass(): Internal.Class<any>
        flatComapMap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Codec<S_>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        dispatch<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.Map<K, V>, arg2: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>
        deprecated(arg0: number): Internal.Codec<Internal.Map<K, V>>
        notifyAll(): void
        simple(): Internal.Decoder$Simple<Internal.Map<K, V>>
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => Internal.Map<K, V>, arg2: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.MapCodec<E_>
        dispatchMap<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.MapCodec<E_>
        comapFlatMap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.Codec<S_>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Map<K, V>, T_>>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<Internal.Map<K, V>>
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Map<K, V>, T_>>
        notify(): void
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<Internal.Map<K, V>>
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>
        flatXmap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Codec<S_>
        hashCode(): number
        comap<B_>(arg0: (arg0: B_) => Internal.Map<K, V>): Internal.Encoder<B_>
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        xmap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.Codec<S_>
        listOf(): Internal.Codec<Internal.List<Internal.Map<K, V>>>
        map<B_>(arg0: (arg0: Internal.Map<K, V>) => B_): Internal.Decoder<B_>
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.Map<K, V>): Internal.DataResult<T_>
        optionalFieldOf(arg0: string, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        optionalFieldOf(arg0: string, arg1: Internal.Map<K, V>, arg2: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: Internal.Map<K, V>, arg3: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<Internal.Map<K, V>>>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Encoder<B_>
        keyCodec(): Internal.Codec<K>
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<Internal.Map<K, V>>, arg2: (arg0: Internal.Map<K, V>) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<Internal.Map<K, V>>
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>
        terminal(): Internal.Decoder$Terminal<Internal.Map<K, V>>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<Internal.Map<K, V>>
        orElse(arg0: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        orElse(arg0: (arg0: any) => any, arg1: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        orElse(arg0: (arg0: string) => void, arg1: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        flatMap<B_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<B_>): Internal.Decoder<B_>
        elementCodec(): Internal.Codec<V>
        boxed(): Internal.Decoder$Boxed<Internal.Map<K, V>>
        orElseGet(arg0: (arg0: any) => any, arg1: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        orElseGet(arg0: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        orElseGet(arg0: (arg0: string) => void, arg1: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>
        dispatchStable<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>
        stable(): Internal.Codec<Internal.Map<K, V>>
        equals(arg0: any): boolean
        mapResult(arg0: Internal.Codec$ResultFunction<Internal.Map<K, V>>): Internal.Codec<Internal.Map<K, V>>
        toString(): string
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<any>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<com.mojang.datafixers.util.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientPlayerJS extends Internal.PlayerJS<any> {
        getXpLevel(): number
        getLastAttackedEntity(): Internal.LivingEntityJS
        sendData(channel: string, data: Internal.CompoundTag): void
        setY(y: number): void
        setX(x: number): void
        isOnScoreboardTeam(teamID: string): boolean
        isLiving(): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        getRevengeTarget(): Internal.LivingEntityJS
        paint(tag: Internal.CompoundTag): void
        getTags(): Internal.Set<string>
        getOffHandItem(): Internal.ItemStackJS
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        setXpLevel(l: number): void
        getHasCustomName(): boolean
        setInvisible(invisible: boolean): void
        runCommandSilent(command: string): number
        getIdleTime(): number
        getMovementSpeed(): number
        setSelectedSlot(index: number): void
        isBoss(): boolean
        getDistanceSq(x: number, y: number, z: number): number
        getDistanceSq(pos: BlockPos): number
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        addFood(f: number, m: number): void
        getHealth(): number
        setLegsArmorItem(item: string): void
        setLegsArmorItem(item: Internal.ItemStackJS): void
        setLegsArmorItem(item: object): void
        getServer(): Internal.ServerJS
        setFeetArmorItem(item: string): void
        setFeetArmorItem(item: Internal.ItemStackJS): void
        setFeetArmorItem(item: object): void
        give(item: string): void
        give(item: Internal.ItemStackJS): void
        give(item: object): void
        setMaxHealth(hp: number): void
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        isMiningBlock(): boolean
        isSpectator(): boolean
        setAbsorptionAmount(amount: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getDisplayName(): Internal.Text
        getType(): string
        getXp(): number
        addExhaustion(exhaustion: number): void
        setCustomNameAlwaysVisible(b: boolean): void
        setOffHandItem(item: string): void
        setOffHandItem(item: Internal.ItemStackJS): void
        setOffHandItem(item: object): void
        getFoodLevel(): number
        addMotion(x: number, y: number, z: number): void
        isFake(): boolean
        isSelf(): boolean
        isInvisible(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaxHealth(): number
        isUnderWater(): boolean
        getHeldItem(hand: Hand): Internal.ItemStackJS
        getEyeHeight(): number
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS
        notify(): void
        getFallDistance(): number
        damageHeldItem(): void
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageHeldItem(hand: Hand, amount: number): void
        setAirSupply(air: number): void
        setOnFire(seconds: number): void
        removePassengers(): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        isUndead(): boolean
        isOnLadder(): boolean
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        getInventory(): Internal.InventoryJS
        boostElytraFlight(): void
        getData(): Internal.AttachedData
        getDistance(x: number, y: number, z: number): number
        getDistance(pos: BlockPos): number
        getLastDamageSource(): Internal.DamageSourceJS
        setStatusMessage(message: Internal.Component): void
        isSwimming(): boolean
        getReachDistance(): number
        getCustomName(): Internal.Text
        getStepHeight(): number
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        getLastAttackedEntityTime(): number
        isMonster(): boolean
        equals(arg0: any): boolean
        addItemCooldown(item: Internal.Item, ticks: number): void
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        isOnGround(): boolean
        toString(): string
        isSilent(): boolean
        isPassenger(e: Internal.EntityJS): boolean
        setXp(xp: number): void
        getMaxAirSupply(): number
        getClass(): Internal.Class<any>
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        getName(): Internal.Text
        setFallDistance(fallDistance: number): void
        getFeetArmorItem(): Internal.ItemStackJS
        sendInventoryUpdate(): void
        setCustomName(name: Internal.Component): void
        setMainHandItem(item: string): void
        setMainHandItem(item: Internal.ItemStackJS): void
        setMainHandItem(item: object): void
        setStepHeight(stepHeight: number): void
        tell(message: Internal.Component): void
        getTeamId(): string
        isWaterCreature(): boolean
        setNoClip(noClip: boolean): void
        setPosition(x: number, y: number, z: number): void
        setPosition(block: Internal.BlockContainerJS): void
        closeInventory(): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        setRevengeTarget(target: Internal.LivingEntityJS): void
        setMovementSpeed(speed: number): void
        isChild(): boolean
        setEquipment(slot: EquipmentSlot, item: string): void
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void
        setEquipment(slot: EquipmentSlot, item: object): void
        giveInHand(item: string): void
        giveInHand(item: Internal.ItemStackJS): void
        giveInHand(item: object): void
        getAirSupply(): number
        getLegsArmorItem(): Internal.ItemStackJS
        setFullNBT(nbt: Internal.CompoundTag): void
        getAttackingEntity(): Internal.LivingEntityJS
        isHoldingInAnyHand(ingredient: any): boolean
        isCreativeMode(): boolean
        getNoClip(): boolean
        getFullNBT(): Internal.CompoundTag
        setYaw(yaw: number): void
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageEquipment(slot: EquipmentSlot, amount: number): void
        damageEquipment(slot: EquipmentSlot): void
        isAlive(): boolean
        getYaw(): number
        getHeadArmorItem(): Internal.ItemStackJS
        setNoGravity(noGravity: boolean): void
        setMouseItem(item: string): void
        setMouseItem(item: Internal.ItemStackJS): void
        setMouseItem(item: object): void
        setHeldItem(hand: Hand, item: string): void
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void
        setHeldItem(hand: Hand, item: object): void
        isPlayer(): boolean
        getRevengeTimer(): number
        getStats(): Internal.PlayerStatsJS
        getAbsorptionAmount(): number
        isCrouching(): boolean
        notifyAll(): void
        getId(): Internal.UUID
        addXPLevels(l: number): void
        getTicksExisted(): number
        getStages(): Internal.Stages
        getOpenInventory(): Internal.AbstractContainerMenu
        setSilent(isSilent: boolean): void
        hashCode(): number
        getChestArmorItem(): Internal.ItemStackJS
        isFrame(): boolean
        heal(hp: number): void
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        setChestArmorItem(item: string): void
        setChestArmorItem(item: Internal.ItemStackJS): void
        setChestArmorItem(item: object): void
        getCustomNameAlwaysVisible(): boolean
        addXP(xp: number): void
        getMainHandItem(): Internal.ItemStackJS
        setHealth(hp: number): void
        setMotionZ(z: number): void
        setMotionY(y: number): void
        getBlock(): Internal.BlockContainerJS
        setMotionX(x: number): void
        isElytraFlying(): boolean
        isInWater(): boolean
        dismountRidingEntity(): void
        isSleeping(): boolean
        isAmbientCreature(): boolean
        getPotionEffects(): Internal.EntityPotionEffectsJS
        swingArm(hand: Hand): void
        rayTrace(distance: number): Internal.RayTraceResultJS
        rayTrace(): Internal.RayTraceResultJS
        isInvulnerable(): boolean
        setHeadArmorItem(item: string): void
        setHeadArmorItem(item: Internal.ItemStackJS): void
        setHeadArmorItem(item: object): void
        getSelectedSlot(): number
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean
        getX(): number
        getY(): number
        spawn(): void
        getZ(): number
        isPeacefulCreature(): boolean
        getMouseItem(): Internal.ItemStackJS
        setFoodLevel(foodLevel: number): void
        getMotionZ(): number
        getMotionX(): number
        getNoGravity(): boolean
        getMotionY(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.Player;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get displayName(): Internal.Text;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get self(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get airSupply(): number;
        get sleeping(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: string);
        set mainHandItem(item: Internal.ItemStackJS);
        set mainHandItem(item: object);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: string);
        set legsArmorItem(item: Internal.ItemStackJS);
        set legsArmorItem(item: object);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: string);
        set headArmorItem(item: Internal.ItemStackJS);
        set headArmorItem(item: object);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: string);
        set feetArmorItem(item: Internal.ItemStackJS);
        set feetArmorItem(item: object);
        set offHandItem(item: string);
        set offHandItem(item: Internal.ItemStackJS);
        set offHandItem(item: object);
        set chestArmorItem(item: string);
        set chestArmorItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: object);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set mouseItem(item: string);
        set mouseItem(item: Internal.ItemStackJS);
        set mouseItem(item: object);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RhinoException extends Internal.RuntimeException {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocalizedMessage(): string
        getScriptStack(limit: number, hideFunction: string): any[]
        getScriptStack(): any[]
        notifyAll(): void
        initColumnNumber(columnNumber: number): void
        getCause(): Internal.Throwable
        notify(): void
        getScriptStackTrace(limit: number, functionName: string): string
        getScriptStackTrace(): string
        addSuppressed(arg0: Internal.Throwable): void
        getStackTrace(): Internal.StackTraceElement[]
        columnNumber(): number
        hashCode(): number
        getSuppressed(): Internal.Throwable[]
        details(): string
        printStackTrace(s: Internal.PrintWriter): void
        printStackTrace(s: Internal.PrintStream): void
        printStackTrace(): void
        initSourceName(sourceName: string): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        initLineSource(lineSource: string): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        lineSource(): string
        equals(arg0: any): boolean
        initLineNumber(lineNumber: number): void
        toString(): string
        sourceName(): string
        lineNumber(): number
        fillInStackTrace(): Internal.Throwable
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Panel extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        getContentHeight(): number
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        isDefaultScrollVertical(): boolean
        align(layout: Internal.WidgetLayout): number
        getGui(): Internal.BaseScreen
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        setOffset(flag: boolean): void
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        drawOffsetBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        updateMouseOver(mouseX: number, mouseY: number): void
        getScrollStep(): number
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget): void
        isMouseOver(): boolean
        onClosed(): void
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget
        openGui(): void
        setOnlyInteractWithWidgetsInside(value: boolean): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        setOnlyRenderWidgetsInside(value: boolean): void
        tick(): void
        setHeight(v: number): void
        addMouseOverText(list: Internal.TooltipList): void
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        refreshWidgets(): void
        isOffset(): boolean
        alignWidgets(): void
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        drawWidget(matrixStack: Internal.PoseStack, theme: Internal.Theme, widget: dev.ftb.mods.ftblibrary.ui.Widget, index: number, x: number, y: number, w: number, h: number): void
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        notify(): void
        isMouseOverAnyWidget(): boolean
        mouseReleased(button: Internal.MouseButton): void
        getScrollX(): number
        getScrollY(): number
        getContentWidth(): number
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        clearWidgets(): void
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        setScrollStep(s: number): void
        getWidgetType(): Internal.WidgetType
        movePanelScroll(dx: number, dy: number): boolean
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        getOnlyInteractWithWidgetsInside(): boolean
        getOnlyRenderWidgetsInside(): boolean
        addWidgets(): void
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getY(): number
        addAll(list: Internal.Iterable<dev.ftb.mods.ftblibrary.ui.Widget>): void
        equals(arg0: any): boolean
        scrollPanel(scroll: number): boolean
        toString(): string
        setScrollX(scroll: number): void
        getIngredientUnderMouse(): any
        setScrollY(scroll: number): void
        posX : number;
        parent : Internal.Panel;
        posY : number;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get scrollY(): number;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Promise <V> extends Internal.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(): Internal.Future<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.Promise<V>
        sync(): Internal.Future<V>
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        trySuccess(arg0: V): boolean
        syncUninterruptibly(): Internal.Promise<V>
        syncUninterruptibly(): Internal.Future<V>
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isCancellable(): boolean
        await(): Internal.Promise<V>
        await(): Internal.Future<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        isSuccess(): boolean
        setUncancellable(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
    }
    abstract class AbstractByteBuf extends Internal.ByteBuf {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        release(arg0: number): boolean
        release(): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        nioBufferCount(): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(arg0: number): boolean
        isReadable(): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        isWritable(arg0: number): boolean
        isWritable(): boolean
        notify(): void
        readChar(): string
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        hasMemoryAddress(): boolean
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readDouble(): number
        readUnsignedShortLE(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        copy(arg0: number, arg1: number): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        writeInt(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        readFloatLE(): number
        hasArray(): boolean
        getDoubleLE(arg0: number): number
        memoryAddress(): number
        maxFastWritableBytes(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: any): boolean
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBoolean(): boolean
        toString(): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        isDirect(): boolean
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getClass(): Internal.Class<any>
        getFloatLE(arg0: number): number
        readerIndex(): number
        readerIndex(arg0: number): Internal.ByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuf): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(): Internal.ByteBuffer
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        touch(arg0: any): Internal.ByteBuf
        touch(arg0: any): Internal.ReferenceCounted
        touch(): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
        discardSomeReadBytes(): Internal.ByteBuf
        duplicate(): Internal.ByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(): number
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        getChar(arg0: number): string
        retainedDuplicate(): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        readMedium(): number
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        readUnsignedShort(): number
        getMedium(arg0: number): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        notifyAll(): void
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        hashCode(): number
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readLongLE(): number
        readUnsignedMediumLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        isContiguous(): boolean
        writeDoubleLE(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICapabilitySerializable <T> extends Internal.ICapabilityProvider, Internal.INBTSerializable<T> {
        serializeNBT(): T
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        deserializeNBT(arg0: T): void
    }
    interface IRegistryDelegate <T> extends Internal.Supplier<T> {
        get(): T
        name(): ResourceLocation
        type(): Internal.Class<T>
    }
    abstract class RenderType extends Internal.RenderStateShard implements Internal.AccessorRenderType, Internal.RenderTypeExtension {
        getClass(): Internal.Class<any>
        handler$zpd000$cleanNoLighting(arg0: Internal.BufferBuilder, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        flywheel$getDrawBuffer(): Internal.DrawBuffer
        hashCode(): number
        static create_$md$204703$0(arg0: string, arg1: Internal.VertexFormat, arg2: Internal.VertexFormat$Mode, arg3: number, arg4: boolean, arg5: boolean, arg6: Internal.RenderType$CompositeState): Internal.RenderType$CompositeRenderType
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        handler$zpd000$setupNoLighting(arg0: Internal.BufferBuilder, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo): void
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ObjectFunction <V> extends Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class LongSerializationPolicy extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.LongSerializationPolicy
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.LongSerializationPolicy[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LongSerializationPolicy): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LongSerializationPolicy>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.LongSerializationPolicy>
        serialize(arg0: number): Internal.JsonElement
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly STRING : Internal.LongSerializationPolicy;
        static readonly DEFAULT : Internal.LongSerializationPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LongSerializationPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PrintStream extends Internal.FilterOutputStream implements Internal.Appendable, Internal.Closeable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        format(arg0: string, arg1: any[]): Internal.PrintStream
        format(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintStream
        checkError(): boolean
        notify(): void
        printf(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintStream
        printf(arg0: string, arg1: any[]): Internal.PrintStream
        print(arg0: boolean): void
        print(arg0: string): void
        print(arg0: string[]): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: string): void
        print(arg0: number): void
        print(arg0: any): void
        println(arg0: string): void
        println(arg0: any): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: string[]): void
        println(arg0: boolean): void
        println(): void
        println(arg0: string): void
        println(arg0: number): void
        println(arg0: number): void
        writeBytes(arg0: number[]): void
        flush(): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static nullOutputStream(): Internal.OutputStream
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
        write(arg0: number[]): void
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.PrintStream
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintStream
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.PrintStream
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Color4I extends Internal.Icon {
        redf(): number
        getClass(): Internal.Class<any>
        addBrightness(percent: number): Internal.Color4I
        rgba(): number
        static rgba(col: number): Internal.Color4I
        static rgba(r: number, g: number, b: number, a: number): Internal.Color4I
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getChatFormattingColor(formatting: Internal.ChatFormatting): Internal.Color4I
        static getChatFormattingColor(id: number): Internal.Color4I
        withAlpha(a: number): Internal.Color4I
        lerp(col: Internal.Color4I, m: number): Internal.Color4I
        notifyAll(): void
        withTint(arg0: Internal.Color4I): Internal.Icon
        withTint(col: Internal.Color4I): Internal.Color4I
        static rgb(r: number, g: number, b: number): Internal.Color4I
        static rgb(col: number): Internal.Color4I
        rgb(): number
        static rgb(color: Vec3): Internal.Color4I
        redi(): number
        notify(): void
        createPixelBuffer(): Internal.PixelBuffer
        hashCode(): number
        bluei(): number
        mutable(): Internal.MutableColor4I
        bluef(): number
        copy(): Internal.Icon
        copy(): Internal.Color4I
        hasPixelBuffer(): boolean
        combineWith(icon: Internal.Icon): Internal.Icon
        combineWith(icons: Internal.Icon[]): Internal.Icon
        getJson(): Internal.JsonElement
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        withBorder(color: Internal.Color4I, roundEdges: boolean): Internal.Icon
        alphaf(): number
        alphai(): number
        withColor(color: Internal.Color4I): Internal.Icon
        isEmpty(): boolean
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon
        draw(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        draw3D(matrixStack: Internal.PoseStack): void
        whiteIfEmpty(): Internal.Color4I
        static getIcon(id: string): Internal.Icon
        static getIcon(json: Internal.JsonElement): Internal.Icon
        static getIcon(id: ResourceLocation): Internal.Icon
        toStyle(): Internal.Style
        isMutable(): boolean
        getIngredient(): any
        static hsb(h: number, s: number, b: number): Internal.Color4I
        equals(o: any): boolean
        withPadding(padding: number): Internal.Icon
        withAlphaf(alpha: number): Internal.Color4I
        static fromJson(element: Internal.JsonElement): Internal.Color4I
        greenf(): number
        toString(): string
        static get256(id: number): Internal.Color4I
        static fromString(s: string): Internal.Color4I
        greeni(): number
        static readonly RED : Internal.Color4I;
        static readonly GRAY : Internal.Color4I;
        static readonly WHITE : Internal.Color4I;
        static readonly LIGHT_RED : Internal.Color4I;
        static readonly BLUE : Internal.Color4I;
        static readonly LIGHT_BLUE : Internal.Color4I;
        static readonly LIGHT_GREEN : Internal.Color4I;
        static readonly BLACK : Internal.Color4I;
        static readonly DARK_GRAY : Internal.Color4I;
        static readonly GREEN : Internal.Color4I;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorEntity {
        bookshelf$createHoverEvent(): Internal.HoverEvent
    }
    interface Type {
        getTypeName(): string
    }
    interface MapEncoder <A> extends Internal.Keyable {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.MapEncoder<B_>
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        comap<B_>(arg0: (arg0: B_) => A): Internal.MapEncoder<B_>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<A>
        encoder(): Internal.Encoder<A>
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
    }
    interface EntityAccess {
        getRemainingFireTicks(): number
        setRemainingFireTicks(arg0: number): void
    }
    interface NumberProvider extends Internal.LootContextUser {
    }
    abstract class LevelEventJS extends Internal.EventJS {
        cancel(): void
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        getLevel(): Internal.LevelJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        post(id: string, sub: string): boolean
        post(id: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        canCancel(): boolean
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder$Terminal <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
    }
    interface InterruptibleChannel extends Internal.Channel {
        isOpen(): boolean
        close(): void
    }
    class Either$Mu <R> implements Internal.K1 {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractStringBuilder implements Internal.Appendable, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        codePointAt(arg0: number): number
        notifyAll(): void
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        notify(): void
        substring(arg0: number): string
        substring(arg0: number, arg1: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        hashCode(): number
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        isEmpty(): boolean
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string): number
        lastIndexOf(arg0: string, arg1: number): number
        setLength(arg0: number): void
        equals(arg0: any): boolean
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: any): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2ObjectFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Readable {
        read(arg0: Internal.CharBuffer): number
    }
    interface Object2ByteFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        getByte(arg0: any): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        removeByte(arg0: any): number
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Date implements Internal.Serializable, Internal.Cloneable, Internal.Comparable<Internal.Date> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static UTC(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        before(arg0: Internal.Date): boolean
        getTime(): number
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Date): number
        notify(): void
        getHours(): number
        setHours(arg0: number): void
        hashCode(): number
        setSeconds(arg0: number): void
        getDate(): number
        static from(arg0: Internal.Instant): Internal.Date
        getMonth(): number
        after(arg0: Internal.Date): boolean
        setTime(arg0: number): void
        setMonth(arg0: number): void
        setMinutes(arg0: number): void
        static parse(arg0: string): number
        toInstant(): Internal.Instant
        setYear(arg0: number): void
        getDay(): number
        getMinutes(): number
        toGMTString(): string
        getSeconds(): number
        getTimezoneOffset(): number
        getYear(): number
        equals(arg0: any): boolean
        clone(): any
        setDate(arg0: number): void
        toString(): string
        toLocaleString(): string
        get date(): number;
        get hours(): number;
        get seconds(): number;
        get month(): number;
        get timezoneOffset(): number;
        get year(): number;
        get minutes(): number;
        get time(): number;
        get class(): Internal.Class<any>;
        get day(): number;
        set date(arg0: number);
        set seconds(arg0: number);
        set hours(arg0: number);
        set month(arg0: number);
        set year(arg0: number);
        set minutes(arg0: number);
        set time(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ObjectFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        get(arg0: any): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): V
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class RuntimeException extends Internal.Exception {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        printStackTrace(): void
        printStackTrace(arg0: Internal.PrintStream): void
        printStackTrace(arg0: Internal.PrintWriter): void
        getLocalizedMessage(): string
        notifyAll(): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        getCause(): Internal.Throwable
        notify(): void
        addSuppressed(arg0: Internal.Throwable): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        getStackTrace(): Internal.StackTraceElement[]
        hashCode(): number
        equals(arg0: any): boolean
        getSuppressed(): Internal.Throwable[]
        toString(): string
        fillInStackTrace(): Internal.Throwable
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FixedUnit extends Internal.Unit {
        getClass(): Internal.Class<any>
        mod(with_: Internal.Unit): Internal.Unit
        cos(): Internal.Unit
        log1p(): Internal.Unit
        deg(): Internal.Unit
        lt(with_: Internal.Unit): Internal.Unit
        atan(): Internal.Unit
        getAsInt(): number
        div(with_: Internal.Unit): Internal.Unit
        neg(): Internal.Unit
        shiftLeft(with_: Internal.Unit): Internal.Unit
        rad(): Internal.Unit
        sqrt(): Internal.Unit
        gte(with_: Internal.Unit): Internal.Unit
        neq(with_: Internal.Unit): Internal.Unit
        atan2(with_: Internal.Unit): Internal.Unit
        tan(): Internal.Unit
        add(with_: Internal.Unit): Internal.Unit
        newValue(v: number): Internal.Unit
        toBool(): Internal.Unit
        ceil(): Internal.Unit
        eq(with_: Internal.Unit): Internal.Unit
        shiftRight(with_: Internal.Unit): Internal.Unit
        sub(with_: Internal.Unit): Internal.Unit
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mul(with_: Internal.Unit): Internal.Unit
        log(): Internal.Unit
        log10(): Internal.Unit
        notifyAll(): void
        notify(): void
        not(): Internal.Unit
        min(with_: Internal.Unit): Internal.Unit
        hashCode(): number
        and(with_: Internal.Unit): Internal.Unit
        static of(value: number): Internal.FixedUnit
        get(): number
        pow(with_: Internal.Unit): Internal.Unit
        sin(): Internal.Unit
        xor(with_: Internal.Unit): Internal.Unit
        lte(with_: Internal.Unit): Internal.Unit
        floor(): Internal.Unit
        isFixed(): boolean
        sq(): Internal.Unit
        or(with_: Internal.Unit): Internal.Unit
        max(with_: Internal.Unit): Internal.Unit
        gt(with_: Internal.Unit): Internal.Unit
        abs(): Internal.Unit
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        append(sb: Internal.StringBuilder): void
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarEventInstance {
        getEvent(arg0: Internal.Map<string, Internal.LunarEvent>): Internal.LunarEvent
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        scheduledDay(): number
        notifyAll(): void
        active(arg0: number): boolean
        notify(): void
        getLunarEventKey(): string
        hashCode(): number
        setScheduledDay(arg0: number): void
        equals(arg0: any): boolean
        toString(): string
        getDaysUntil(arg0: number): number
        passed(arg0: number): boolean
        static readonly CODEC : Internal.Codec<Internal.LunarEventInstance>;
        get lunarEventKey(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CharBuffer extends Internal.Buffer implements Internal.Comparable<Internal.CharBuffer>, Internal.Appendable, Internal.CharSequence, Internal.Readable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.CharBuffer
        notifyAll(): void
        compareTo(arg0: Internal.CharBuffer): number
        compareTo(arg0: any): number
        notify(): void
        asReadOnlyBuffer(): Internal.CharBuffer
        put(arg0: Internal.CharBuffer): Internal.CharBuffer
        put(arg0: string, arg1: number, arg2: number): Internal.CharBuffer
        put(arg0: number, arg1: string[]): Internal.CharBuffer
        put(arg0: number, arg1: string): Internal.CharBuffer
        put(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer
        put(arg0: string[]): Internal.CharBuffer
        put(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        put(arg0: number, arg1: Internal.CharBuffer, arg2: number, arg3: number): Internal.CharBuffer
        put(arg0: string): Internal.CharBuffer
        put(arg0: string): Internal.CharBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.CharBuffer
        slice(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.CharBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        array(): string[]
        array(): any
        hashCode(): number
        get(): string
        get(arg0: number): string
        get(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        get(arg0: string[]): Internal.CharBuffer
        get(arg0: number, arg1: string[]): Internal.CharBuffer
        get(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer
        limit(arg0: number): Internal.CharBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.CharBuffer
        flip(): Internal.Buffer
        codePoints(): Internal.IntStream
        order(): Internal.ByteOrder
        hasArray(): boolean
        read(arg0: Internal.CharBuffer): number
        hasRemaining(): boolean
        isEmpty(): boolean
        clear(): Internal.CharBuffer
        clear(): Internal.Buffer
        length(): number
        duplicate(): Internal.CharBuffer
        duplicate(): Internal.Buffer
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        subSequence(arg0: number, arg1: number): Internal.CharBuffer
        remaining(): number
        static allocate(arg0: number): Internal.CharBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.CharBuffer
        mismatch(arg0: Internal.CharBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.CharBuffer
        reset(): Internal.Buffer
        toString(): string
        position(arg0: number): Internal.Buffer
        position(arg0: number): Internal.CharBuffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        static wrap(arg0: string[]): Internal.CharBuffer
        static wrap(arg0: Internal.CharSequence): Internal.CharBuffer
        static wrap(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer
        mark(): Internal.Buffer
        mark(): Internal.CharBuffer
        chars(): Internal.IntStream
        charAt(arg0: number): string
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.CharBuffer
        append(arg0: string): Internal.CharBuffer
        append(arg0: string): Internal.Appendable
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorDamageSource {
        botania_setBypassArmor(): Internal.DamageSource
    }
    class DataResult <R> implements Internal.App<Internal.DataResult$Mu, R> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static instance(): Internal.DataResult$Instance
        setPartial(arg0: R): Internal.DataResult<R>
        setPartial(arg0: () => R): Internal.DataResult<R>
        notifyAll(): void
        addLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>
        static partialGet<K_, V_>(arg0: (arg0: K_) => V_, arg1: () => string): (arg0: K_) => Internal.DataResult<V_>
        static error<R_>(arg0: string, arg1: R_): Internal.DataResult<R_>
        static error<R_>(arg0: string): Internal.DataResult<R_>
        static error<R_>(arg0: string, arg1: R_, arg2: Internal.Lifecycle): Internal.DataResult<R_>
        static error<R_>(arg0: string, arg1: Internal.Lifecycle): Internal.DataResult<R_>
        error(): Internal.Optional<Internal.DataResult$PartialResult<R>>
        notify(): void
        promotePartial(arg0: (arg0: string) => void): Internal.DataResult<R>
        result(): Internal.Optional<R>
        lifecycle(): Internal.Lifecycle
        setLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>
        hashCode(): number
        get(): Internal.Either<R, Internal.DataResult$PartialResult<R>>
        map<T_>(arg0: (arg0: R) => T_): Internal.DataResult<T_>
        resultOrPartial(arg0: (arg0: string) => void): Internal.Optional<R>
        apply2<R2_, S_>(arg0: (arg0: R, arg1: R2_) => S_, arg1: Internal.DataResult<R2_>): Internal.DataResult<S_>
        apply3<R2_, R3_, S_>(arg0: Internal.Function3<R, R2_, R3_, S_>, arg1: Internal.DataResult<R2_>, arg2: Internal.DataResult<R3_>): Internal.DataResult<S_>
        apply2stable<R2_, S_>(arg0: (arg0: R, arg1: R2_) => S_, arg1: Internal.DataResult<R2_>): Internal.DataResult<S_>
        ap<R2_>(arg0: Internal.DataResult<(arg0: R) => R2_>): Internal.DataResult<R2_>
        flatMap<R2_>(arg0: (arg0: R) => Internal.DataResult<R2_>): Internal.DataResult<R2_>
        mapError(arg0: (arg0: any) => any): Internal.DataResult<R>
        static unbox<R_>(arg0: Internal.App<Internal.DataResult$Mu, R_>): Internal.DataResult<R_>
        static success<R_>(arg0: R_, arg1: Internal.Lifecycle): Internal.DataResult<R_>
        static success<R_>(arg0: R_): Internal.DataResult<R_>
        equals(arg0: any): boolean
        getOrThrow(arg0: boolean, arg1: (arg0: string) => void): R
        toString(): string
        get class(): Internal.Class<any>;
        set partial(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LevelResource {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JsonObject extends Internal.JsonElement {
        getAsFloat(): number
        getClass(): Internal.Class<any>
        getAsByte(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAsBigDecimal(): Internal.BigDecimal
        notifyAll(): void
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        notify(): void
        getAsInt(): number
        remove(arg0: string): Internal.JsonElement
        isJsonPrimitive(): boolean
        getAsLong(): number
        isJsonObject(): boolean
        hashCode(): number
        get(arg0: string): Internal.JsonElement
        has(arg0: string): boolean
        keySet(): Internal.Set<string>
        getAsBigInteger(): Internal.BigInteger
        add(arg0: string, arg1: Internal.JsonElement): void
        getAsJsonObject(arg0: string): Internal.JsonObject
        getAsJsonObject(): Internal.JsonObject
        getAsJsonNull(): Internal.JsonNull
        entrySet(): Internal.Set<Internal.Map$Entry<string, Internal.JsonElement>>
        isJsonNull(): boolean
        getAsDouble(): number
        addProperty(arg0: string, arg1: string): void
        addProperty(arg0: string, arg1: boolean): void
        addProperty(arg0: string, arg1: string): void
        addProperty(arg0: string, arg1: Internal.Number): void
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonObject
        size(): number
        getAsJsonArray(arg0: string): Internal.JsonArray
        getAsJsonArray(): Internal.JsonArray
        getAsBoolean(): boolean
        getAsJsonPrimitive(arg0: string): Internal.JsonPrimitive
        getAsJsonPrimitive(): Internal.JsonPrimitive
        equals(arg0: any): boolean
        toString(): string
        getAsShort(): number
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ConstantUnit extends Internal.FixedUnit {
        getClass(): Internal.Class<any>
        mod(with_: Internal.Unit): Internal.Unit
        cos(): Internal.Unit
        log1p(): Internal.Unit
        deg(): Internal.Unit
        lt(with_: Internal.Unit): Internal.Unit
        atan(): Internal.Unit
        getAsInt(): number
        div(with_: Internal.Unit): Internal.Unit
        neg(): Internal.Unit
        shiftLeft(with_: Internal.Unit): Internal.Unit
        rad(): Internal.Unit
        sqrt(): Internal.Unit
        gte(with_: Internal.Unit): Internal.Unit
        neq(with_: Internal.Unit): Internal.Unit
        atan2(with_: Internal.Unit): Internal.Unit
        tan(): Internal.Unit
        add(with_: Internal.Unit): Internal.Unit
        newValue(v: number): Internal.Unit
        toBool(): Internal.Unit
        ceil(): Internal.Unit
        eq(with_: Internal.Unit): Internal.Unit
        shiftRight(with_: Internal.Unit): Internal.Unit
        sub(with_: Internal.Unit): Internal.Unit
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mul(with_: Internal.Unit): Internal.Unit
        log(): Internal.Unit
        log10(): Internal.Unit
        notifyAll(): void
        notify(): void
        not(): Internal.Unit
        min(with_: Internal.Unit): Internal.Unit
        hashCode(): number
        and(with_: Internal.Unit): Internal.Unit
        static of(value: number): Internal.FixedUnit
        get(): number
        pow(with_: Internal.Unit): Internal.Unit
        sin(): Internal.Unit
        xor(with_: Internal.Unit): Internal.Unit
        lte(with_: Internal.Unit): Internal.Unit
        floor(): Internal.Unit
        isFixed(): boolean
        sq(): Internal.Unit
        or(with_: Internal.Unit): Internal.Unit
        max(with_: Internal.Unit): Internal.Unit
        gt(with_: Internal.Unit): Internal.Unit
        abs(): Internal.Unit
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        append(sb: Internal.StringBuilder): void
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        readonly name : string;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockState extends Internal.BlockBehaviour$BlockStateBase implements Internal.IForgeBlockState, Internal.BlockStateFTBC {
        getNeighborTable(): Internal.Table<any, any, any>
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState
        getClass(): Internal.Class<any>
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState
        onBlockExploded(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Explosion): void
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction
        redirect$zlm000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean
        setRequiresToolKJS(arg0: boolean): void
        setMaterialKJS(arg0: Internal.Material): void
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        getFTBCIsWater(): boolean
        canStickTo(arg0: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number
        setDestroySpeedKJS(arg0: number): void
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<any>): boolean
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        setLightEmissionKJS(arg0: number): void
        isScaffolding(arg0: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean
        setNeighborTable(table: Internal.Table<any, any, any>): void
        setStateMap(newValue: Internal.FastMap<any>): void
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean
        handler$zpj000$onBlockCollision(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity, arg3: Internal.CallbackInfo): void
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isStickyBlock(): boolean
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        isSlimeBlock(): boolean
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getToolModifiedState(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[]
        getStateIndex(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean
        notifyAll(): void
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number
        onDestroyedByPlayer(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        notify(): void
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType
        hashCode(): number
        addRunningEffects(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity): boolean
        setStateIndex(newValue: number): void
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>
        handler$zma000$cacheStateTail(ci: Internal.CallbackInfo): void
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes
        onCaughtFire(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number
        getLightInfo(): Internal.BlockStateLightInfo
        setBedOccupied(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        getStateMap(): Internal.FastMap<any>
        getRespawnPosition(arg0: Internal.EntityType<any>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>
        handler$zma000$cacheStateHead(ci: Internal.CallbackInfo): void
        equals(arg0: any): boolean
        toString(): string
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        get stickyBlock(): boolean;
        get stateIndex(): number;
        get slimeBlock(): boolean;
        get fTBCIsWater(): boolean;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get lightInfo(): Internal.BlockStateLightInfo;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set materialKJS(arg0: Internal.Material);
        set requiresToolKJS(arg0: boolean);
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        set destroySpeedKJS(arg0: number);
        set lightEmissionKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PathMatcher {
        matches(arg0: Internal.Path): boolean
    }
    interface FontResourceManagerAccess {
        getFontSets(): Internal.Map<ResourceLocation, Internal.FontSet>
    }
    interface FocusListener extends Internal.EventListener {
        focusGained(arg0: Internal.FocusEvent): void
        focusLost(arg0: Internal.FocusEvent): void
    }
    class LazyOptional <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        resolve(): Internal.Optional<T>
        notifyAll(): void
        isPresent(): boolean
        invalidate(): void
        orElse(arg0: T): T
        notify(): void
        orElseThrow<X>(arg0: Internal.NonNullSupplier<X>): T
        static empty<T>(): Internal.LazyOptional<T>
        filter(arg0: Internal.NonNullPredicate<T>): Internal.Optional<T>
        cast<X>(): Internal.LazyOptional<X>
        orElseGet(arg0: Internal.NonNullSupplier<T>): T
        hashCode(): number
        equals(arg0: any): boolean
        ifPresent(arg0: Internal.NonNullConsumer<T>): void
        static of<T>(arg0: Internal.NonNullSupplier<T>): Internal.LazyOptional<T>
        toString(): string
        map<U>(arg0: Internal.NonNullFunction<T, U>): Internal.Optional<U>
        lazyMap<U>(arg0: Internal.NonNullFunction<T, U>): Internal.LazyOptional<U>
        addListener(arg0: Internal.NonNullConsumer<Internal.LazyOptional<T>>): void
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FTBQuestsKubeJSPlayerData extends Internal.FTBQuestsKubeJSTeamData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRelativeProgress(id: any): number
        notifyAll(): void
        getTaskProgress(id: any): number
        isStarted(id: any): boolean
        addProgress(id: any, progress: number): boolean
        getLocked(): boolean
        getFile(): Internal.QuestFile
        notify(): void
        setLocked(v: boolean): void
        changeProgress(id: any, consumer: (arg0: Internal.ProgressChange) => void): void
        getOnlineMembers(): Internal.EntityArrayList
        hashCode(): number
        equals(arg0: any): boolean
        canStartQuest(id: any): boolean
        reset(id: any): void
        toString(): string
        complete(id: any): void
        getData(): Internal.TeamData
        isCompleted(id: any): boolean
        get file(): Internal.QuestFile;
        get onlineMembers(): Internal.EntityArrayList;
        get data(): Internal.TeamData;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        set locked(v: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContextAction <T> {
        run(arg0: Internal.Context): T
    }
    interface MouseWheelListener extends Internal.EventListener {
        mouseWheelMoved(arg0: Internal.MouseWheelEvent): void
    }
    class VampirePlayerSpecialAttributes {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getJumpBoost(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isCannotInteract(): boolean
        toString(): string
        notify(): void
        setJumpBoost(arg0: number): void
        disguisedAs : Internal.IFaction<any>;
        isDBNO : boolean;
        invisible : boolean;
        half_invulnerable : boolean;
        eyeType : number;
        disguised : boolean;
        waterResistance : boolean;
        glowingEyes : boolean;
        blood_vision : boolean;
        fangType : number;
        bat : boolean;
        blood_vision_garlic : boolean;
        advanced_biter : boolean;
        get cannotInteract(): boolean;
        get class(): Internal.Class<any>;
        get jumpBoost(): number;
        set jumpBoost(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WindowListener extends Internal.EventListener {
        windowDeactivated(arg0: Internal.WindowEvent): void
        windowClosed(arg0: Internal.WindowEvent): void
        windowOpened(arg0: Internal.WindowEvent): void
        windowActivated(arg0: Internal.WindowEvent): void
        windowClosing(arg0: Internal.WindowEvent): void
        windowDeiconified(arg0: Internal.WindowEvent): void
        windowIconified(arg0: Internal.WindowEvent): void
    }
    interface PackResources extends Internal.AutoCloseable, Internal.IForgePackResources {
        close(): void
        isHidden(): boolean
    }
    interface Long2DoubleFunction extends Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ArsNouveauEnchantmentRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Level implements Internal.Comparable<Internal.Level>, Internal.Serializable {
        isMoreSpecificThan(level: Internal.Level): boolean
        isLessSpecificThan(level: Internal.Level): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static forName(name: string, intValue: number): Internal.Level
        static valueOf<T_>(enumType: Internal.Class<T_>, name: string): T_
        static valueOf(name: string): Internal.Level
        notifyAll(): void
        static values(): Internal.Level[]
        compareTo(other: any): number
        compareTo(other: Internal.Level): number
        isInRange(minLevel: Internal.Level, maxLevel: Internal.Level): boolean
        intLevel(): number
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Level>
        static getLevel(name: string): Internal.Level
        static toLevel(name: string, defaultLevel: Internal.Level): Internal.Level
        static toLevel(sArg: string): Internal.Level
        hashCode(): number
        getStandardLevel(): Internal.StandardLevel
        equals(other: any): boolean
        clone(): Internal.Level
        clone(): any
        name(): string
        toString(): string
        static readonly TRACE : Internal.Level;
        static readonly ALL : Internal.Level;
        static readonly CATEGORY : "Level";
        static readonly ERROR : Internal.Level;
        static readonly INFO : Internal.Level;
        static readonly FATAL : Internal.Level;
        static readonly DEBUG : Internal.Level;
        static readonly OFF : Internal.Level;
        static readonly WARN : Internal.Level;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Level>;
        get standardLevel(): Internal.StandardLevel;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PublicKey extends Internal.Key {
        getEncoded(): number[]
        getAlgorithm(): string
        getFormat(): string
    }
    interface ErrorReporter {
        runtimeError(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): Internal.EvaluatorException
        warning(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void
        error(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void
    }
    abstract class AbstractIntSet extends Internal.AbstractIntCollection implements Internal.Cloneable, Internal.IntSet {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        notify(): void
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.IntIterator
        iterator(): Internal.Iterator<any>
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        spliterator(): Internal.IntSpliterator
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.IntCollection): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.IntPredicate): boolean
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        toString(): string
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.IntCollection): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemKJS {
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        setFireResistantKJS(arg0: boolean): void
        setMaxDamageKJS(arg0: number): void
        setItemBuilderKJS(arg0: Internal.ItemBuilder): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        setBurnTimeKJS(arg0: number): void
        setRarityKJS(arg0: Internal.Rarity): void
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
    }
    abstract class Permission implements Internal.Guard, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        checkGuard(arg0: any): void
        newPermissionCollection(): Internal.PermissionCollection
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getActions(): string
        toString(): string
        implies(arg0: Internal.Permission): boolean
        notify(): void
        get name(): string;
        get class(): Internal.Class<any>;
        get actions(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Principal {
        getName(): string
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
    }
    interface AutoCloseable {
        close(): void
    }
    interface Long2FloatFunction extends Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class FontRenderContext {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isTransformed(): boolean
        notifyAll(): void
        notify(): void
        getAntiAliasingHint(): any
        usesFractionalMetrics(): boolean
        hashCode(): number
        equals(arg0: Internal.FontRenderContext): boolean
        equals(arg0: any): boolean
        toString(): string
        getTransformType(): number
        getFractionalMetricsHint(): any
        isAntiAliased(): boolean
        getTransform(): Internal.AffineTransform
        get transform(): Internal.AffineTransform;
        get antiAliased(): boolean;
        get transformed(): boolean;
        get transformType(): number;
        get class(): Internal.Class<any>;
        get fractionalMetricsHint(): any;
        get antiAliasingHint(): any;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerLevel extends net.minecraft.world.level.Level implements Internal.WorldGenLevel {
        handler$zpk000$wireBlockCallback(arg0: BlockPos, arg1: Internal.BlockState, arg2: Internal.BlockState, arg3: number, arg4: Internal.CallbackInfo): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        notifyAll(): void
        redirect$bnp000$getRedstonePowerAsCallFromNeighbours(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction): number
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void
        notify(): void
        removePlayer(arg0: Internal.ServerPlayer, arg1: boolean): void
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void
        handler$bnp000$updateComparatorOutputLevel(arg0: BlockPos, arg1: Internal.Block, arg2: Internal.CallbackInfo): void
        redirect$bbo000$onTickBlock(state: Internal.BlockState, level: Internal.ServerLevel, pos: BlockPos, random: Internal.Random): void
        invalidateCaps(): void
        getLunarContext(): Internal.LunarContext
        hashCode(): number
        increaseMaxEntityRadius(arg0: number): number
        handler$zom000$addFreshBlockEntities_HammerLib(arg0: Internal.Collection<any>, arg1: Internal.CallbackInfo): void
        removeEntityComplete(arg0: Internal.Entity, arg1: boolean): void
        close(): void
        unloadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean
        handler$zom000$tickBlockEntities_HammerLib(arg0: Internal.CallbackInfo): void
        loadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        getMaxEntityRadius(): number
        removeEntity(arg0: Internal.Entity, arg1: boolean): void
        removeEntity(arg0: Internal.Entity): void
        asKJS(): any
        reviveCaps(): void
        redirect$bbo000$onTickLiquid(state: Internal.FluidState, level: net.minecraft.world.level.Level, pos: BlockPos): void
        getLoadedBlockEntities_HammerLib(): Internal.List<any>
        equals(arg0: any): boolean
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
        toString(): string
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext
        redirect$bbn000$redirectTick(blockEntity: Internal.TickingBlockEntity): void
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        get loadedBlockEntities_HammerLib(): Internal.List<any>;
        set lunarContext(arg0: Internal.LunarContext);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JobAttributes$SidesType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly TWO_SIDED_SHORT_EDGE : Internal.JobAttributes$SidesType;
        static readonly TWO_SIDED_LONG_EDGE : Internal.JobAttributes$SidesType;
        static readonly ONE_SIDED : Internal.JobAttributes$SidesType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Event$Result extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Event$Result
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Event$Result[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Event$Result): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Event$Result>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Event$Result>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DENY : Internal.Event$Result;
        static readonly DEFAULT : Internal.Event$Result;
        static readonly ALLOW : Internal.Event$Result;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Event$Result>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeVertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface AccessorMob {
        getGoalSelector(): Internal.GoalSelector
        setLootTable(arg0: ResourceLocation): void
        botania_getAmbientSound(): Internal.SoundEvent
        getTargetSelector(): Internal.GoalSelector
    }
    interface Function16 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function4<T13, T14, T15, T16, R>>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function7<T10, T11, T12, T13, T14, T15, T16, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15, arg15: T16): R
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function3<T14, T15, T16, R>>
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15, arg1: T16) => R>
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function9<T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry15(): Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, (arg0: T16) => R>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function8<T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function6<T11, T12, T13, T14, T15, T16, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function5<T12, T13, T14, T15, T16, R>>
        curry(): (arg0: T1) => Internal.Function15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function11<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function10<T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function13<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function12<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function14<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>
    }
    class ClickEvent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AWTKeyStroke implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isOnKeyRelease(): boolean
        static getAWTKeyStroke(arg0: string): Internal.AWTKeyStroke
        static getAWTKeyStroke(arg0: string): Internal.AWTKeyStroke
        static getAWTKeyStroke(arg0: number, arg1: number): Internal.AWTKeyStroke
        static getAWTKeyStroke(arg0: number, arg1: number, arg2: boolean): Internal.AWTKeyStroke
        static getAWTKeyStroke(arg0: string, arg1: number): Internal.AWTKeyStroke
        notify(): void
        getKeyChar(): string
        hashCode(): number
        equals(arg0: any): boolean
        static getAWTKeyStrokeForEvent(arg0: Internal.KeyEvent): Internal.AWTKeyStroke
        toString(): string
        getModifiers(): number
        getKeyCode(): number
        getKeyEventType(): number
        get onKeyRelease(): boolean;
        get keyCode(): number;
        get keyEventType(): number;
        get keyChar(): string;
        get modifiers(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceLocationAccess {
        setPath(arg0: string): void
        setNamespace(arg0: string): void
    }
    interface ExecutorService extends Internal.Executor {
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        isTerminated(): boolean
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        execute(arg0: Internal.Runnable): void
        shutdown(): void
        isShutdown(): boolean
    }
    interface LongBinaryOperator {
        applyAsLong(arg0: number, arg1: number): number
    }
    interface ByteProcessor {
        process(arg0: number): boolean
    }
    class BigInteger extends Internal.Number implements Internal.Comparable<Internal.BigInteger> {
        bitLength(): number
        getClass(): Internal.Class<any>
        getLowestSetBit(): number
        mod(arg0: Internal.BigInteger): Internal.BigInteger
        byteValueExact(): number
        gcd(arg0: Internal.BigInteger): Internal.BigInteger
        compareTo(arg0: Internal.BigInteger): number
        compareTo(arg0: any): number
        sqrtAndRemainder(): Internal.BigInteger[]
        shiftLeft(arg0: number): Internal.BigInteger
        sqrt(): Internal.BigInteger
        shortValue(): number
        clearBit(arg0: number): Internal.BigInteger
        signum(): number
        add(arg0: Internal.BigInteger): Internal.BigInteger
        subtract(arg0: Internal.BigInteger): Internal.BigInteger
        floatValue(): number
        isProbablePrime(arg0: number): boolean
        doubleValue(): number
        nextProbablePrime(): Internal.BigInteger
        testBit(arg0: number): boolean
        shiftRight(arg0: number): Internal.BigInteger
        divideAndRemainder(arg0: Internal.BigInteger): Internal.BigInteger[]
        modPow(arg0: Internal.BigInteger, arg1: Internal.BigInteger): Internal.BigInteger
        intValueExact(): number
        andNot(arg0: Internal.BigInteger): Internal.BigInteger
        modInverse(arg0: Internal.BigInteger): Internal.BigInteger
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        longValueExact(): number
        notifyAll(): void
        setBit(arg0: number): Internal.BigInteger
        shortValueExact(): number
        notify(): void
        longValue(): number
        not(): Internal.BigInteger
        min(arg0: Internal.BigInteger): Internal.BigInteger
        and(arg0: Internal.BigInteger): Internal.BigInteger
        hashCode(): number
        pow(arg0: number): Internal.BigInteger
        xor(arg0: Internal.BigInteger): Internal.BigInteger
        divide(arg0: Internal.BigInteger): Internal.BigInteger
        multiply(arg0: Internal.BigInteger): Internal.BigInteger
        flipBit(arg0: number): Internal.BigInteger
        or(arg0: Internal.BigInteger): Internal.BigInteger
        max(arg0: Internal.BigInteger): Internal.BigInteger
        static valueOf(arg0: number): Internal.BigInteger
        intValue(): number
        abs(): Internal.BigInteger
        negate(): Internal.BigInteger
        toByteArray(): number[]
        equals(arg0: any): boolean
        toString(arg0: number): string
        toString(): string
        bitCount(): number
        static probablePrime(arg0: number, arg1: Internal.Random): Internal.BigInteger
        remainder(arg0: Internal.BigInteger): Internal.BigInteger
        byteValue(): number
        static readonly ZERO : Internal.BigInteger;
        static readonly ONE : Internal.BigInteger;
        static readonly TEN : Internal.BigInteger;
        static readonly TWO : Internal.BigInteger;
        get lowestSetBit(): number;
        get class(): Internal.Class<any>;
        set bit(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function4 <T1, T2, T3, T4, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4): R
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4) => R>
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3, arg1: T4) => R
        curry(): (arg0: T1) => Internal.Function3<T2, T3, T4, R>
    }
    abstract class EntityInstance <E> extends Internal.AbstractInstance implements Internal.LightListener, Internal.MovingListener {
        getClass(): Internal.Class<any>
        init(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        notifyAll(): void
        getInstancePosition(): Internal.Vector3f
        getInstancePosition(arg0: number): Internal.Vector3f
        update(arg0: Internal.LightProvider): boolean
        update(): void
        updateLight(): void
        notify(): void
        remove(): void
        getWorldPosition(): BlockPos
        getVolume(): Internal.ImmutableBox
        getVolume(): Internal.GridAlignedBB
        hashCode(): number
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        equals(arg0: any): boolean
        toString(): string
        shouldReset(): boolean
        status(): Internal.ListenerStatus
        readonly world : net.minecraft.world.level.Level;
        get volume(): Internal.GridAlignedBB;
        get worldPosition(): BlockPos;
        get instancePosition(): Internal.Vector3f;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorModelManager {
        getBakedRegistry(): Internal.Map<ResourceLocation, Internal.BakedModel>
    }
    interface ObjectSet <K> extends Internal.ObjectCollection<K>, Internal.Set<K> {
        add(arg0: K): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: K) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: K) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        size(): number
        addAll(arg0: Internal.Collection<K>): boolean
        stream(): Internal.Stream<K>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<K>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface ChannelId extends Internal.Serializable, Internal.Comparable<Internal.ChannelId> {
        asShortText(): string
        compareTo(arg0: Internal.ChannelId): number
        asLongText(): string
    }
    class Block extends Internal.BlockBehaviour implements Internal.ItemLike, Internal.IForgeBlock {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState
        getClass(): Internal.Class<any>
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction
        getTags(): Internal.Set<ResourceLocation>
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean
        setMaterialKJS(arg0: Internal.Material): void
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        setExplosionResistanceKJS(arg0: number): void
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean
        setJumpFactorKJS(arg0: number): void
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean
        getMaterial(): Internal.Material
        isStickyBlock(arg0: Internal.BlockState): boolean
        setSoundTypeKJS(arg0: Internal.SoundType): void
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes
        getBlockBuilderKJS(): Internal.BlockBuilder
        isSlimeBlock(arg0: Internal.BlockState): boolean
        getRegistryType(): Internal.Class<Internal.Block>
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean
        notifyAll(): void
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean
        getId(): string
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        notify(): void
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean
        getRenderPropertiesInternal(): any
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType
        hashCode(): number
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean
        initializeClient(arg0: (arg0: Internal.IBlockRenderProperties) => void): void
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack
        setFrictionKJS(arg0: number): void
        setHasCollisionKJS(arg0: boolean): void
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number
        getRegistryName(): ResourceLocation
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Block
        setRegistryName(arg0: string): Internal.Block
        setRegistryName(arg0: string, arg1: string): Internal.Block
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        setIsRandomlyTickingKJS(arg0: boolean): void
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>
        equals(arg0: any): boolean
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        setSpeedFactorKJS(arg0: number): void
        setBlockBuilderKJS(b: Internal.BlockBuilder): void
        toString(): string
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): Internal.Material;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: Internal.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P16 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelManager extends Internal.SimplePreparableReloadListener<any> implements Internal.AutoCloseable, Internal.AccessorModelManager {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getModel(arg0: ResourceLocation): Internal.BakedModel
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getBakedRegistry(): Internal.Map<any, any>
        toString(): string
        close(): void
        notify(): void
        get bakedRegistry(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StartupEventJS extends Internal.EventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        post(id: string): boolean
        post(id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        canCancel(): boolean
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InventoryFilterItem$FilterSlot {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly x : number;
        readonly y : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ConstantDesc {
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
    }
    interface ToDoubleFunction <T> {
        applyAsDouble(arg0: T): number
    }
    class ByteOrder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static nativeOrder(): Internal.ByteOrder
        toString(): string
        notify(): void
        static readonly BIG_ENDIAN : Internal.ByteOrder;
        static readonly LITTLE_ENDIAN : Internal.ByteOrder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ForgeRegistryEntry <V> implements Internal.IForgeRegistryEntry<V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<V>
        getRegistryName(): ResourceLocation
        toString(): string
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): V
        setRegistryName(arg0: string): V
        setRegistryName(arg0: string, arg1: string): V
        notify(): void
        readonly delegate : () => V;
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableSet <E> extends Internal.ImmutableCollection<any> implements Internal.Set<E> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableSet<E_>
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableSet<E_>
        static of<E_>(arg0: E_): Internal.ImmutableSet<E_>
        static of<E_>(): Internal.ImmutableSet<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableSet<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableSet<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableSet<E_>
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        static builder<E_>(): Internal.ImmutableSet$Builder<E_>
        parallelStream(): Internal.Stream<E>
        static toImmutableSet<E_>(): Internal.Collector<E_, any, Internal.ImmutableSet<E_>>
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableSet<E_>
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableSet<E_>
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableSet<E_>
        static copyOf<E_>(arg0: Internal.Collection<E_>): Internal.ImmutableSet<E_>
        removeIf(arg0: (arg0: E) => boolean): boolean
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableSet$Builder<E_>
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Item$Properties {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        setNoRepair(): Internal.Item$Properties
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Entity extends Internal.CapabilityProvider<any> implements Internal.Nameable, net.minecraft.world.level.entity.EntityAccess, Internal.CommandSource, Internal.IForgeEntity, Internal.LambDynamicLight, Internal.AccessorEntity, vazkii.botania.mixin.AccessorEntity, Internal.EntityAccess, Internal.EntityKJS, Internal.EntityAccessor {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        isDynamicLightEnabled(): boolean
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        revive(): void
        dynamicLightTick(): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        notify(): void
        hashCode(): number
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        asKJS(): any
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set remainingFireTicks(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Comparable <T> {
        compareTo(arg0: T): number
    }
    interface IForgeItemStackMixin {
    }
    class SearchRegistry implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Subject implements Internal.Serializable {
        getClass(): Internal.Class<any>
        static getSubject(arg0: Internal.AccessControlContext): Internal.Subject
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPrivateCredentials(): Internal.Set<any>
        getPrivateCredentials<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>
        notifyAll(): void
        getPrincipals(): Internal.Set<Internal.Principal>
        getPrincipals<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>
        notify(): void
        getPublicCredentials<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>
        getPublicCredentials(): Internal.Set<any>
        static doAsPrivileged<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T_>, arg2: Internal.AccessControlContext): T_
        static doAsPrivileged<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T_>, arg2: Internal.AccessControlContext): T_
        static doAs<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T_>): T_
        static doAs<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T_>): T_
        isReadOnly(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        setReadOnly(): void
        get privateCredentials(): Internal.Set<any>;
        get principals(): Internal.Set<Internal.Principal>;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get publicCredentials(): Internal.Set<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NonNullFunction <T, R> {
        apply(arg0: T): R
    }
    class DataResult$Instance extends Internal.Enum<any> implements Internal.Applicative<Internal.DataResult$Mu, any> {
        getClass(): Internal.Class<any>
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DataResult$Instance): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DataResult$Instance>>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>): Internal.Products$P11<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>): Internal.Products$P10<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>): Internal.Products$P9<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>, arg14: Internal.App<Internal.DataResult$Mu, T15_>, arg15: Internal.App<Internal.DataResult$Mu, T16_>): Internal.Products$P16<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>, arg14: Internal.App<Internal.DataResult$Mu, T15_>): Internal.Products$P15<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>): Internal.Products$P14<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>): Internal.Products$P13<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>): Internal.Products$P12<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>
        group<T1_, T2_, T3_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>): Internal.Products$P3<Internal.DataResult$Mu, T1_, T2_, T3_>
        group<T1_, T2_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>): Internal.Products$P2<Internal.DataResult$Mu, T1_, T2_>
        group<T1_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>): Internal.Products$P1<Internal.DataResult$Mu, T1_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>): Internal.Products$P8<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>): Internal.Products$P7<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>): Internal.Products$P6<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_>
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>): Internal.Products$P5<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_>
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>): Internal.Products$P4<Internal.DataResult$Mu, T1_, T2_, T3_, T4_>
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>): Internal.App<Internal.DataResult$Mu, R_>
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>): Internal.App<Internal.DataResult$Mu, R_>
        lift2<A_, B_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Internal.DataResult$Mu, A_>, arg1: Internal.App<Internal.DataResult$Mu, B_>) => Internal.App<Internal.DataResult$Mu, R_>
        lift1<A_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_) => R_>): (arg0: Internal.App<Internal.DataResult$Mu, A_>) => Internal.App<Internal.DataResult$Mu, R_>
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, T9_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, R_>>
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, R_>>
        ap<A_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_) => R_>, arg1: Internal.App<Internal.DataResult$Mu, A_>): Internal.App<Internal.DataResult$Mu, R_>
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Internal.DataResult$Mu, A_>): Internal.App<Internal.DataResult$Mu, R_>
        name(): string
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>, arg15: Internal.App<Internal.DataResult$Mu, T15_>, arg16: Internal.App<Internal.DataResult$Mu, T16_>): Internal.App<Internal.DataResult$Mu, R_>
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>): Internal.App<Internal.DataResult$Mu, R_>
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>): Internal.App<Internal.DataResult$Mu, R_>
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>, arg15: Internal.App<Internal.DataResult$Mu, T15_>): Internal.App<Internal.DataResult$Mu, R_>
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>): Internal.App<Internal.DataResult$Mu, R_>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        static values(): Internal.DataResult$Instance[]
        notify(): void
        point<A_>(arg0: A_): Internal.App<Internal.DataResult$Mu, A_>
        getDeclaringClass(): Internal.Class<Internal.DataResult$Instance>
        hashCode(): number
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Internal.DataResult$Mu, T_>): Internal.App<Internal.DataResult$Mu, R_>
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Internal.DataResult$Mu, A_>, arg2: Internal.App<Internal.DataResult$Mu, B_>): Internal.App<Internal.DataResult$Mu, R_>
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>): Internal.App<Internal.DataResult$Mu, R_>
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>): Internal.App<Internal.DataResult$Mu, R_>
        ap2<A_, B_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Internal.DataResult$Mu, A_>, arg2: Internal.App<Internal.DataResult$Mu, B_>): Internal.App<Internal.DataResult$Mu, R_>
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>): Internal.App<Internal.DataResult$Mu, R_>
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>): Internal.App<Internal.DataResult$Mu, R_>
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>): Internal.App<Internal.DataResult$Mu, R_>
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>): Internal.App<Internal.DataResult$Mu, R_>
        static valueOf(arg0: string): Internal.DataResult$Instance
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>): Internal.App<Internal.DataResult$Mu, R_>
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>): Internal.App<Internal.DataResult$Mu, R_>
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>): Internal.App<Internal.DataResult$Mu, R_>
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>): Internal.App<Internal.DataResult$Mu, R_>
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>): Internal.App<Internal.DataResult$Mu, R_>
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>): Internal.App<Internal.DataResult$Mu, R_>
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>): Internal.App<Internal.DataResult$Mu, R_>
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>): Internal.App<Internal.DataResult$Mu, R_>
        equals(arg0: any): boolean
        toString(): string
        ordinal(): number
        static readonly INSTANCE : Internal.DataResult$Instance;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DataResult$Instance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ServerLevelAccessor extends Internal.LevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    abstract class BaseScreen extends Internal.Panel implements Internal.IOpenableScreen {
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        setY(v: number): void
        setX(v: number): void
        shouldDraw(): boolean
        getContentHeight(): number
        isDefaultScrollVertical(): boolean
        openYesNo(title: Internal.Component, desc: Internal.Component, callback: Internal.Runnable): void
        drawForeground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static getClipboardString(): string
        onInit(): boolean
        setOffset(flag: boolean): void
        getScrollStep(): number
        getMouseY(): number
        onClosed(): void
        isMouseOver(widget: dev.ftb.mods.ftblibrary.ui.Widget): boolean
        isMouseOver(x: number, y: number, w: number, h: number): boolean
        isMouseOver(): boolean
        getTheme(): Internal.Theme
        getMouseX(): number
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget
        openGui(): void
        initGui(): void
        addMouseOverText(list: Internal.TooltipList): void
        playClickSound(): void
        isEnabled(): boolean
        handleClick(scheme: string, path: string): boolean
        handleClick(click: string): boolean
        refreshWidgets(): void
        isOffset(): boolean
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        openYesNoFull(title: Internal.Component, desc: Internal.Component, callback: Internal.BooleanConsumer): void
        onClosedByKey(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        drawWidget(matrixStack: Internal.PoseStack, theme: Internal.Theme, widget: dev.ftb.mods.ftblibrary.ui.Widget, index: number, x: number, y: number, w: number, h: number): void
        shouldAddMouseOverText(): boolean
        notify(): void
        mouseReleased(button: Internal.MouseButton): void
        getScrollX(): number
        getContentWidth(): number
        getScrollY(): number
        getPartialTicks(): number
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        drawDefaultBackground(matrixStack: Internal.PoseStack): boolean
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        setScrollStep(s: number): void
        updateGui(mx: number, my: number, pt: number): void
        getWidgetType(): Internal.WidgetType
        doesGuiPauseGame(): boolean
        movePanelScroll(dx: number, dy: number): boolean
        getPrevScreen(): Internal.Screen
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        getOnlyInteractWithWidgetsInside(): boolean
        addWidgets(): void
        openContextMenu(panel: Internal.Panel): void
        openContextMenu(menu: Internal.List<Internal.ContextMenuItem>): Internal.ContextMenu
        addAll(list: Internal.Iterable<dev.ftb.mods.ftblibrary.ui.Widget>): void
        equals(arg0: any): boolean
        scrollPanel(scroll: number): boolean
        toString(): string
        setScrollX(scroll: number): void
        setScrollY(scroll: number): void
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        getClass(): Internal.Class<any>
        collidesWith(x: number, y: number, w: number, h: number): boolean
        acceptGhostIngredient(ingredient: any): void
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        align(layout: Internal.WidgetLayout): number
        getGui(): Internal.BaseScreen
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        drawOffsetBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        updateMouseOver(mouseX: number, mouseY: number): void
        getScreen(): com.mojang.blaze3d.platform.Window
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget): void
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        setOnlyInteractWithWidgetsInside(value: boolean): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        setOnlyRenderWidgetsInside(value: boolean): void
        tick(): void
        setHeight(v: number): void
        alignWidgets(): void
        mouseScrolled(scroll: number): boolean
        notifyAll(): void
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        isMouseOverAnyWidget(): boolean
        setSize(w: number, h: number): void
        hashCode(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        clearWidgets(): void
        getCursor(): Internal.CursorType
        getOnlyRenderWidgetsInside(): boolean
        onBack(): void
        getX(): number
        getY(): number
        onPostInit(): void
        getIngredientUnderMouse(): any
        itemRenderer : Internal.ItemRenderer;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        contextMenu : Internal.Panel;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get theme(): Internal.Theme;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get prevScreen(): Internal.Screen;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get scrollY(): number;
        get gui(): Internal.BaseScreen;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Recipe <C> {
    }
    abstract class PathfinderMob extends Internal.Mob {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        setLootTable(arg0: ResourceLocation): void
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        dynamicLightTick(): void
        getGoalSelector(): Internal.GoalSelector
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        botania_getAmbientSound(): Internal.SoundEvent
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getClassification(arg0: boolean): Internal.MobCategory
        getTargetSelector(): Internal.GoalSelector
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get goalSelector(): Internal.GoalSelector;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get targetSelector(): Internal.GoalSelector;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set lootTable(arg0: ResourceLocation);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoubleStream$DoubleMapMultiConsumer {
        accept(arg0: number, arg1: Internal.DoubleConsumer): void
    }
    class AccessControlContext {
        getClass(): Internal.Class<any>
        checkPermission(arg0: Internal.Permission): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getDomainCombiner(): Internal.DomainCombiner
        toString(): string
        notify(): void
        get domainCombiner(): Internal.DomainCombiner;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ListJS extends Internal.ArrayList<any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>
        shift(): any
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        static orSelf(o: any): Internal.ListJS
        parallelStream(): Internal.Stream<any>
        indexOf(arg0: any): number
        add(value: any): boolean
        add(index: number, value: any): void
        appendString(builder: Internal.StringBuilder): void
        spliterator(): Internal.Spliterator<any>
        sort(arg0: Internal.Comparator<any>): void
        push(o: any[]): Internal.ListJS
        removeIf(arg0: (arg0: any) => boolean): boolean
        contains(arg0: any): boolean
        toJson(): Internal.JsonArray
        toJson(): Internal.JsonElement
        size(): number
        listIterator(): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.ListIterator<any>
        ensureCapacity(arg0: number): void
        static nbt(list: any): Internal.CollectionTag<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(o: any): boolean
        remove(index: number): any
        pop(): any
        toNBT(): Internal.Tag
        toNBT(): Internal.CollectionTag<any>
        stream(): Internal.Stream<any>
        hashCode(): number
        get(arg0: number): any
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: string[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(o: any): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static json(array: any): Internal.JsonArray
        copy(): Internal.Copyable
        copy(): Internal.ListJS
        map(transformer: (arg0: any) => any): Internal.ListJS
        subList(arg0: number, arg1: number): Internal.List<any>
        trimToSize(): void
        set(arg0: number, arg1: any): any
        onChanged(o: any): void
        forEach(arg0: (arg0: any) => void): void
        splice(pos: number, deleteCount: number, items: any[]): Internal.ListJS
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        static ofArray(array: any): Internal.ListJS
        reverse(): Internal.ListJS
        filter(predicate: (arg0: any) => boolean): Internal.ListJS
        lastIndexOf(arg0: any): number
        addAll(index: number, c: Internal.Collection<any>): boolean
        addAll(c: Internal.Collection<any>): boolean
        equals(arg0: any): boolean
        clone(): any
        getLength(): number
        toString(): string
        unshift(o: any[]): Internal.ListJS
        retainAll(arg0: Internal.Collection<any>): boolean
        changeListener : Internal.ChangeListener<Internal.ListJS>;
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FontSet implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ReferenceCounted {
        refCnt(): number
        release(arg0: number): boolean
        release(): boolean
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.ReferenceCounted
        touch(arg0: any): Internal.ReferenceCounted
        touch(): Internal.ReferenceCounted
    }
    interface IForgeBlockState {
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState
        onBlockExploded(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Explosion): void
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number
        onDestroyedByPlayer(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType
        canStickTo(arg0: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void
        addRunningEffects(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity): boolean
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<any>): boolean
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes
        isScaffolding(arg0: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean
        onCaughtFire(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number
        setBedOccupied(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean
        getRespawnPosition(arg0: Internal.EntityType<any>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isStickyBlock(): boolean
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        isSlimeBlock(): boolean
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getToolModifiedState(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[]
    }
    interface PrimitiveIterator$OfDouble extends Internal.PrimitiveIterator<number, Internal.DoubleConsumer> {
        next(): number
        next(): any
        hasNext(): boolean
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: Internal.DoubleConsumer): void
        remove(): void
        nextDouble(): number
    }
    interface BakedQuadAccess {
        setVertices(arg0: number[]): void
    }
    interface ProfilerFiller {
    }
    class RenderType$CompositeState {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Opens implements Internal.Comparable<Internal.ModuleDescriptor$Opens> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isQualified(): boolean
        toString(): string
        source(): string
        compareTo(arg0: Internal.ModuleDescriptor$Opens): number
        compareTo(arg0: any): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>
        targets(): Internal.Set<string>
        notify(): void
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EventListener {
    }
    class Rarity extends Internal.Enum<any> implements Internal.IExtensibleEnum {
        init(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Rarity
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Rarity[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Rarity): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Rarity>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Rarity>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        static create(arg0: string, arg1: Internal.ChatFormatting): Internal.Rarity
        toString(): string
        ordinal(): number
        static readonly RARE : Internal.Rarity;
        static readonly EPIC : Internal.Rarity;
        static readonly UNCOMMON : Internal.Rarity;
        static readonly COMMON : Internal.Rarity;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Rarity>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityJS implements Internal.MessageSender, Internal.WrappedJS {
        setY(y: number): void
        setX(x: number): void
        isLiving(): boolean
        isOnScoreboardTeam(teamID: string): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        getTags(): Internal.Set<string>
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        getHasCustomName(): boolean
        setInvisible(invisible: boolean): void
        runCommandSilent(command: string): number
        isBoss(): boolean
        getDistanceSq(x: number, y: number, z: number): number
        getDistanceSq(pos: BlockPos): number
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        getServer(): Internal.ServerJS
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getDisplayName(): Internal.Text
        getType(): string
        setCustomNameAlwaysVisible(b: boolean): void
        addMotion(x: number, y: number, z: number): void
        isInvisible(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isUnderWater(): boolean
        getEyeHeight(): number
        notify(): void
        getFallDistance(): number
        setOnFire(seconds: number): void
        removePassengers(): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        getDistance(x: number, y: number, z: number): number
        getDistance(pos: BlockPos): number
        setStatusMessage(message: Internal.Component): void
        isSwimming(): boolean
        getCustomName(): Internal.Text
        getStepHeight(): number
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        isMonster(): boolean
        equals(arg0: any): boolean
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        toString(): string
        isOnGround(): boolean
        isSilent(): boolean
        isPassenger(e: Internal.EntityJS): boolean
        getClass(): Internal.Class<any>
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        getName(): Internal.Text
        setFallDistance(fallDistance: number): void
        setCustomName(name: Internal.Component): void
        setStepHeight(stepHeight: number): void
        tell(message: Internal.Component): void
        getTeamId(): string
        isWaterCreature(): boolean
        setNoClip(noClip: boolean): void
        setPosition(x: number, y: number, z: number): void
        setPosition(block: Internal.BlockContainerJS): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        setFullNBT(nbt: Internal.CompoundTag): void
        getNoClip(): boolean
        getFullNBT(): Internal.CompoundTag
        setYaw(yaw: number): void
        isAlive(): boolean
        getYaw(): number
        setNoGravity(noGravity: boolean): void
        isPlayer(): boolean
        isCrouching(): boolean
        notifyAll(): void
        getId(): Internal.UUID
        getTicksExisted(): number
        setSilent(isSilent: boolean): void
        hashCode(): number
        isFrame(): boolean
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        getCustomNameAlwaysVisible(): boolean
        setMotionZ(z: number): void
        setMotionY(y: number): void
        getBlock(): Internal.BlockContainerJS
        setMotionX(x: number): void
        isInWater(): boolean
        dismountRidingEntity(): void
        isAmbientCreature(): boolean
        rayTrace(distance: number): Internal.RayTraceResultJS
        isInvulnerable(): boolean
        getX(): number
        spawn(): void
        getY(): number
        getZ(): number
        isPeacefulCreature(): boolean
        getMotionZ(): number
        getMotionX(): number
        getNoGravity(): boolean
        getMotionY(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get customName(): Internal.Text;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get stepHeight(): number;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get player(): boolean;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set motionZ(z: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set fallDistance(fallDistance: number);
        set motionX(x: number);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set invulnerable(invulnerable: boolean);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS);
        set pitch(pitch: number);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessScreen {
        getRenderables(): Internal.List<Internal.Widget>
    }
    abstract class Mob extends Internal.LivingEntity implements Internal.AccessorMob {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        setLootTable(arg0: ResourceLocation): void
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        dynamicLightTick(): void
        getGoalSelector(): Internal.GoalSelector
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        botania_getAmbientSound(): Internal.SoundEvent
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getClassification(arg0: boolean): Internal.MobCategory
        getTargetSelector(): Internal.GoalSelector
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get goalSelector(): Internal.GoalSelector;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get targetSelector(): Internal.GoalSelector;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set lootTable(arg0: ResourceLocation);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Supplier <T> {
        get(): T
    }
    class FireworksJS$Explosion {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        trail : boolean;
        readonly fadeColors : Internal.IntOpenHashSet;
        shape : Internal.FireworksJS$Shape;
        flicker : boolean;
        readonly colors : Internal.IntOpenHashSet;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Key extends Internal.Serializable {
        getEncoded(): number[]
        getAlgorithm(): string
        getFormat(): string
    }
    class TextComponent extends Internal.BaseComponent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getString(): string
        notify(): void
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemFiltersStack {
        getInventoryFilterData(): Internal.ItemInventory
        createDataIF(item: Internal.Item): any
        getItemFiltersData(): any
        getStringValueFilterData(): Internal.StringValueData<any>
    }
    class ParsePosition {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getIndex(): number
        hashCode(): number
        setIndex(arg0: number): void
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        setErrorIndex(arg0: number): void
        getErrorIndex(): number
        get errorIndex(): number;
        get index(): number;
        get class(): Internal.Class<any>;
        set errorIndex(arg0: number);
        set index(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecipeType <T> {
    }
    class RewardAutoClaim extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.RewardAutoClaim
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.RewardAutoClaim[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.RewardAutoClaim): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RewardAutoClaim>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.RewardAutoClaim>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DISABLED : Internal.RewardAutoClaim;
        static readonly NO_TOAST : Internal.RewardAutoClaim;
        static readonly INVISIBLE : Internal.RewardAutoClaim;
        static readonly NAME_MAP : Internal.NameMap<Internal.RewardAutoClaim>;
        static readonly NAME_MAP_NO_DEFAULT : Internal.NameMap<Internal.RewardAutoClaim>;
        static readonly ENABLED : Internal.RewardAutoClaim;
        id : string;
        static readonly DEFAULT : Internal.RewardAutoClaim;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RewardAutoClaim>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Builder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mainClass(arg0: string): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
        exports(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        exports(arg0: string): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.ModuleDescriptor$Exports): Internal.ModuleDescriptor$Builder
        notifyAll(): void
        packages(arg0: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        version(arg0: string): Internal.ModuleDescriptor$Builder
        version(arg0: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder
        notify(): void
        build(): Internal.ModuleDescriptor
        hashCode(): number
        provides(arg0: string, arg1: Internal.List<string>): Internal.ModuleDescriptor$Builder
        provides(arg0: Internal.ModuleDescriptor$Provides): Internal.ModuleDescriptor$Builder
        equals(arg0: any): boolean
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
        opens(arg0: string): Internal.ModuleDescriptor$Builder
        opens(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        opens(arg0: Internal.ModuleDescriptor$Opens): Internal.ModuleDescriptor$Builder
        toString(): string
        uses(arg0: string): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string, arg2: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.ModuleDescriptor$Requires): Internal.ModuleDescriptor$Builder
        requires(arg0: string): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Class <T> implements Internal.Serializable, Internal.GenericDeclaration, Internal.Type, Internal.AnnotatedElement, Internal.TypeDescriptor$OfField<Internal.Class<any>>, Internal.Constable {
        getModule(): Internal.Module
        getClass(): Internal.Class<any>
        isSealed(): boolean
        getResource(arg0: string): Internal.URL
        getName(): string
        isLocalClass(): boolean
        isSynthetic(): boolean
        getCanonicalName(): string
        getMethod(arg0: string, arg1: Internal.Class<any>[]): Internal.Method
        describeConstable(): Internal.Optional<Internal.ClassDesc>
        getDeclaredFields(): Internal.Field[]
        isMemberClass(): boolean
        cast(arg0: any): T
        isInstance(arg0: any): boolean
        getEnclosingMethod(): Internal.Method
        getPermittedSubclasses(): Internal.Class<any>[]
        getSigners(): any[]
        getTypeParameters(): any[]
        isInterface(): boolean
        getPackage(): Internal.Package
        arrayType(): Internal.TypeDescriptor$OfField<any>
        arrayType(): Internal.Class<any>
        getNestHost(): Internal.Class<any>
        asSubclass<U_>(arg0: Internal.Class<U_>): Internal.Class<U_>
        getField(arg0: string): Internal.Field
        descriptorString(): string
        getInterfaces(): Internal.Class<any>[]
        getAnnotatedInterfaces(): Internal.AnnotatedType[]
        newInstance(): T
        getFields(): Internal.Field[]
        getAnnotation<A_>(arg0: Internal.Class<A_>): A_
        getRecordComponents(): any[]
        getComponentType(): Internal.Class<any>
        getDeclaredAnnotation<A_>(arg0: Internal.Class<A_>): A_
        getSimpleName(): string
        isArray(): boolean
        getPackageName(): string
        getMethods(): Internal.Method[]
        isPrimitive(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isAnnotation(): boolean
        getProtectionDomain(): Internal.ProtectionDomain
        getDeclaredConstructors(): Internal.Constructor<any>[]
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        desiredAssertionStatus(): boolean
        getNestMembers(): Internal.Class<any>[]
        getGenericInterfaces(): Internal.Type[]
        getClassLoader(): Internal.ClassLoader
        isAssignableFrom(arg0: Internal.Class<any>): boolean
        notify(): void
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaredMethods(): Internal.Method[]
        getDeclaringClass(): Internal.Class<any>
        getAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[]
        getConstructors(): Internal.Constructor<any>[]
        hashCode(): number
        getAnnotatedSuperclass(): Internal.AnnotatedType
        toGenericString(): string
        getModifiers(): number
        getTypeName(): string
        getEnclosingConstructor(): Internal.Constructor<any>
        isNestmateOf(arg0: Internal.Class<any>): boolean
        getClasses(): Internal.Class<any>[]
        getSuperclass(): Internal.Class<T>
        getDeclaredField(arg0: string): Internal.Field
        componentType(): Internal.TypeDescriptor$OfField<any>
        componentType(): Internal.Class<any>
        static forName(arg0: string, arg1: boolean, arg2: Internal.ClassLoader): Internal.Class<any>
        static forName(arg0: string): Internal.Class<any>
        static forName(arg0: Internal.Module, arg1: string): Internal.Class<any>
        getResourceAsStream(arg0: string): Internal.InputStream
        isRecord(): boolean
        getDeclaredMethod(arg0: string, arg1: Internal.Class<any>[]): Internal.Method
        isEnum(): boolean
        getDeclaredConstructor(arg0: Internal.Class<any>[]): Internal.Constructor<T>
        getAnnotations(): Internal.Annotation[]
        getConstructor(arg0: Internal.Class<any>[]): Internal.Constructor<T>
        getEnumConstants(): T[]
        isHidden(): boolean
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[]
        getDeclaredClasses(): Internal.Class<any>[]
        equals(arg0: any): boolean
        isAnonymousClass(): boolean
        getEnclosingClass(): Internal.Class<any>
        toString(): string
        getGenericSuperclass(): Internal.Type
        get enclosingConstructor(): Internal.Constructor<any>;
        get annotations(): Internal.Annotation[];
        get memberClass(): boolean;
        get declaredConstructors(): Internal.Constructor<any>[];
        get declaredFields(): Internal.Field[];
        get superclass(): Internal.Class<T>;
        get record(): boolean;
        get canonicalName(): string;
        get package(): Internal.Package;
        get protectionDomain(): Internal.ProtectionDomain;
        get sealed(): boolean;
        get module(): Internal.Module;
        get enclosingMethod(): Internal.Method;
        get enum(): boolean;
        get declaringClass(): Internal.Class<any>;
        get synthetic(): boolean;
        get constructors(): Internal.Constructor<any>[];
        get declaredClasses(): Internal.Class<any>[];
        get name(): string;
        get fields(): Internal.Field[];
        get classLoader(): Internal.ClassLoader;
        get primitive(): boolean;
        get hidden(): boolean;
        get methods(): Internal.Method[];
        get classes(): Internal.Class<any>[];
        get typeName(): string;
        get declaredMethods(): Internal.Method[];
        get interface(): boolean;
        get genericInterfaces(): Internal.Type[];
        get modifiers(): number;
        get typeParameters(): any[];
        get annotatedSuperclass(): Internal.AnnotatedType;
        get permittedSubclasses(): Internal.Class<any>[];
        get array(): boolean;
        get enumConstants(): T[];
        get annotatedInterfaces(): Internal.AnnotatedType[];
        get packageName(): string;
        get class(): Internal.Class<any>;
        get annotation(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get interfaces(): Internal.Class<any>[];
        get genericSuperclass(): Internal.Type;
        get localClass(): boolean;
        get enclosingClass(): Internal.Class<any>;
        get nestMembers(): Internal.Class<any>[];
        get signers(): any[];
        get recordComponents(): any[];
        get simpleName(): string;
        get nestHost(): Internal.Class<any>;
        get anonymousClass(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TypeWrappers {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        removeAll(): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        register<T>(target: Internal.Class<T>, validator: (arg0: any) => boolean, factory: Internal.TypeWrapperFactory<T>): void
        register<T>(target: Internal.Class<T>, factory: Internal.TypeWrapperFactory<T>): void
        register<F, T>(id: string, from: Internal.Class<F>, to: Internal.Class<T>, factory: (arg0: F) => T): void
        getWrapperFactory(target: Internal.Class<any>, from: any): Internal.TypeWrapperFactory<any>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableSetMultimap$Builder <K, V> extends Internal.ImmutableMultimap$Builder<any, any> {
        orderKeysBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableSetMultimap$Builder<K, V>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        build(): Internal.ImmutableSetMultimap<K, V>
        build(): Internal.ImmutableMultimap<any, any>
        hashCode(): number
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableSetMultimap$Builder<K, V>
        orderValuesBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>
        notifyAll(): void
        equals(arg0: any): boolean
        putAll(arg0: Internal.Multimap<any, any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: any, arg1: any[]): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: K, arg1: V[]): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: any, arg1: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableSetMultimap$Builder<K, V>
        toString(): string
        notify(): void
        put(arg0: Internal.Map$Entry<any, any>): Internal.ImmutableMultimap$Builder<any, any>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>
        put(arg0: any, arg1: any): Internal.ImmutableMultimap$Builder<any, any>
        put(arg0: K, arg1: V): Internal.ImmutableSetMultimap$Builder<K, V>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Consumer <T> {
        andThen(arg0: (arg0: T) => void): (arg0: T) => void
        accept(arg0: T): void
    }
    class TeamData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        clearCachedProgress(): void
        setCanEdit(mode: boolean): boolean
        notifyAll(): void
        save(): void
        setProgress(task: Internal.Task, progress: number): void
        resetProgress(task: Internal.Task): void
        getProgress(task: Internal.Task): number
        getProgress(task: number): number
        notify(): void
        getCanEdit(): boolean
        serializeNBT(): Internal.SNBTCompoundTag
        getClaimType(player: Internal.UUID, reward: Internal.Reward): Internal.RewardClaimType
        getRewardClaimTime(player: Internal.UUID, reward: Internal.Reward): Internal.Date
        hashCode(): number
        canStartTasks(quest: Internal.Quest): boolean
        deleteReward(reward: Internal.Reward): void
        setStarted(id: number, time: Internal.Date): boolean
        static get(player: Internal.Player): Internal.TeamData
        isLocked(): boolean
        getStartedTime(id: number): Internal.Date
        setAutoPin(auto: boolean): void
        getCompletedTime(id: number): Internal.Date
        write(buffer: Internal.FriendlyByteBuf, self: boolean): void
        isCompleted(object: Internal.QuestObject): boolean
        setQuestPinned(id: number, pinned: boolean): void
        isQuestPinned(id: number): boolean
        read(buffer: Internal.FriendlyByteBuf, self: boolean): void
        hasUnclaimedRewards(player: Internal.UUID, object: Internal.QuestObject): boolean
        getRelativeProgress(object: Internal.QuestObject): number
        checkAutoCompletion(quest: Internal.Quest): void
        deserializeNBT(nbt: Internal.SNBTCompoundTag): void
        setCompleted(id: number, time: Internal.Date): boolean
        isStarted(object: Internal.QuestObject): boolean
        addProgress(task: Internal.Task, p: number): void
        setLocked(b: boolean): boolean
        copyData(from: Internal.TeamData): void
        mergeData(from: Internal.TeamData): void
        resetReward(player: Internal.UUID, reward: Internal.Reward): boolean
        areDependenciesComplete(quest: Internal.Quest): boolean
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>
        equals(arg0: any): boolean
        isRewardClaimed(player: Internal.UUID, reward: Internal.Reward): boolean
        getAutoPin(): boolean
        toString(): string
        claimReward(player: Internal.ServerPlayer, reward: Internal.Reward, notify: boolean): void
        claimReward(player: Internal.UUID, reward: Internal.Reward, date: number): boolean
        file : Internal.QuestFile;
        readonly pinnedQuests : Internal.LongOpenHashSet;
        static VERSION : 1;
        name : string;
        shouldSave : boolean;
        readonly uuid : Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get canEdit(): boolean;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        get autoPin(): boolean;
        set canEdit(mode: boolean);
        set locked(b: boolean);
        set autoPin(auto: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface OpenOption {
    }
    class Slot implements Internal.SlotAccessor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setY(arg0: number): void
        setX(arg0: number): void
        hashCode(): number
        getSlotIndex(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        isSameInventory(arg0: Internal.Slot): boolean
        setBackground(arg0: ResourceLocation, arg1: ResourceLocation): Internal.Slot
        notify(): void
        get class(): Internal.Class<any>;
        get slotIndex(): number;
        set x(arg0: number);
        set y(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntStream$IntMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.IntConsumer): void
    }
    abstract class BaseComponent implements Internal.MutableComponent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getString(): string
        notify(): void
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarEventSavedData extends Internal.SavedData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static load(arg0: Internal.CompoundTag): Internal.LunarEventSavedData
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get(arg0: Internal.LevelAccessor): Internal.LunarEventSavedData
        setForecast(arg0: Internal.LunarForecast): void
        toString(): string
        getForecast(): Internal.LunarForecast
        notify(): void
        static readonly DATA_NAME : "enhancedcelestials:lunar_event_data";
        get forecast(): Internal.LunarForecast;
        get class(): Internal.Class<any>;
        set forecast(arg0: Internal.LunarForecast);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BidirectionalIterator <K> extends Internal.Iterator<K> {
        next(): K
        previous(): K
        hasPrevious(): boolean
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: K) => void): void
        remove(): void
    }
    class ScriptPack {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly manager : Internal.ScriptManager;
        scope : Internal.Scriptable;
        context : Internal.Context;
        readonly scripts : Internal.List<Internal.ScriptFile>;
        readonly info : Internal.ScriptPackInfo;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleManagerAccess {
        invokeMakeParticle<T>(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle
    }
    class BlockSnapshot {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        restore(): boolean
        restore(arg0: boolean): boolean
        restore(arg0: boolean, arg1: boolean): boolean
        getBlockEntity(): Internal.BlockEntity
        notifyAll(): void
        restoreToLocation(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: boolean, arg3: boolean): boolean
        getTag(): Internal.CompoundTag
        getReplacedBlock(): Internal.BlockState
        notify(): void
        getCurrentBlock(): Internal.BlockState
        getLevel(): Internal.LevelAccessor
        hashCode(): number
        getPos(): BlockPos
        equals(arg0: any): boolean
        static create(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: number): Internal.BlockSnapshot
        static create(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos): Internal.BlockSnapshot
        toString(): string
        getFlag(): number
        get flag(): number;
        get currentBlock(): Internal.BlockState;
        get level(): Internal.LevelAccessor;
        get pos(): BlockPos;
        get blockEntity(): Internal.BlockEntity;
        get replacedBlock(): Internal.BlockState;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Advancement {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntUnaryOperator {
        applyAsInt(arg0: number): number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
    }
    interface Enumeration <E> {
        hasMoreElements(): boolean
        asIterator(): Internal.Iterator<E>
        nextElement(): E
    }
    class MetalPressRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class EnchantmentInstance extends Internal.WeightedEntry$IntrusiveBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AttributeModifier {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectCollection <K> extends Internal.Collection<K>, Internal.ObjectIterable<K> {
        add(arg0: K): boolean
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: K) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: K) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        size(): number
        addAll(arg0: Internal.Collection<K>): boolean
        stream(): Internal.Stream<K>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<K>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface ScheduledExecutorService extends Internal.ExecutorService {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        isTerminated(): boolean
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        execute(arg0: Internal.Runnable): void
        shutdown(): void
        isShutdown(): boolean
    }
    class RewardType extends Internal.RegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setExcludeFromListRewards(v: boolean): Internal.RewardType
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(name: ResourceLocation): Internal.RewardType
        setGuiProvider(p: Internal.RewardType$GuiProvider): Internal.RewardType
        setDisplayName(name: Internal.Component): Internal.RewardType
        getGuiProvider(): Internal.RewardType$GuiProvider
        notify(): void
        static createReward(quest: Internal.Quest, id: string): Internal.Reward
        getIcon(): Internal.Icon
        getDisplayName(): Internal.Component
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.RewardType>
        toString(): string
        getExcludeFromListRewards(): boolean
        getTypeForNBT(): string
        intId : number;
        readonly provider : Internal.RewardType$Provider;
        readonly id : ResourceLocation;
        get registryType(): Internal.Class<Internal.RewardType>;
        get displayName(): Internal.Component;
        get excludeFromListRewards(): boolean;
        get guiProvider(): Internal.RewardType$GuiProvider;
        get icon(): Internal.Icon;
        get registryName(): ResourceLocation;
        get typeForNBT(): string;
        get class(): Internal.Class<any>;
        set displayName(name: Internal.Component);
        set excludeFromListRewards(v: boolean);
        set guiProvider(p: Internal.RewardType$GuiProvider);
        set registryName(name: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2FloatFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        getFloat(arg0: any): number
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        removeFloat(arg0: any): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class DoubleSummaryStatistics implements Internal.DoubleConsumer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMax(): number
        notifyAll(): void
        getAverage(): number
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        notify(): void
        accept(arg0: number): void
        getMin(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getCount(): number
        getSum(): number
        combine(arg0: Internal.DoubleSummaryStatistics): void
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DropTargetDragEvent extends Internal.DropTargetEvent {
        getDropTargetContext(): Internal.DropTargetContext
        getDropAction(): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        notifyAll(): void
        rejectDrag(): void
        acceptDrag(arg0: number): void
        notify(): void
        getSourceActions(): number
        getTransferable(): Internal.Transferable
        getCurrentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>
        isDataFlavorSupported(arg0: Internal.DataFlavor): boolean
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        toString(): string
        getCurrentDataFlavors(): Internal.DataFlavor[]
        get sourceActions(): number;
        get transferable(): Internal.Transferable;
        get location(): Internal.Point;
        get currentDataFlavors(): Internal.DataFlavor[];
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        get currentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FluidAttributes {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOverlayTexture(): ResourceLocation
        isLighterThanAir(): boolean
        notifyAll(): void
        isGaseous(): boolean
        isGaseous(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): boolean
        isGaseous(arg0: Internal.FluidStack): boolean
        getRarity(): Internal.Rarity
        getRarity(arg0: Internal.FluidStack): Internal.Rarity
        getRarity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.Rarity
        getEmptySound(): Internal.SoundEvent
        getEmptySound(arg0: Internal.FluidStack): Internal.SoundEvent
        getEmptySound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent
        notify(): void
        getBucket(arg0: Internal.FluidStack): Internal.ItemStack
        getFlowingTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation
        getFlowingTexture(): ResourceLocation
        getFlowingTexture(arg0: Internal.FluidStack): ResourceLocation
        hashCode(): number
        static builder(arg0: ResourceLocation, arg1: ResourceLocation): Internal.FluidAttributes$Builder
        getStillTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation
        getStillTexture(): ResourceLocation
        getStillTexture(arg0: Internal.FluidStack): ResourceLocation
        getBlock(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): Internal.BlockState
        getStateForPlacement(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): Internal.FluidState
        getTranslationKey(arg0: Internal.FluidStack): string
        getTranslationKey(): string
        getColor(arg0: Internal.FluidStack): number
        getColor(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getColor(): number
        getFillSound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent
        getFillSound(): Internal.SoundEvent
        getFillSound(arg0: Internal.FluidStack): Internal.SoundEvent
        getDensity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getDensity(): number
        getDensity(arg0: Internal.FluidStack): number
        getLuminosity(arg0: Internal.FluidStack): number
        getLuminosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getLuminosity(): number
        doesVaporize(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): boolean
        getViscosity(): number
        getViscosity(arg0: Internal.FluidStack): number
        getViscosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getDisplayName(arg0: Internal.FluidStack): Internal.Component
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): boolean
        equals(arg0: any): boolean
        getTextures(): Internal.Stream<ResourceLocation>
        toString(): string
        vaporize(arg0: Internal.Player, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.FluidStack): void
        getTemperature(arg0: Internal.FluidStack): number
        getTemperature(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getTemperature(): number
        static readonly BUCKET_VOLUME : 1000;
        get overlayTexture(): ResourceLocation;
        get translationKey(): string;
        get color(): number;
        get density(): number;
        get textures(): Internal.Stream<ResourceLocation>;
        get lighterThanAir(): boolean;
        get gaseous(): boolean;
        get emptySound(): Internal.SoundEvent;
        get stillTexture(): ResourceLocation;
        get viscosity(): number;
        get flowingTexture(): ResourceLocation;
        get temperature(): number;
        get luminosity(): number;
        get class(): Internal.Class<any>;
        get fillSound(): Internal.SoundEvent;
        get rarity(): Internal.Rarity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WrappedGoal extends Internal.Goal {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function3 <T1, T2, T3, R> {
        apply(arg0: T1, arg1: T2, arg2: T3): R
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3) => R
        curry(): (arg0: T1) => (arg0: T2, arg1: T3) => R
    }
    class FocusEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getID(): number
        getOppositeComponent(): java_.awt.Component
        isTemporary(): boolean
        getCause(): Internal.FocusEvent$Cause
        notify(): void
        paramString(): string
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        toString(): string
        getComponent(): java_.awt.Component
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly FOCUS_FIRST : 1004;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly FOCUS_LOST : 1005;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly FOCUS_GAINED : 1004;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly FOCUS_LAST : 1005;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get temporary(): boolean;
        get component(): java_.awt.Component;
        get oppositeComponent(): java_.awt.Component;
        get cause(): Internal.FocusEvent$Cause;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder <A> {
        simple(): Internal.Decoder$Simple<A>
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        terminal(): Internal.Decoder$Terminal<A>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<A>
        promotePartial(arg0: (arg0: string) => void): Internal.Decoder<A>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>
        boxed(): Internal.Decoder$Boxed<A>
        fieldOf(arg0: string): Internal.MapDecoder<A>
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>
    }
    interface Cloneable {
    }
    class ImageCapabilities implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isAccelerated(): boolean
        isTrueVolatile(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        notify(): void
        get trueVolatile(): boolean;
        get class(): Internal.Class<any>;
        get accelerated(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer, message: string): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getOwner(): Internal.UUID
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        delete(source: Internal.CommandSourceStack): number
        notify(): void
        getColoredName(): Internal.Component
        serializeNBT(): Internal.SNBTCompoundTag
        hashCode(): number
        info(source: Internal.CommandSourceStack): number
        settings(source: Internal.CommandSourceStack, key: Internal.TeamProperty<any>, value: string): number
        isAlly(profile: Internal.UUID): boolean
        getProperty<T_>(property: Internal.TeamProperty<T_>): T_
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        sendMessage(from: Internal.UUID, text: Internal.Component): void
        deserializeNBT(tag: Internal.CompoundTag): void
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        getOnlineRanked(rank: Internal.TeamRank): Internal.List<Internal.ServerPlayer>
        denyInvite(source: Internal.CommandSourceStack): number
        isFreeToJoin(): boolean
        getDisplayName(): string
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>
        getType(): Internal.TeamType
        setProperty<T_>(property: Internal.TeamProperty<T_>, value: T_): void
        equals(o: any): boolean
        toString(): string
        getMembers(): Internal.Set<Internal.UUID>
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MessageSizeEstimator$Handle {
        size(arg0: any): number
    }
    class ModelBakeEvent extends net.minecraftforge.eventbus.api.Event implements Internal.IModBusEvent {
        setCanceled(arg0: boolean): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCanceled(): boolean
        setResult(arg0: Internal.Event$Result): void
        getModelRegistry(): Internal.Map<ResourceLocation, Internal.BakedModel>
        notifyAll(): void
        hasResult(): boolean
        getModelManager(): Internal.ModelManager
        notify(): void
        getListenerList(): Internal.ListenerList
        hashCode(): number
        equals(arg0: any): boolean
        getResult(): Internal.Event$Result
        toString(): string
        isCancelable(): boolean
        getPhase(): Internal.EventPriority
        getModelLoader(): Internal.ForgeModelBakery
        setPhase(arg0: Internal.EventPriority): void
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get modelRegistry(): Internal.Map<ResourceLocation, Internal.BakedModel>;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get modelManager(): Internal.ModelManager;
        get modelLoader(): Internal.ForgeModelBakery;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DirectoryStream$Filter <T> {
        accept(arg0: T): boolean
    }
    interface VertexList {
        getLight(arg0: number): number
        getG(arg0: number): number
        isEmpty(): boolean
        getR(arg0: number): number
        getVertexCount(): number
        getU(arg0: number): number
        getV(arg0: number): number
        getX(arg0: number): number
        getY(arg0: number): number
        getZ(arg0: number): number
        getNZ(arg0: number): number
        getNY(arg0: number): number
        getNX(arg0: number): number
        getA(arg0: number): number
        getB(arg0: number): number
    }
    class VariantBlockStateGenerator$Variant {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonElement
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        model(s: string): Internal.VariantBlockStateGenerator$Model
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class QuestProgressEventData <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        withObject<N>(o: N): Internal.QuestProgressEventData<N>
        readonly teamData : Internal.TeamData;
        readonly onlineMembers : Internal.List<Internal.ServerPlayer>;
        readonly notifiedPlayers : Internal.List<Internal.ServerPlayer>;
        readonly time : Internal.Date;
        readonly object : T;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorGoalSelector {
        getAvailableGoals(): Internal.Set<Internal.WrappedGoal>
    }
    class ModuleDescriptor$Requires implements Internal.Comparable<Internal.ModuleDescriptor$Requires> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compiledVersion(): Internal.Optional<Internal.ModuleDescriptor$Version>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        rawCompiledVersion(): Internal.Optional<string>
        name(): string
        toString(): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Requires): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Frustum {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2DoubleFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class BufferStrategy {
        getClass(): Internal.Class<any>
        contentsRestored(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        contentsLost(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getDrawGraphics(): Internal.Graphics
        show(): void
        toString(): string
        dispose(): void
        getCapabilities(): Internal.BufferCapabilities
        notify(): void
        get capabilities(): Internal.BufferCapabilities;
        get drawGraphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface EventExecutorGroup extends Internal.ScheduledExecutorService, Internal.Iterable<Internal.EventExecutor> {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        next(): Internal.EventExecutor
        terminationFuture(): Internal.Future<any>
        submit(arg0: Internal.Runnable): Internal.Future<any>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        shutdownGracefully(): Internal.Future<any>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>
        spliterator(): Internal.Spliterator<Internal.EventExecutor>
        isTerminated(): boolean
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
    }
    class InterfaceAddress {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getBroadcast(): Internal.InetAddress
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getNetworkPrefixLength(): number
        getAddress(): Internal.InetAddress
        toString(): string
        notify(): void
        get broadcast(): Internal.InetAddress;
        get address(): Internal.InetAddress;
        get class(): Internal.Class<any>;
        get networkPrefixLength(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Copyable {
        copy(): Internal.Copyable
    }
    interface Double2IntFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class BaseImmutableMultimap <K, V> extends Internal.AbstractMultimap<any, any> {
        getClass(): Internal.Class<any>
        containsEntry(arg0: any, arg1: any): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        keys(): Internal.Multiset<K>
        asMap(): Internal.Map<K, Internal.Collection<V>>
        notifyAll(): void
        values(): Internal.Collection<V>
        clear(): void
        isEmpty(): boolean
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        get(arg0: K): Internal.Collection<V>
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: any): boolean
        toString(): string
        keySet(): Internal.Set<K>
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ScriptSource {
        createStream(arg0: Internal.ScriptFileInfo): Internal.InputStream
    }
    abstract class StateHolder <O, S> implements Internal.FastMapStateHolder<any> {
        getNeighborTable(): Internal.Table<any, any, any>
        getStateIndex(): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        redirect$zlm000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any
        setNeighborTable(table: Internal.Table<any, any, any>): void
        notifyAll(): void
        setStateMap(newValue: Internal.FastMap<any>): void
        getStateMap(): Internal.FastMap<any>
        notify(): void
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void
        hashCode(): number
        equals(arg0: any): boolean
        setStateIndex(newValue: number): void
        toString(): string
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MathContext implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRoundingMode(): Internal.RoundingMode
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        getPrecision(): number
        static readonly DECIMAL128 : Internal.MathContext;
        static readonly DECIMAL64 : Internal.MathContext;
        static readonly DECIMAL32 : Internal.MathContext;
        static readonly UNLIMITED : Internal.MathContext;
        get roundingMode(): Internal.RoundingMode;
        get precision(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
    }
    abstract class UnmodifiableListIterator <E> extends Internal.UnmodifiableIterator<any> implements Internal.ListIterator<E> {
        next(): E
        add(arg0: E): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        set(arg0: E): void
        previous(): E
        notifyAll(): void
        hasNext(): boolean
        nextIndex(): number
        notify(): void
        remove(): void
        hashCode(): number
        equals(arg0: any): boolean
        hasPrevious(): boolean
        toString(): string
        forEachRemaining(arg0: (arg0: E) => void): void
        previousIndex(): number
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IngredientKJS extends Internal.AsKJS {
        getItemsKJS(): Internal.ItemStack[]
        asKJS(): any
    }
    interface Keyable {
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
    }
    class EntityArrayList extends Internal.ArrayList<any> implements Internal.MessageSender {
        getClass(): Internal.Class<any>
        sendData(channel: string, data: Internal.CompoundTag): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getWorld(): Internal.LevelJS
        getName(): Internal.Text
        notifyAll(): void
        tell(message: Internal.Component): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: any): boolean
        remove(arg0: number): Internal.EntityJS
        runCommandSilent(command: string): number
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<Internal.EntityJS>
        stream(): Internal.Stream<Internal.EntityJS>
        hashCode(): number
        getFirst(): Internal.EntityJS
        get(arg0: number): Internal.EntityJS
        playSound(id: Internal.SoundEvent): void
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<Internal.EntityJS>
        runCommand(command: string): number
        indexOf(arg0: any): number
        add(arg0: Internal.EntityJS): boolean
        add(arg0: number, arg1: Internal.EntityJS): void
        subList(arg0: number, arg1: number): Internal.List<Internal.EntityJS>
        setStatusMessage(message: Internal.Component): void
        trimToSize(): void
        set(arg0: number, arg1: Internal.EntityJS): Internal.EntityJS
        spliterator(): Internal.Spliterator<Internal.EntityJS>
        forEach(arg0: (arg0: Internal.EntityJS) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<Internal.EntityJS>): void
        kill(): void
        removeIf(arg0: (arg0: Internal.EntityJS) => boolean): boolean
        filter(filter: (arg0: Internal.EntityJS) => boolean): Internal.EntityArrayList
        lastIndexOf(arg0: any): number
        getLevel(): Internal.LevelJS
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.Collection<Internal.EntityJS>): boolean
        addAll(arg0: number, arg1: Internal.Collection<Internal.EntityJS>): boolean
        getDisplayName(): Internal.Text
        equals(arg0: any): boolean
        clone(): any
        listIterator(): Internal.ListIterator<Internal.EntityJS>
        listIterator(arg0: number): Internal.ListIterator<Internal.EntityJS>
        toString(): string
        ensureCapacity(arg0: number): void
        retainAll(arg0: Internal.Collection<any>): boolean
        get world(): Internal.LevelJS;
        get level(): Internal.LevelJS;
        get displayName(): Internal.Text;
        get name(): Internal.Text;
        get class(): Internal.Class<any>;
        get first(): Internal.EntityJS;
        get empty(): boolean;
        set statusMessage(message: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MutableUnit extends Internal.Unit {
        getClass(): Internal.Class<any>
        mod(with_: Internal.Unit): Internal.Unit
        cos(): Internal.Unit
        log1p(): Internal.Unit
        deg(): Internal.Unit
        lt(with_: Internal.Unit): Internal.Unit
        atan(): Internal.Unit
        getAsInt(): number
        div(with_: Internal.Unit): Internal.Unit
        neg(): Internal.Unit
        shiftLeft(with_: Internal.Unit): Internal.Unit
        rad(): Internal.Unit
        sqrt(): Internal.Unit
        gte(with_: Internal.Unit): Internal.Unit
        neq(with_: Internal.Unit): Internal.Unit
        atan2(with_: Internal.Unit): Internal.Unit
        tan(): Internal.Unit
        add(with_: Internal.Unit): Internal.Unit
        ceil(): Internal.Unit
        toBool(): Internal.Unit
        eq(with_: Internal.Unit): Internal.Unit
        shiftRight(with_: Internal.Unit): Internal.Unit
        sub(with_: Internal.Unit): Internal.Unit
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mul(with_: Internal.Unit): Internal.Unit
        log(): Internal.Unit
        log10(): Internal.Unit
        notifyAll(): void
        notify(): void
        not(): Internal.Unit
        min(with_: Internal.Unit): Internal.Unit
        hashCode(): number
        and(with_: Internal.Unit): Internal.Unit
        get(): number
        pow(with_: Internal.Unit): Internal.Unit
        sin(): Internal.Unit
        xor(with_: Internal.Unit): Internal.Unit
        floor(): Internal.Unit
        lte(with_: Internal.Unit): Internal.Unit
        isFixed(): boolean
        sq(): Internal.Unit
        or(with_: Internal.Unit): Internal.Unit
        set(v: number): void
        max(with_: Internal.Unit): Internal.Unit
        gt(with_: Internal.Unit): Internal.Unit
        abs(): Internal.Unit
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        append(sb: Internal.StringBuilder): void
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TaskType$GuiProvider {
        openCreationGui(arg0: Internal.Runnable, arg1: Internal.Quest, arg2: (arg0: Internal.Task) => void): void
    }
    interface IForgeFluid {
        getAttributes(): Internal.FluidAttributes
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        getTags(): Internal.Set<ResourceLocation>
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: Internal.Material): boolean
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean
    }
    class LocalDate implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDate, Internal.Serializable {
        getClass(): Internal.Class<any>
        atStartOfDay(): Internal.LocalDateTime
        atStartOfDay(arg0: Internal.ZoneId): Internal.ZonedDateTime
        toEpochDay(): number
        isEqual(arg0: Internal.ChronoLocalDate): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChronoLocalDate): number
        getDayOfWeek(): Internal.DayOfWeek
        lengthOfMonth(): number
        getEra(): Internal.IsoEra
        getEra(): Internal.Era
        static from(arg0: Internal.TemporalAccessor): Internal.LocalDate
        getMonth(): Internal.Month
        static ofYearDay(arg0: number, arg1: number): Internal.LocalDate
        plusMonths(arg0: number): Internal.LocalDate
        plusYears(arg0: number): Internal.LocalDate
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        plus(arg0: Internal.TemporalAmount): Internal.LocalDate
        atTime(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalDateTime
        atTime(arg0: Internal.LocalTime): Internal.ChronoLocalDateTime<any>
        atTime(arg0: Internal.LocalTime): Internal.LocalDateTime
        atTime(arg0: number, arg1: number, arg2: number): Internal.LocalDateTime
        atTime(arg0: Internal.OffsetTime): Internal.OffsetDateTime
        atTime(arg0: number, arg1: number): Internal.LocalDateTime
        getYear(): number
        toEpochSecond(arg0: Internal.LocalTime, arg1: Internal.ZoneOffset): number
        withDayOfMonth(arg0: number): Internal.LocalDate
        isAfter(arg0: Internal.ChronoLocalDate): boolean
        withMonth(arg0: number): Internal.LocalDate
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalDate
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDate
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.LocalDate
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        datesUntil(arg0: Internal.LocalDate): Internal.Stream<Internal.LocalDate>
        datesUntil(arg0: Internal.LocalDate, arg1: Internal.Period): Internal.Stream<Internal.LocalDate>
        notifyAll(): void
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        withYear(arg0: number): Internal.LocalDate
        notify(): void
        lengthOfYear(): number
        plusDays(arg0: number): Internal.LocalDate
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.LocalDate
        static now(): Internal.LocalDate
        static now(arg0: Internal.ZoneId): Internal.LocalDate
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalDate
        static of(arg0: number, arg1: Internal.Month, arg2: number): Internal.LocalDate
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.LocalDate
        getChronology(): Internal.IsoChronology
        getChronology(): Internal.Chronology
        static ofEpochDay(arg0: number): Internal.LocalDate
        getMonthValue(): number
        minusYears(arg0: number): Internal.LocalDate
        minusWeeks(arg0: number): Internal.LocalDate
        withDayOfYear(arg0: number): Internal.LocalDate
        isLeapYear(): boolean
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalDate
        static parse(arg0: Internal.CharSequence): Internal.LocalDate
        isBefore(arg0: Internal.ChronoLocalDate): boolean
        minusDays(arg0: number): Internal.LocalDate
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.LocalDate
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDate
        minusMonths(arg0: number): Internal.LocalDate
        equals(arg0: any): boolean
        until(arg0: Internal.ChronoLocalDate): Internal.Period
        until(arg0: Internal.ChronoLocalDate): Internal.ChronoPeriod
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        static readonly MIN : Internal.LocalDate;
        static readonly MAX : Internal.LocalDate;
        static readonly EPOCH : Internal.LocalDate;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get era(): Internal.Era;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get chronology(): Internal.Chronology;
        get leapYear(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ComponentListener extends Internal.EventListener {
        componentHidden(arg0: Internal.ComponentEvent): void
        componentResized(arg0: Internal.ComponentEvent): void
        componentShown(arg0: Internal.ComponentEvent): void
        componentMoved(arg0: Internal.ComponentEvent): void
    }
    class PropertyChangeEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setPropagationId(arg0: any): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getPropagationId(): any
        getOldValue(): any
        getNewValue(): any
        notify(): void
        getPropertyName(): string
        get newValue(): any;
        get propertyName(): string;
        get source(): any;
        get oldValue(): any;
        get class(): Internal.Class<any>;
        get propagationId(): any;
        set propagationId(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleValue {
        getMinimumAccessibleValue(): Internal.Number
        setCurrentAccessibleValue(arg0: Internal.Number): boolean
        getCurrentAccessibleValue(): Internal.Number
        getMaximumAccessibleValue(): Internal.Number
    }
    interface SecondaryLoop {
        exit(): boolean
        enter(): boolean
    }
    class RecordCodecBuilder$Mu <O> implements Internal.K1 {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntSpliterator extends Internal.Spliterator$OfInt {
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.IntSpliterator
        trySplit(): Internal.Spliterator$OfInt
        characteristics(): number
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: (arg0: any) => void): boolean
        tryAdvance(arg0: any): boolean
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean
        getComparator(): Internal.Comparator<any>
        getComparator(): Internal.IntComparator
        getExactSizeIfKnown(): number
        estimateSize(): number
        skip(arg0: number): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: any) => void): void
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
    }
    interface EntityTypeExtension <T> {
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<T>): void
        flywheel$getInstancingController(): Internal.EntityInstancingController<T>
    }
    interface Collection <E> extends Internal.Iterable<E> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface Stream$Builder <T> extends Internal.Consumer<T> {
        add(arg0: T): (arg0: T) => void
        build(): Internal.Stream<T>
        andThen(arg0: (arg0: T) => void): (arg0: T) => void
        accept(arg0: T): void
    }
    class Proxy {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        address(): Internal.SocketAddress
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        type(): Internal.Proxy$Type
        notify(): void
        static readonly NO_PROXY : Internal.Proxy;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelPart {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BufferCapabilities$FlipContents extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly UNDEFINED : Internal.BufferCapabilities$FlipContents;
        static readonly PRIOR : Internal.BufferCapabilities$FlipContents;
        static readonly COPIED : Internal.BufferCapabilities$FlipContents;
        static readonly BACKGROUND : Internal.BufferCapabilities$FlipContents;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2LongFunction extends Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Matrix4f implements Internal.MatrixWrite {
        multiplyBackward(arg0: Internal.Matrix4f): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        flywheel$writeUnsafe(arg0: number): void
        toString(): string
        setTranslation(arg0: number, arg1: number, arg2: number): void
        flywheel$write(arg0: Internal.VecBuffer): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Int2ObjectOpenHashMap <V> extends Internal.AbstractInt2ObjectMap<any> implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: any, arg1: V): V
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        containsValue(arg0: any): boolean
        put(arg0: number, arg1: V): V
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        trim(arg0: number): boolean
        trim(): boolean
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): V
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction<V>): V
        computeIfAbsent(arg0: number, arg1: (arg0: number) => V): V
        values(): Internal.Collection<any>
        values(): Internal.ObjectCollection<V>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): V
        replaceAll(arg0: (arg0: number, arg1: V) => V): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        notify(): void
        remove(arg0: number, arg1: any): boolean
        remove(arg0: number): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        int2ObjectEntrySet(): Internal.ObjectSet<any>
        int2ObjectEntrySet(): Internal.Int2ObjectMap$FastEntrySet<V>
        hashCode(): number
        putAll(arg0: Internal.Map<number, V>): void
        get(arg0: number): V
        get(arg0: any): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.IntSet
        keySet(): Internal.Set<any>
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        forEach(arg0: (arg0: number, arg1: V) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        clone(): (arg0: any) => any
        clone(): any
        toString(): string
        putIfAbsent(arg0: number, arg1: V): V
        putIfAbsent(arg0: number, arg1: V): V
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MenuShortcut implements Internal.Serializable {
        getClass(): Internal.Class<any>
        getKey(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        usesShiftModifier(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: Internal.MenuShortcut): boolean
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        get key(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Font implements Internal.IAntiqueTextProvider {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setAntiqueInk(arg0: boolean): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        hasAntiqueInk(): boolean
        get class(): Internal.Class<any>;
        set antiqueInk(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class AirItem extends Internal.Item {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notifyAll(): void
        getId(): string
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getRenderPropertiesInternal(): any
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JobAttributes$DestinationType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly PRINTER : Internal.JobAttributes$DestinationType;
        static readonly FILE : Internal.JobAttributes$DestinationType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleText {
        getSelectionStart(): number
        getSelectedText(): string
        getIndexAtPoint(arg0: Internal.Point): number
        getCharCount(): number
        getCharacterAttribute(arg0: number): Internal.AttributeSet
        getBeforeIndex(arg0: number, arg1: number): string
        getAfterIndex(arg0: number, arg1: number): string
        getSelectionEnd(): number
        getAtIndex(arg0: number, arg1: number): string
        getCaretPosition(): number
        getCharacterBounds(arg0: number): Internal.Rectangle
    }
    interface ItemStackKJS extends Internal.AsKJS {
        removeTagKJS(): void
        asKJS(): any
    }
    abstract class Button extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        getGui(): Internal.BaseScreen
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        updateMouseOver(mouseX: number, mouseY: number): void
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        onClosed(): void
        isMouseOver(): boolean
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        openGui(): void
        setTitle(s: Internal.Component): Internal.Button
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        tick(): void
        setHeight(v: number): void
        setIcon(i: Internal.Icon): Internal.Button
        addMouseOverText(list: Internal.TooltipList): void
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        onClicked(arg0: Internal.MouseButton): void
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        notify(): void
        mouseReleased(button: Internal.MouseButton): void
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        getWidgetType(): Internal.WidgetType
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        drawIcon(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getY(): number
        equals(arg0: any): boolean
        toString(): string
        getIngredientUnderMouse(): any
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get title(): Internal.Component;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get partialTicks(): number;
        set clipboardString(string: string);
        set icon(i: Internal.Icon);
        set x(v: number);
        set y(v: number);
        set title(s: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GameRulesJS {
        getClass(): Internal.Class<any>
        getInt(rule: string): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        set(rule: string, value: any): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getBoolean(rule: string): boolean
        getString(rule: string): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ConfigCallback {
        save(arg0: boolean): void
    }
    interface BufferVertexConsumer extends Internal.VertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    abstract class InventoryFilterItem extends Internal.BaseFilterItem {
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        getDamage(arg0: Internal.ItemStack): number
        getDisplayItemStacks(filter: Internal.ItemStack, list: Internal.List<Internal.ItemStack>): void
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        clearFilterCache(filter: Internal.ItemStack): void
        static getInventory(stack: Internal.ItemStack): Internal.ItemInventory
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getRegistryName(): ResourceLocation
        addInfo(filter: Internal.ItemStack, info: Internal.FilterInfo, expanded: boolean): void
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        filter(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        getItems(filter: Internal.ItemStack, set: Internal.Set<Internal.Item>): void
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        isRepairable(arg0: Internal.ItemStack): boolean
        getInventorySize(filter: Internal.ItemStack): number
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        isDamageable(arg0: Internal.ItemStack): boolean
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        addSlots(filter: Internal.ItemStack, list: Internal.List<Internal.InventoryFilterItem$FilterSlot>): void
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        filterItem(filter: Internal.ItemStack, item: Internal.Item): boolean
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        notifyAll(): void
        getId(): string
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getRenderPropertiesInternal(): any
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        setRarityKJS(arg0: Internal.Rarity): void
        addPlaceable(arg0: Internal.Block): void
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        resetFilterData(filter: Internal.ItemStack): void
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        getItemStackLimit(arg0: Internal.ItemStack): number
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get category(): Internal.CreativeModeTab;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set maxStackSizeKJS(arg0: number);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Composite {
        createContext(arg0: Internal.ColorModel, arg1: Internal.ColorModel, arg2: Internal.RenderingHints): Internal.CompositeContext
    }
    interface IEventHandler {
        onEvent(arg0: Internal.EventJS): void
    }
    abstract class DynamicLike <T> {
        createLong(arg0: number): Internal.Dynamic<T>
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>
        getClass(): Internal.Class<any>
        getElementGeneric(arg0: T): Internal.DataResult<T>
        getElementGeneric(arg0: T, arg1: T): T
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: (arg0: K) => Internal.Decoder<V>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: Internal.Decoder<V>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>
        readMap<R>(arg0: Internal.DataResult<R>, arg1: Internal.Function3<R, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R>>): Internal.DataResult<R>
        asListOpt<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.DataResult<Internal.List<U>>
        createShort(arg0: number): Internal.Dynamic<T>
        decode<A>(arg0: Internal.Decoder<A>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        asList<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.List<U>
        readList<E>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E>): Internal.DataResult<Internal.List<E>>
        readList<E>(arg0: Internal.Decoder<E>): Internal.DataResult<Internal.List<E>>
        asString(): Internal.DataResult<string>
        asString(arg0: string): string
        asByte(arg0: number): number
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>
        read<A>(arg0: Internal.Decoder<A>): Internal.DataResult<A>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        createString(arg0: string): Internal.Dynamic<T>
        getGeneric(arg0: T): Internal.DataResult<T>
        asMapOpt<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Internal.DataResult<Internal.Map<K, V>>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        asStream(): Internal.Stream<Internal.Dynamic<T>>
        createByte(arg0: number): Internal.Dynamic<T>
        asLong(arg0: number): number
        asDouble(arg0: number): number
        asBoolean(arg0: boolean): boolean
        createDouble(arg0: number): Internal.Dynamic<T>
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        asMap<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Internal.Map<K, V>
        notifyAll(): void
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>
        asIntStream(): Internal.IntStream
        asByteBuffer(): Internal.ByteBuffer
        asFloat(arg0: number): number
        asLongStream(): Internal.LongStream
        notify(): void
        createBoolean(arg0: boolean): Internal.Dynamic<T>
        asInt(arg0: number): number
        emptyList(): Internal.Dynamic<T>
        hashCode(): number
        asShort(arg0: number): number
        get(arg0: string): Internal.OptionalDynamic<T>
        emptyMap(): Internal.Dynamic<T>
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>
        asNumber(arg0: Internal.Number): Internal.Number
        asNumber(): Internal.DataResult<Internal.Number>
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>
        createFloat(arg0: number): Internal.Dynamic<T>
        getOps(): Internal.DynamicOps<T>
        getElement(arg0: string): Internal.DataResult<T>
        getElement(arg0: string, arg1: T): T
        equals(arg0: any): boolean
        createInt(arg0: number): Internal.Dynamic<T>
        toString(): string
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockEntityRenderer <T> {
    }
    class Cursor implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getType(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static getSystemCustomCursor(arg0: string): Internal.Cursor
        static getPredefinedCursor(arg0: number): Internal.Cursor
        toString(): string
        static getDefaultCursor(): Internal.Cursor
        notify(): void
        static readonly N_RESIZE_CURSOR : 8;
        static readonly S_RESIZE_CURSOR : 9;
        static readonly TEXT_CURSOR : 2;
        static readonly NW_RESIZE_CURSOR : 6;
        static readonly W_RESIZE_CURSOR : 10;
        static readonly SE_RESIZE_CURSOR : 5;
        static readonly CUSTOM_CURSOR : -1;
        static readonly NE_RESIZE_CURSOR : 7;
        static readonly SW_RESIZE_CURSOR : 4;
        static readonly DEFAULT_CURSOR : 0;
        static readonly CROSSHAIR_CURSOR : 1;
        static readonly E_RESIZE_CURSOR : 11;
        static readonly HAND_CURSOR : 12;
        static readonly WAIT_CURSOR : 3;
        static readonly MOVE_CURSOR : 13;
        get name(): string;
        get type(): number;
        get defaultCursor(): Internal.Cursor;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkDirection extends Internal.Enum<any> {
        getEvent(arg0: Internal.ICustomPacket<any>, arg1: () => Internal.NetworkEvent$Context): Internal.NetworkEvent
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static directionFor<T_>(arg0: Internal.Class<T_>): Internal.NetworkDirection
        static valueOf(arg0: string): Internal.NetworkDirection
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.NetworkDirection[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.NetworkDirection): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.NetworkDirection>>
        notify(): void
        getOriginationSide(): Internal.LogicalSide
        getReceptionSide(): Internal.LogicalSide
        getDeclaringClass(): Internal.Class<Internal.NetworkDirection>
        buildPacket<T_>(arg0: Internal.Pair<Internal.FriendlyByteBuf, number>, arg1: ResourceLocation): Internal.ICustomPacket<T_>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        reply(): Internal.NetworkDirection
        ordinal(): number
        static readonly LOGIN_TO_CLIENT : Internal.NetworkDirection;
        static readonly PLAY_TO_SERVER : Internal.NetworkDirection;
        static readonly LOGIN_TO_SERVER : Internal.NetworkDirection;
        static readonly PLAY_TO_CLIENT : Internal.NetworkDirection;
        get receptionSide(): Internal.LogicalSide;
        get originationSide(): Internal.LogicalSide;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.NetworkDirection>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WritableRenderedImage extends Internal.RenderedImage {
        getMinTileX(): number
        getMinTileY(): number
        getTileWidth(): number
        isTileWritable(arg0: number, arg1: number): boolean
        getNumYTiles(): number
        getSources(): Internal.Vector<Internal.RenderedImage>
        getWidth(): number
        addTileObserver(arg0: Internal.TileObserver): void
        getTileGridXOffset(): number
        getWritableTileIndices(): Internal.Point[]
        getSampleModel(): Internal.SampleModel
        getHeight(): number
        getWritableTile(arg0: number, arg1: number): Internal.WritableRaster
        removeTileObserver(arg0: Internal.TileObserver): void
        getPropertyNames(): string[]
        getNumXTiles(): number
        getData(arg0: Internal.Rectangle): Internal.Raster
        getData(): Internal.Raster
        getTileHeight(): number
        getTile(arg0: number, arg1: number): Internal.Raster
        getProperty(arg0: string): any
        getColorModel(): Internal.ColorModel
        setData(arg0: Internal.Raster): void
        hasTileWriters(): boolean
        copyData(arg0: Internal.WritableRaster): Internal.WritableRaster
        getTileGridYOffset(): number
        releaseWritableTile(arg0: number, arg1: number): void
        getMinX(): number
        getMinY(): number
    }
    class MobEffectCategory extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.MobEffectCategory
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.MobEffectCategory[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.MobEffectCategory): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobEffectCategory>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.MobEffectCategory>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly HARMFUL : Internal.MobEffectCategory;
        static readonly BENEFICIAL : Internal.MobEffectCategory;
        static readonly NEUTRAL : Internal.MobEffectCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobEffectCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoublePredicate {
        or(arg0: Internal.DoublePredicate): Internal.DoublePredicate
        test(arg0: number): boolean
        and(arg0: Internal.DoublePredicate): Internal.DoublePredicate
        negate(): Internal.DoublePredicate
    }
    interface Message {
        getString(): string
    }
    interface SlotAccessor {
        setY(arg0: number): void
        setX(arg0: number): void
    }
    class Dialog$ModalityType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Dialog$ModalityType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Dialog$ModalityType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Dialog$ModalityType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dialog$ModalityType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Dialog$ModalityType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly TOOLKIT_MODAL : Internal.Dialog$ModalityType;
        static readonly APPLICATION_MODAL : Internal.Dialog$ModalityType;
        static readonly MODELESS : Internal.Dialog$ModalityType;
        static readonly DOCUMENT_MODAL : Internal.Dialog$ModalityType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dialog$ModalityType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Runnable {
        run(): void
    }
    class HunterPlayerSpecialAttribute {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getVampireNearbyProgress(): number
        notifyAll(): void
        resetDisguise(): void
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        getDisguiseProgress(): number
        activateDisguise(): void
        toString(): string
        isVampireNearby(): boolean
        isDisguised(): boolean
        nearbyVampire(arg0: number): void
        increaseDisguiseTicks(): void
        fullHunterCoat : Internal.IItemWithTier$TIER;
        get disguiseProgress(): number;
        get vampireNearby(): boolean;
        get class(): Internal.Class<any>;
        get disguised(): boolean;
        get vampireNearbyProgress(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MultiBufferSource {
    }
    class StandardLevel extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.StandardLevel
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.StandardLevel[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.StandardLevel): number
        intLevel(): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.StandardLevel>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.StandardLevel>
        hashCode(): number
        static getStandardLevel(intLevel: number): Internal.StandardLevel
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly TRACE : Internal.StandardLevel;
        static readonly ALL : Internal.StandardLevel;
        static readonly ERROR : Internal.StandardLevel;
        static readonly INFO : Internal.StandardLevel;
        static readonly FATAL : Internal.StandardLevel;
        static readonly DEBUG : Internal.StandardLevel;
        static readonly OFF : Internal.StandardLevel;
        static readonly WARN : Internal.StandardLevel;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.StandardLevel>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FileSystem implements Internal.Closeable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        supportedFileAttributeViews(): Internal.Set<string>
        getFileStores(): Internal.Iterable<Internal.FileStore>
        notifyAll(): void
        newWatchService(): Internal.WatchService
        notify(): void
        isReadOnly(): boolean
        isOpen(): boolean
        provider(): Internal.FileSystemProvider
        hashCode(): number
        equals(arg0: any): boolean
        getRootDirectories(): Internal.Iterable<Internal.Path>
        getPath(arg0: string, arg1: string[]): Internal.Path
        getSeparator(): string
        toString(): string
        getPathMatcher(arg0: string): Internal.PathMatcher
        close(): void
        getUserPrincipalLookupService(): Internal.UserPrincipalLookupService
        get rootDirectories(): Internal.Iterable<Internal.Path>;
        get readOnly(): boolean;
        get userPrincipalLookupService(): Internal.UserPrincipalLookupService;
        get class(): Internal.Class<any>;
        get separator(): string;
        get open(): boolean;
        get fileStores(): Internal.Iterable<Internal.FileStore>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Locale$IsoCountryCode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Locale$IsoCountryCode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Locale$IsoCountryCode[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Locale$IsoCountryCode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$IsoCountryCode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly PART3 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA2 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA3 : Internal.Locale$IsoCountryCode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityGetter {
    }
    interface Map$Entry <K, V> {
        getKey(): K
        getValue(): V
        hashCode(): number
        setValue(arg0: V): V
        equals(arg0: any): boolean
    }
    class ChapterGroup extends Internal.QuestObject {
        getClass(): Internal.Class<any>
        isDefaultGroup(): boolean
        getIndex(): number
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        getPath(): string
        clearCachedData(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        editedFromGUI(): void
        hasTag(tag: string): boolean
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        getChildren(): Internal.Collection<Internal.QuestObject>
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getAltTitle(): Internal.Component
        getVisibleChapters(data: Internal.TeamData): Internal.List<Internal.Chapter>
        deleteSelf(): void
        cacheProgress(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        notify(): void
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getFirstVisibleChapter(data: Internal.TeamData): Internal.Chapter
        getQuestFile(): Internal.QuestFile
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        disableToast : boolean;
        readonly file : Internal.QuestFile;
        readonly chapters : Internal.List<Internal.Chapter>;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        guiCollapsed : boolean;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get path(): string;
        get defaultGroup(): boolean;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class TypeAdapter <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        read(arg0: Internal.JsonReader): T
        notifyAll(): void
        nullSafe(): Internal.TypeAdapter<T>
        notify(): void
        fromJsonTree(arg0: Internal.JsonElement): T
        toJson(arg0: T): string
        toJson(arg0: Internal.Writer, arg1: T): void
        hashCode(): number
        equals(arg0: any): boolean
        toJsonTree(arg0: T): Internal.JsonElement
        fromJson(arg0: Internal.Reader): T
        fromJson(arg0: string): T
        toString(): string
        write(arg0: Internal.JsonWriter, arg1: T): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Number implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        intValue(): number
        notifyAll(): void
        equals(arg0: any): boolean
        floatValue(): number
        toString(): string
        shortValue(): number
        doubleValue(): number
        notify(): void
        longValue(): number
        byteValue(): number
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CollectionTag <T> extends Internal.AbstractList<any> implements Internal.Tag, Internal.CustomJavaObjectWrapper$AsList {
        getClass(): Internal.Class<any>
        wrapAsJavaList(): Internal.List<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): T
        remove(arg0: number): any
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<T>
        stream(): Internal.Stream<T>
        hashCode(): number
        get(arg0: number): T
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<T>
        indexOf(arg0: any): number
        add(arg0: number, arg1: any): void
        add(arg0: number, arg1: T): void
        add(arg0: T): boolean
        subList(arg0: number, arg1: number): Internal.List<T>
        set(arg0: number, arg1: any): any
        set(arg0: number, arg1: T): T
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<T>): void
        removeIf(arg0: (arg0: T) => boolean): boolean
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<T>): boolean
        addAll(arg0: Internal.Collection<T>): boolean
        equals(arg0: any): boolean
        listIterator(): Internal.ListIterator<T>
        listIterator(arg0: number): Internal.ListIterator<T>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExpInvokerMixin {
        an_getExperienceReward(arg0: Internal.Player): number
        an_shouldDropExperience(): boolean
    }
    class Pose extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Pose
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Pose[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Pose): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Pose>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Pose>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SLEEPING : Internal.Pose;
        static readonly FALL_FLYING : Internal.Pose;
        static readonly LONG_JUMPING : Internal.Pose;
        static readonly DYING : Internal.Pose;
        static readonly CROUCHING : Internal.Pose;
        static readonly STANDING : Internal.Pose;
        static readonly SWIMMING : Internal.Pose;
        static readonly SPIN_ATTACK : Internal.Pose;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Pose>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInt2ObjectMap <V> extends Internal.AbstractInt2ObjectFunction<any> implements Internal.Int2ObjectMap<V>, Internal.Serializable {
        getClass(): Internal.Class<any>
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        containsValue(arg0: any): boolean
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): V
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction<V>): V
        computeIfAbsent(arg0: number, arg1: (arg0: number) => V): V
        notifyAll(): void
        values(): Internal.ObjectCollection<V>
        values(): Internal.Collection<any>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): V
        replaceAll(arg0: (arg0: number, arg1: V) => V): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        remove(arg0: number): V
        remove(arg0: any): V
        remove(arg0: number, arg1: any): boolean
        remove(arg0: any, arg1: any): boolean
        notify(): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        int2ObjectEntrySet(): Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>>
        hashCode(): number
        get(arg0: any): V
        get(arg0: number): V
        putAll(arg0: Internal.Map<number, V>): void
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        forEach(arg0: (arg0: number, arg1: V) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        isEmpty(): boolean
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        toString(): string
        putIfAbsent(arg0: number, arg1: V): V
        putIfAbsent(arg0: number, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StringConfig extends Internal.ConfigFromString<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<string>
        notifyAll(): void
        isEqual(v1: string, v2: string): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<string>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(v: string): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(v: string): Internal.Component
        getStringForGUI(arg0: any): Internal.Component
        getPath(): string
        copy(value: string): string
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: string, c: (arg0: string) => void, def: string): Internal.ConfigValue<string>
        getColor(arg0: any): Internal.Color4I
        getColor(v: string): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(callback: (arg0: string) => void, string: string): boolean
        getIcon(v: string): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<string>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<string>
        setNameKey(key: string): Internal.ConfigValue<string>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: string): boolean
        static readonly COLOR : Internal.Color4I;
        defaultValue : string;
        readonly pattern : Internal.Pattern;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: string) => void;
        value : string;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: string);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PageAttributes$PrintQualityType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly HIGH : Internal.PageAttributes$PrintQualityType;
        static readonly DRAFT : Internal.PageAttributes$PrintQualityType;
        static readonly NORMAL : Internal.PageAttributes$PrintQualityType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VertexFormatElement {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getElementCount(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get elementCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongIterator extends Internal.PrimitiveIterator$OfLong {
        next(): number
        next(): any
        hasNext(): boolean
        skip(arg0: number): number
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: (arg0: any) => void): void
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: Internal.LongConsumer): void
        nextLong(): number
        remove(): void
    }
    interface BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        setSoundTypeKJS(arg0: Internal.SoundType): void
        getBlockBuilderKJS(): Internal.BlockBuilder
        setExplosionResistanceKJS(arg0: number): void
        setSpeedFactorKJS(arg0: number): void
        setJumpFactorKJS(arg0: number): void
        setBlockBuilderKJS(arg0: Internal.BlockBuilder): void
        setFrictionKJS(arg0: number): void
        setIsRandomlyTickingKJS(arg0: boolean): void
        setHasCollisionKJS(arg0: boolean): void
        setMaterialKJS(arg0: Internal.Material): void
    }
    abstract class BlockEntityInstance <T> extends Internal.AbstractInstance {
        getClass(): Internal.Class<any>
        init(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        notifyAll(): void
        getInstancePosition(): BlockPos
        update(): void
        updateLight(): void
        notify(): void
        remove(): void
        getWorldPosition(): BlockPos
        getVolume(): Internal.ImmutableBox
        hashCode(): number
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        equals(arg0: any): boolean
        toString(): string
        shouldReset(): boolean
        status(): Internal.ListenerStatus
        readonly world : net.minecraft.world.level.Level;
        get volume(): Internal.ImmutableBox;
        get worldPosition(): BlockPos;
        get instancePosition(): BlockPos;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ObjectiveCriteria {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface VertexType {
        createWriter(arg0: Internal.ByteBuffer): Internal.VertexWriter
        getLayout(): Internal.BufferLayout
        getStride(): number
        byteOffset(arg0: number): number
        createReader(arg0: Internal.ByteBuffer, arg1: number): Internal.VertexList
        getShaderHeader(): string
    }
    class Direction extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getIndex(): number
        static valueOf(arg0: string): Internal.Direction
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Direction[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Direction): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Direction>>
        notify(): void
        getClockWise(): Internal.Direction
        getDeclaringClass(): Internal.Class<Internal.Direction>
        getYaw(): number
        getHorizontalIndex(): number
        getX(): number
        getY(): number
        getPitch(): number
        getZ(): number
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        getCounterClockWise(): Internal.Direction
        toString(): string
        getOpposite(): Internal.Direction
        ordinal(): number
        static readonly DOWN : Internal.Direction;
        static readonly NORTH : Internal.Direction;
        static readonly WEST : Internal.Direction;
        static readonly UP : Internal.Direction;
        static readonly SOUTH : Internal.Direction;
        static readonly EAST : Internal.Direction;
        get clockWise(): Internal.Direction;
        get horizontalIndex(): number;
        get x(): number;
        get index(): number;
        get y(): number;
        get z(): number;
        get counterClockWise(): Internal.Direction;
        get opposite(): Internal.Direction;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get yaw(): number;
        get declaringClass(): Internal.Class<Internal.Direction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TextStyle extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.TextStyle
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.TextStyle[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.TextStyle): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TextStyle>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.TextStyle>
        asNormal(): Internal.TextStyle
        hashCode(): number
        equals(arg0: any): boolean
        isStandalone(): boolean
        name(): string
        toString(): string
        asStandalone(): Internal.TextStyle
        ordinal(): number
        static readonly SHORT_STANDALONE : Internal.TextStyle;
        static readonly NARROW_STANDALONE : Internal.TextStyle;
        static readonly FULL_STANDALONE : Internal.TextStyle;
        static readonly FULL : Internal.TextStyle;
        static readonly SHORT : Internal.TextStyle;
        static readonly NARROW : Internal.TextStyle;
        get standalone(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TextStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ImageConsumer {
        imageComplete(arg0: number): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ColorModel, arg5: number[], arg6: number, arg7: number): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ColorModel, arg5: number[], arg6: number, arg7: number): void
        setProperties(arg0: Internal.Hashtable<any, any>): void
        setDimensions(arg0: number, arg1: number): void
        setHints(arg0: number): void
        setColorModel(arg0: Internal.ColorModel): void
    }
    class CookingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        cookingTime(time: number): Internal.CookingRecipeJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        xp(xp: number): Internal.CookingRecipeJS
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor {
        descriptorString(): string
    }
    interface StackedContentsCompatible {
    }
    class ImmutableSetMultimap <K, V> extends Internal.ImmutableMultimap<any, any> implements Internal.SetMultimap<K, V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        keys(): Internal.ImmutableMultiset<K>
        keys(): Internal.Multiset<any>
        asMap(): Internal.Map<any, any>
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>
        notifyAll(): void
        values(): Internal.ImmutableCollection<V>
        values(): Internal.Collection<any>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        static flatteningToImmutableSetMultimap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => Internal.Stream<V_>): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>
        removeAll(arg0: any): Internal.Set<any>
        removeAll(arg0: any): Internal.ImmutableSet<V>
        removeAll(arg0: any): Internal.ImmutableCollection<any>
        removeAll(arg0: any): Internal.Collection<any>
        hashCode(): number
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        putAll(arg0: Internal.Multimap<K, V>): boolean
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(): Internal.ImmutableSetMultimap<K_, V_>
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>
        get(arg0: any): Internal.ImmutableCollection<any>
        get(arg0: any): Internal.Collection<any>
        get(arg0: any): Internal.Set<any>
        get(arg0: K): Internal.ImmutableSet<V>
        static builder<K_, V_>(): Internal.ImmutableSetMultimap$Builder<K_, V_>
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>
        keySet(): Internal.Set<any>
        keySet(): Internal.ImmutableSet<K>
        containsEntry(arg0: any, arg1: any): boolean
        inverse(): Internal.ImmutableMultimap<any, any>
        inverse(): Internal.ImmutableSetMultimap<V, K>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableSetMultimap<K_, V_>
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMultimap<K_, V_>
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableSetMultimap<K_, V_>
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableMultimap<K_, V_>
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Set<any>
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSet<V>
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.ImmutableCollection<any>
        static toImmutableSetMultimap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>
        entries(): Internal.Collection<any>
        entries(): Internal.Set<any>
        entries(): Internal.ImmutableCollection<any>
        entries(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>
        size(): number
        equals(arg0: any): boolean
        toString(): string
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Tag {
        toString(): string
    }
    abstract class Player extends Internal.LivingEntity implements Internal.PlayerAccess, Internal.AccessorPlayer, Internal.IVampirismPlayer, Internal.PlayerKJS {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        botania$setCritTarget(arg0: Internal.LivingEntity): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number
        dynamicLightTick(): void
        handler$zib000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getSuffixes(): Internal.Collection<Internal.MutableComponent>
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        setForcedPose(arg0: Internal.Pose): void
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        getPrefixes(): Internal.Collection<Internal.MutableComponent>
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getVampAtts(): Internal.VampirismPlayerAttributes
        getClassification(arg0: boolean): Internal.MobCategory
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zjf000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable<any>): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        getStagesRawKJS(): Internal.Stages
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        getStages(): Internal.Stages
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        darkutils$setSleepTimer(arg0: number): void
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        darkutils$setEnchantmentSeed(arg0: number): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        redirect$zcm001$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        refreshDisplayName(): void
        getForcedPose(): Internal.Pose
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get isInsidePortal(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get stagesRawKJS(): Internal.Stages;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get vampAtts(): Internal.VampirismPlayerAttributes;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get persistentDataKJS(): Internal.CompoundTag;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootBuilder implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        getClass(): Internal.Class<any>
        clearFunctions(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        survivesExplosion(): Internal.ConditionContainer
        notifyAll(): void
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(o: Internal.JsonObject): Internal.LootBuilder
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        notify(): void
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        addPool(p: (arg0: Internal.LootBuilderPool) => void): void
        hashCode(): number
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootBuilder
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        toJson(): Internal.JsonObject
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        clearPools(): void
        equals(arg0: any): boolean
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        toString(): string
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        clearConditions(): void
        functions : Internal.JsonArray;
        pools : Internal.JsonArray;
        type : string;
        conditions : Internal.JsonArray;
        customId : ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SNBTCompoundTag extends Internal.CompoundTag {
        getCompound(string: string): Internal.SNBTCompoundTag
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        wrapAsJavaMap(): Internal.Map<any, any>
        singleLine(): void
        singleLine(key: string): void
        notify(): void
        getNullableList(key: string, type: number): Internal.ListTag
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
        putNumber(key: string, number: Internal.Number): void
        isBoolean(key: string): boolean
        hashCode(): number
        getList<T_>(key: string, type: Internal.Class<T_>): Internal.List<T_>
        equals(arg0: any): boolean
        merge(arg0: Internal.CompoundTag): Internal.CompoundTag
        static of(tag: Internal.Tag): Internal.SNBTCompoundTag
        toString(): string
        getComment(key: string): string
        comment(key: string, comment: string[]): void
        comment(key: string, comment: string): void
        putNull(key: string): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class NumberConfig <T> extends Internal.ConfigFromString<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        notifyAll(): void
        isEqual(v1: Internal.ConfigValue<Internal.ConfigValue<T>>, v2: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(arg0: any): Internal.Component
        getStringForGUI(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Component
        getPath(): string
        copy(value: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.ConfigValue<Internal.ConfigValue<T>>, c: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, def: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getColor(arg0: any): Internal.Color4I
        getColor(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(arg0: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, arg1: string): boolean
        getIcon(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        fader(v: boolean): Internal.NumberConfig<Internal.ConfigValue<Internal.ConfigValue<T>>>
        readonly min : Internal.ConfigValue<Internal.ConfigValue<T>>;
        readonly max : Internal.ConfigValue<Internal.ConfigValue<T>>;
        static readonly COLOR : Internal.Color4I;
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void;
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AgeableModelAccessor {
        getBodyParts_vampirism(): Internal.Iterable<Internal.ModelPart>
    }
    class Products$P6 <F, T1, T2, T3, T4, T5, T6> {
        t4(): Internal.App<F, T4>
        getClass(): Internal.Class<any>
        t5(): Internal.App<F, T5>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        t6(): Internal.App<F, T6>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function6<T1, T2, T3, T4, T5, T6, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.App<F, R>
        notifyAll(): void
        notify(): void
        hashCode(): number
        and<T7, T8>(arg0: Internal.Products$P2<F, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T7>(arg0: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    interface IngredientJS extends Internal.JsonSerializable, Internal.WrappedJS, Internal.Copyable {
        getItemIds(): Internal.Set<string>
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        anyStackMatches(ingredient: string): boolean
        anyStackMatches(ingredient: object): boolean
        anyStackMatches(ingredient: Internal.ItemStackJS): boolean
        test(arg0: string): boolean
        test(arg0: object): boolean
        test(arg0: Internal.ItemStackJS): boolean
        testVanillaItem(item: Internal.Item): boolean
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        isEmpty(): boolean
        isInvalidRecipeIngredient(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: object): Internal.IngredientJS
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        filter(filter: Internal.ItemStackJS): Internal.IngredientJS
        filter(filter: string): Internal.IngredientJS
        createVanillaIngredient(): (arg0: any) => boolean
        not(): Internal.IngredientJS
        toJson(): Internal.JsonElement
        withCount(count: number): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        getFirst(): Internal.ItemStackJS
        testVanilla(stack: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        copy(): Internal.Copyable
        copy(): Internal.IngredientJS
        getCount(): number
    }
    interface FuncSupplier$Func2 extends Internal.FuncSupplier {
        create2(arg0: Internal.Unit, arg1: Internal.Unit): Internal.Unit
        create(args: Internal.List<Internal.Unit>): Internal.Unit
    }
    interface SortedSet <E> extends Internal.Set<E> {
        add(arg0: E): boolean
        tailSet(arg0: E): Internal.SortedSet<E>
        last(): E
        headSet(arg0: E): Internal.SortedSet<E>
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        comparator(): Internal.Comparator<E>
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        subSet(arg0: E, arg1: E): Internal.SortedSet<E>
        parallelStream(): Internal.Stream<E>
        first(): E
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    class ItemRegistryEventJS extends Internal.StartupEventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        post(id: string): boolean
        post(id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        create(name: string, callback: (arg0: Internal.ItemBuilder) => void): void
        toString(): string
        createFood(builder: () => Internal.FoodBuilder): () => Internal.FoodBuilder
        notify(): void
        canCancel(): boolean
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EventLoopGroup extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        next(): Internal.EventLoop
        next(): Internal.EventExecutor
        terminationFuture(): Internal.Future<any>
        submit(arg0: Internal.Runnable): Internal.Future<any>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        shutdownGracefully(): Internal.Future<any>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>
        spliterator(): Internal.Spliterator<Internal.EventExecutor>
        isTerminated(): boolean
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        register(arg0: io.netty.channel.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: io.netty.channel.Channel): Internal.ChannelFuture
    }
    interface AccessorItem {
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
    }
    interface AttributeView {
        name(): string
    }
    class GameRenderer implements Internal.ResourceManagerReloadListener, Internal.AutoCloseable, Internal.GameRendererAccessor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zoh000$updateCameraAndRender(arg0: number, arg1: number, arg2: boolean, arg3: Internal.CallbackInfo): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        constant$bnl000$pickCreative(arg0: number): number
        constant$bnl000$pick(arg0: number): number
        toString(): string
        close(): void
        create$callGetFov(arg0: Internal.Camera, arg1: number, arg2: boolean): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MinecraftServerKJS extends Internal.AsKJS {
        getServerResourcesKJS(): Internal.ServerResources
        asKJS(): any
    }
    class ContinuationPending extends Internal.RuntimeException {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        printStackTrace(): void
        printStackTrace(arg0: Internal.PrintStream): void
        printStackTrace(arg0: Internal.PrintWriter): void
        getLocalizedMessage(): string
        notifyAll(): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        getApplicationState(): any
        getCause(): Internal.Throwable
        notify(): void
        getContinuation(): any
        addSuppressed(arg0: Internal.Throwable): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        getStackTrace(): Internal.StackTraceElement[]
        setApplicationState(applicationState: any): void
        hashCode(): number
        equals(arg0: any): boolean
        getSuppressed(): Internal.Throwable[]
        toString(): string
        fillInStackTrace(): Internal.Throwable
        setContinuation(continuation: Internal.NativeContinuation): void
        get localizedMessage(): string;
        get applicationState(): any;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        get continuation(): any;
        set applicationState(applicationState: any);
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockContainerJS implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spawnFireworks(fireworks: Internal.FireworksJS): void
        notifyAll(): void
        getItem(): Internal.ItemStackJS
        getBiomeId(): string
        getId(): string
        getUp(): Internal.BlockContainerJS
        getTags(): Internal.Collection<ResourceLocation>
        clearCache(): void
        getCanSeeSky(): boolean
        getEast(): Internal.BlockContainerJS
        notify(): void
        getNorth(): Internal.BlockContainerJS
        hashCode(): number
        getPos(): BlockPos
        setEntityData(tag: Internal.CompoundTag): void
        getDimension(): string
        mergeEntityData(tag: Internal.CompoundTag): void
        getEntityId(): string
        getInventory(facing: Internal.Direction): Internal.InventoryJS
        getLight(): number
        getPlayersInRadius(): Internal.EntityArrayList
        getPlayersInRadius(radius: number): Internal.EntityArrayList
        getWest(): Internal.BlockContainerJS
        set(id: ResourceLocation, properties: Internal.Map<any, any>, flags: number): void
        set(id: ResourceLocation, properties: Internal.Map<any, any>): void
        set(id: ResourceLocation): void
        offset(x: number, y: number, z: number): Internal.BlockContainerJS
        offset(f: Internal.Direction): Internal.BlockContainerJS
        offset(f: Internal.Direction, d: number): Internal.BlockContainerJS
        hasTag(tag: ResourceLocation): boolean
        getDown(): Internal.BlockContainerJS
        getProperties(): Internal.Map<string, string>
        createExplosion(): Internal.ExplosionJS
        setBlockState(state: Internal.BlockState, flags: number): void
        getEntity(): Internal.BlockEntity
        createEntity(id: ResourceLocation): Internal.EntityJS
        getMaterial(): Internal.MaterialJS
        getSouth(): Internal.BlockContainerJS
        getLevel(): Internal.LevelJS
        spawnLightning(effectOnly: boolean): void
        spawnLightning(effectOnly: boolean, player: Internal.EntityJS): void
        getX(): number
        getY(): number
        getZ(): number
        equals(obj: any): boolean
        getEntityData(): Internal.CompoundTag
        toString(): string
        getBlockState(): Internal.BlockState
        specialEquals(o: any, shallow: boolean): boolean
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get blockState(): Internal.BlockState;
        get biomeId(): string;
        get south(): Internal.BlockContainerJS;
        get playersInRadius(): Internal.EntityArrayList;
        get north(): Internal.BlockContainerJS;
        get down(): Internal.BlockContainerJS;
        get east(): Internal.BlockContainerJS;
        get pos(): BlockPos;
        get west(): Internal.BlockContainerJS;
        get id(): string;
        get up(): Internal.BlockContainerJS;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get canSeeSky(): boolean;
        get entityId(): string;
        get tags(): Internal.Collection<ResourceLocation>;
        get material(): Internal.MaterialJS;
        get light(): number;
        get x(): number;
        get y(): number;
        get z(): number;
        get properties(): Internal.Map<string, string>;
        get entity(): Internal.BlockEntity;
        get entityData(): Internal.CompoundTag;
        set entityData(tag: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableMultiset$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableMultiset$Builder<E>
        add(arg0: any): Internal.ImmutableCollection$Builder<any>
        add(arg0: E): Internal.ImmutableMultiset$Builder<E>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableMultiset$Builder<E>
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableMultiset$Builder<E>
        build(): Internal.ImmutableCollection<any>
        build(): Internal.ImmutableMultiset<E>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        addCopies(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>
        notify(): void
        setCount(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CokeOvenRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        creosote(c: number): Internal.CokeOvenRecipeJS
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class URLConnection {
        getClass(): Internal.Class<any>
        setConnectTimeout(arg0: number): void
        getHeaderFieldLong(arg0: string, arg1: number): number
        setUseCaches(arg0: boolean): void
        setRequestProperty(arg0: string, arg1: string): void
        getDoInput(): boolean
        getIfModifiedSince(): number
        getPermission(): Internal.Permission
        static getDefaultAllowUserInteraction(): boolean
        getDefaultUseCaches(): boolean
        static getDefaultUseCaches(arg0: string): boolean
        getAllowUserInteraction(): boolean
        getConnectTimeout(): number
        getContentLength(): number
        getInputStream(): Internal.InputStream
        setAllowUserInteraction(arg0: boolean): void
        getRequestProperties(): Internal.Map<string, Internal.List<string>>
        getURL(): Internal.URL
        getHeaderField(arg0: string): string
        getHeaderField(arg0: number): string
        getHeaderFields(): Internal.Map<string, Internal.List<string>>
        getContentLengthLong(): number
        static setDefaultAllowUserInteraction(arg0: boolean): void
        getContentType(): string
        setDefaultUseCaches(arg0: boolean): void
        static setDefaultUseCaches(arg0: string, arg1: boolean): void
        setDoOutput(arg0: boolean): void
        static guessContentTypeFromName(arg0: string): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLastModified(): number
        setIfModifiedSince(arg0: number): void
        notifyAll(): void
        getReadTimeout(): number
        getContent(arg0: Internal.Class<any>[]): any
        getContent(): any
        notify(): void
        getHeaderFieldInt(arg0: string, arg1: number): number
        getRequestProperty(arg0: string): string
        static guessContentTypeFromStream(arg0: Internal.InputStream): string
        hashCode(): number
        static setDefaultRequestProperty(arg0: string, arg1: string): void
        getHeaderFieldDate(arg0: string, arg1: number): number
        getDate(): number
        static getFileNameMap(): Internal.FileNameMap
        getHeaderFieldKey(arg0: number): string
        connect(): void
        static setContentHandlerFactory(arg0: Internal.ContentHandlerFactory): void
        getContentEncoding(): string
        getUseCaches(): boolean
        setDoInput(arg0: boolean): void
        addRequestProperty(arg0: string, arg1: string): void
        setReadTimeout(arg0: number): void
        getExpiration(): number
        static getDefaultRequestProperty(arg0: string): string
        equals(arg0: any): boolean
        static setFileNameMap(arg0: Internal.FileNameMap): void
        getOutputStream(): Internal.OutputStream
        toString(): string
        getDoOutput(): boolean
        get date(): number;
        get contentLengthLong(): number;
        get defaultUseCaches(): boolean;
        get requestProperties(): Internal.Map<string, Internal.List<string>>;
        get useCaches(): boolean;
        get ifModifiedSince(): number;
        get content(): any;
        get doOutput(): boolean;
        get connectTimeout(): number;
        get contentEncoding(): string;
        get headerFields(): Internal.Map<string, Internal.List<string>>;
        get outputStream(): Internal.OutputStream;
        get class(): Internal.Class<any>;
        get contentType(): string;
        get defaultAllowUserInteraction(): boolean;
        get inputStream(): Internal.InputStream;
        get permission(): Internal.Permission;
        get doInput(): boolean;
        get uRL(): Internal.URL;
        get allowUserInteraction(): boolean;
        get readTimeout(): number;
        get contentLength(): number;
        get fileNameMap(): Internal.FileNameMap;
        get expiration(): number;
        get lastModified(): number;
        set doOutput(arg0: boolean);
        set defaultUseCaches(arg0: boolean);
        set defaultAllowUserInteraction(arg0: boolean);
        set useCaches(arg0: boolean);
        set readTimeout(arg0: number);
        set connectTimeout(arg0: number);
        set fileNameMap(arg0: Internal.FileNameMap);
        set ifModifiedSince(arg0: number);
        set doInput(arg0: boolean);
        set contentHandlerFactory(arg0: Internal.ContentHandlerFactory);
        set allowUserInteraction(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Applicative <F, Mu> extends Internal.Functor<F, Mu> {
        point<A_>(arg0: A_): Internal.App<Mu, A_>
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Mu, T_>): Internal.App<Mu, R_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Mu, A_>, arg2: Internal.App<Mu, B_>): Internal.App<Mu, R_>
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>): Internal.App<Mu, R_>
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Mu, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>): Internal.App<Mu, R_>
        ap2<A_, B_, R_>(arg0: Internal.App<Mu, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Mu, A_>, arg2: Internal.App<Mu, B_>): Internal.App<Mu, R_>
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>): Internal.App<Mu, R_>
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Mu, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>): Internal.App<Mu, R_>
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>): Internal.App<Mu, R_>
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>): Internal.App<Mu, R_>
        lift2<A_, B_, R_>(arg0: Internal.App<Mu, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Mu, A_>, arg1: Internal.App<Mu, B_>) => Internal.App<Mu, R_>
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Mu, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>): Internal.App<Mu, R_>
        lift1<A_, R_>(arg0: Internal.App<Mu, (arg0: A_) => R_>): (arg0: Internal.App<Mu, A_>) => Internal.App<Mu, R_>
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>): Internal.App<Mu, R_>
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>): Internal.App<Mu, R_>
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>): Internal.App<Mu, R_>
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, R_>>
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>): Internal.App<Mu, R_>
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, R_>>
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, R_>>
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>): Internal.App<Mu, R_>
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Mu, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, R_>>
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>): Internal.App<Mu, R_>
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>): Internal.App<Mu, R_>
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, T9_>, Internal.App<Mu, R_>>
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>): Internal.App<Mu, R_>
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, R_>>
        ap<A_, R_>(arg0: Internal.App<Mu, (arg0: A_) => R_>, arg1: Internal.App<Mu, A_>): Internal.App<Mu, R_>
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Mu, A_>): Internal.App<Mu, R_>
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>): Internal.App<Mu, R_>
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, R_>>
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Mu, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>, arg15: Internal.App<Mu, T15_>, arg16: Internal.App<Mu, T16_>): Internal.App<Mu, R_>
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Mu, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>): Internal.App<Mu, R_>
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Mu, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>): Internal.App<Mu, R_>
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Mu, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>, arg15: Internal.App<Mu, T15_>): Internal.App<Mu, R_>
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Mu, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>): Internal.App<Mu, R_>
    }
    abstract class LivingEntity extends Internal.Entity implements Internal.ExpInvokerMixin, Internal.AccessorLivingEntity, Internal.ICitadelDataEntity, Internal.LivingEntityAccessor, Internal.LivingEntityKJS, net.blay09.mods.netherportalfix.mixin.LivingEntityAccessor, de.teamlapen.vampirism.mixin.LivingEntityAccessor, com.simibubi.create.foundation.mixin.accessor.LivingEntityAccessor {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        dynamicLightTick(): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getClassification(arg0: boolean): Internal.MobCategory
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TemporalAdjuster {
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
    }
    abstract class Monster extends Internal.PathfinderMob implements Internal.Enemy {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        setLootTable(arg0: ResourceLocation): void
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        dynamicLightTick(): void
        getGoalSelector(): Internal.GoalSelector
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        botania_getAmbientSound(): Internal.SoundEvent
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getClassification(arg0: boolean): Internal.MobCategory
        getTargetSelector(): Internal.GoalSelector
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get goalSelector(): Internal.GoalSelector;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get targetSelector(): Internal.GoalSelector;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set lootTable(arg0: ResourceLocation);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface JsonReloadListenerAccess {
        getGson(): Internal.Gson
    }
    class ScreenManager {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityWeight {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        readData(nbt: Internal.CompoundTag): void
        hashCode(): number
        readNetData(data: Internal.FriendlyByteBuf): void
        getWeight(entity: Internal.Entity): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        writeData(nbt: Internal.CompoundTag): void
        notify(): void
        writeNetData(data: Internal.FriendlyByteBuf): void
        boss : number;
        passive : number;
        monster : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MappedRegistry <T> extends Internal.WritableRegistry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        hashCode(): number
        keys<U_>(arg0: Internal.DynamicOps<U_>): Internal.Stream<U_>
        notifyAll(): void
        equals(arg0: any): boolean
        static invokeRegisterSimple_$md$204703$1(arg0: Internal.ResourceKey<any>, arg1: () => any)): Internal.Registry<any>
        static callRegisterDefaulted_$md$204703$0(arg0: Internal.ResourceKey<any>, arg1: string, arg2: () => any)): Internal.DefaultedRegistry<any>
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemSupplier {
    }
    interface ChannelConfig {
        setMessageSizeEstimator(arg0: Internal.MessageSizeEstimator): Internal.ChannelConfig
        setWriteBufferLowWaterMark(arg0: number): Internal.ChannelConfig
        getWriteBufferLowWaterMark(): number
        getMessageSizeEstimator(): Internal.MessageSizeEstimator
        setRecvByteBufAllocator(arg0: Internal.RecvByteBufAllocator): Internal.ChannelConfig
        getOption<T>(arg0: Internal.ChannelOption<T>): T
        isAutoClose(): boolean
        getRecvByteBufAllocator<T>(): T
        setAllocator(arg0: Internal.ByteBufAllocator): Internal.ChannelConfig
        getAllocator(): Internal.ByteBufAllocator
        isAutoRead(): boolean
        setOptions(arg0: Internal.Map<Internal.ChannelOption<any>, any>): boolean
        setConnectTimeoutMillis(arg0: number): Internal.ChannelConfig
        setWriteBufferWaterMark(arg0: Internal.WriteBufferWaterMark): Internal.ChannelConfig
        setOption<T>(arg0: Internal.ChannelOption<T>, arg1: T): boolean
        setWriteSpinCount(arg0: number): Internal.ChannelConfig
        getConnectTimeoutMillis(): number
        setWriteBufferHighWaterMark(arg0: number): Internal.ChannelConfig
        getMaxMessagesPerRead(): number
        getWriteBufferHighWaterMark(): number
        setAutoRead(arg0: boolean): Internal.ChannelConfig
        getWriteSpinCount(): number
        setMaxMessagesPerRead(arg0: number): Internal.ChannelConfig
        getOptions(): Internal.Map<Internal.ChannelOption<any>, any>
        getWriteBufferWaterMark(): Internal.WriteBufferWaterMark
        setAutoClose(arg0: boolean): Internal.ChannelConfig
    }
    interface ListBuilder <T> {
        add<E>(arg0: E, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>
        add(arg0: Internal.DataResult<T>): Internal.ListBuilder<T>
        add(arg0: T): Internal.ListBuilder<T>
        withErrorsFrom(arg0: Internal.DataResult<any>): Internal.ListBuilder<T>
        mapError(arg0: (arg0: any) => any): Internal.ListBuilder<T>
        ops(): Internal.DynamicOps<T>
        addAll<E>(arg0: Internal.Iterable<E>, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>
        build(arg0: T): Internal.DataResult<T>
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>
    }
    interface Char2CharFunction extends Internal.Function<string, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: string, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: string) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: string, arg1: string): string
        put(arg0: string, arg1: string): string
        remove(arg0: any): string
        remove(arg0: any): any
        remove(arg0: string): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): string
        get(arg0: any): any
        get(arg0: string): string
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: string): string
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Double2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class HitResult {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface VoxelShapeAccess {
        setFaces(arg0: Internal.VoxelShape[]): void
        getFaces(): Internal.VoxelShape[]
        getShape(): Internal.DiscreteVoxelShape
        setShape(arg0: Internal.DiscreteVoxelShape): void
    }
    interface IBlockEntityLevel {
        getLoadedBlockEntities_HammerLib(): Internal.List<Internal.BlockEntity>
        loadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        unloadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
    }
    class SetTag <T> implements net.minecraft.tags.Tag<T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MapDecoder <A> extends Internal.Keyable {
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.MapDecoder<B_>
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        decoder(): Internal.Decoder<A>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<A>
        map<B_>(arg0: (arg0: A) => B_): Internal.MapDecoder<B_>
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
        ap<E_>(arg0: Internal.MapDecoder<(arg0: A) => E_>): Internal.MapDecoder<E_>
    }
    class DataOutputStream extends Internal.FilterOutputStream implements Internal.DataOutput {
        writeInt(arg0: number): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeByte(arg0: number): void
        notifyAll(): void
        writeFloat(arg0: number): void
        notify(): void
        writeChar(arg0: number): void
        writeLong(arg0: number): void
        writeBytes(arg0: string): void
        size(): number
        flush(): void
        hashCode(): number
        equals(arg0: any): boolean
        writeUTF(arg0: string): void
        toString(): string
        static nullOutputStream(): Internal.OutputStream
        writeShort(arg0: number): void
        writeChars(arg0: string): void
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
        write(arg0: number[]): void
        writeBoolean(arg0: boolean): void
        writeDouble(arg0: number): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Exception extends Internal.Throwable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        printStackTrace(): void
        printStackTrace(arg0: Internal.PrintStream): void
        printStackTrace(arg0: Internal.PrintWriter): void
        getLocalizedMessage(): string
        notifyAll(): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        getCause(): Internal.Throwable
        notify(): void
        addSuppressed(arg0: Internal.Throwable): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        getStackTrace(): Internal.StackTraceElement[]
        hashCode(): number
        equals(arg0: any): boolean
        getSuppressed(): Internal.Throwable[]
        toString(): string
        fillInStackTrace(): Internal.Throwable
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RandomGenerator {
        nextFloat(): number
        nextFloat(arg0: number): number
        nextFloat(arg0: number, arg1: number): number
        isDeprecated(): boolean
        nextInt(): number
        nextInt(arg0: number): number
        nextInt(arg0: number, arg1: number): number
        nextLong(arg0: number, arg1: number): number
        nextLong(arg0: number): number
        nextLong(): number
        nextDouble(arg0: number): number
        nextDouble(): number
        nextDouble(arg0: number, arg1: number): number
        nextGaussian(): number
        nextGaussian(arg0: number, arg1: number): number
        nextBytes(arg0: number[]): void
        longs(arg0: number): Internal.LongStream
        longs(arg0: number, arg1: number): Internal.LongStream
        longs(): Internal.LongStream
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream
        nextExponential(): number
        ints(): Internal.IntStream
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream
        ints(arg0: number): Internal.IntStream
        ints(arg0: number, arg1: number): Internal.IntStream
        doubles(arg0: number): Internal.DoubleStream
        doubles(): Internal.DoubleStream
        doubles(arg0: number, arg1: number): Internal.DoubleStream
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream
        nextBoolean(): boolean
    }
    interface IAntiqueTextProvider {
        setAntiqueInk(arg0: boolean): void
        hasAntiqueInk(): boolean
    }
    interface BinaryOperator <T> extends Internal.BiFunction<T, T, T> {
        apply(arg0: T, arg1: T): T
        andThen<V_>(arg0: (arg0: T) => V_): (arg0: T, arg1: T) => V_
    }
    class GlyphJustificationInfo {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly growRightLimit : number;
        static readonly PRIORITY_WHITESPACE : 1;
        readonly shrinkLeftLimit : number;
        readonly weight : number;
        readonly shrinkRightLimit : number;
        readonly shrinkAbsorb : boolean;
        readonly growPriority : number;
        static readonly PRIORITY_KASHIDA : 0;
        readonly growAbsorb : boolean;
        static readonly PRIORITY_NONE : 3;
        readonly growLeftLimit : number;
        static readonly PRIORITY_INTERCHAR : 2;
        readonly shrinkPriority : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Stream <T> extends Internal.BaseStream<T, Internal.Stream<T>> {
        sequential(): Internal.Stream<T>
        takeWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>
        distinct(): Internal.Stream<T>
        findFirst(): Internal.Optional<T>
        skip(arg0: number): Internal.Stream<T>
        toList(): Internal.List<T>
        allMatch(arg0: (arg0: T) => boolean): boolean
        mapMultiToDouble(arg0: (arg0: T, arg1: Internal.DoubleConsumer) => void): Internal.DoubleStream
        iterator(): Internal.Iterator<T>
        mapMulti<R_>(arg0: (arg0: T, arg1: (arg0: R_) => void) => void): Internal.Stream<R_>
        flatMapToInt(arg0: (arg0: T) => Internal.IntStream): Internal.IntStream
        min(arg0: Internal.Comparator<T>): Internal.Optional<T>
        flatMapToLong(arg0: (arg0: T) => Internal.LongStream): Internal.LongStream
        parallel(): Internal.Stream<T>
        mapToLong(arg0: Internal.ToLongFunction<T>): Internal.LongStream
        noneMatch(arg0: (arg0: T) => boolean): boolean
        findAny(): Internal.Optional<T>
        isParallel(): boolean
        limit(arg0: number): Internal.Stream<T>
        toArray(): any[]
        toArray<A_>(arg0: Internal.IntFunction<A_[]>): A_[]
        forEachOrdered(arg0: (arg0: T) => void): void
        close(): void
        anyMatch(arg0: (arg0: T) => boolean): boolean
        map<R_>(arg0: (arg0: T) => R_): Internal.Stream<R_>
        mapToDouble(arg0: Internal.ToDoubleFunction<T>): Internal.DoubleStream
        unordered(): Internal.Stream<T>
        mapMultiToLong(arg0: (arg0: T, arg1: Internal.LongConsumer) => void): Internal.LongStream
        mapMultiToInt(arg0: (arg0: T, arg1: java_.util.function_.IntConsumer) => void): Internal.IntStream
        reduce<U_>(arg0: U_, arg1: (arg0: U_, arg1: T) => U_, arg2: (arg0: any, arg1: any) => any): U_
        reduce(arg0: T, arg1: (arg0: any, arg1: any) => any): T
        reduce(arg0: (arg0: any, arg1: any) => any): Internal.Optional<T>
        spliterator(): Internal.Spliterator<T>
        max(arg0: Internal.Comparator<T>): Internal.Optional<T>
        forEach(arg0: (arg0: T) => void): void
        count(): number
        dropWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>
        flatMapToDouble(arg0: (arg0: T) => Internal.DoubleStream): Internal.DoubleStream
        peek(arg0: (arg0: T) => void): Internal.Stream<T>
        flatMap<R_>(arg0: (arg0: T) => Internal.Stream<R_>): Internal.Stream<R_>
        filter(arg0: (arg0: T) => boolean): Internal.Stream<T>
        onClose(arg0: Internal.Runnable): Internal.Stream<T>
        sorted(): Internal.Stream<T>
        sorted(arg0: Internal.Comparator<T>): Internal.Stream<T>
        mapToInt(arg0: Internal.ToIntFunction<T>): Internal.IntStream
        collect<R_>(arg0: () => R_, arg1: (arg0: R_, arg1: T) => void, arg2: (arg0: R_, arg1: R_) => void): R_
        collect<R_, A_>(arg0: Internal.Collector<T, A_, R_>): R_
    }
    class SpawnPlacements$Type extends Internal.Enum<any> implements Internal.IExtensibleEnum {
        init(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.SpawnPlacements$Type
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.SpawnPlacements$Type[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.SpawnPlacements$Type): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.SpawnPlacements$Type>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.SpawnPlacements$Type>
        hashCode(): number
        canSpawnAt(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.EntityType<any>): boolean
        equals(arg0: any): boolean
        name(): string
        static create(arg0: string, arg1: Internal.TriPredicate<Internal.LevelReader, BlockPos, Internal.EntityType<Internal.Mob>>): Internal.SpawnPlacements$Type
        toString(): string
        ordinal(): number
        static readonly IN_LAVA : Internal.SpawnPlacements$Type;
        static readonly IN_WATER : Internal.SpawnPlacements$Type;
        static readonly ON_GROUND : Internal.SpawnPlacements$Type;
        static readonly NO_RESTRICTIONS : Internal.SpawnPlacements$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.SpawnPlacements$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ShortFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        removeShort(arg0: any): number
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): number
        getShort(arg0: any): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface JsonSerializable {
        toJson(): Internal.JsonElement
    }
    interface AccessorItemEntity {
        setAge(arg0: number): void
        getPickupDelay(): number
    }
    interface AccessorMinecraft {
        bookshelf$getFontManager(): Internal.FontManager
    }
    interface DropTargetListener extends Internal.EventListener {
        drop(arg0: Internal.DropTargetDropEvent): void
        dragEnter(arg0: Internal.DropTargetDragEvent): void
        dropActionChanged(arg0: Internal.DropTargetDragEvent): void
        dragOver(arg0: Internal.DropTargetDragEvent): void
        dragExit(arg0: Internal.DropTargetEvent): void
    }
    interface Int2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface DamageSourceAccessor {
        callBypassArmor(): Internal.DamageSource
        callBypassMagic(): Internal.DamageSource
        callBypassInvul(): Internal.DamageSource
    }
    class NetworkEvent extends net.minecraftforge.eventbus.api.Event {
        setCanceled(arg0: boolean): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLoginIndex(): number
        isCanceled(): boolean
        setResult(arg0: Internal.Event$Result): void
        notifyAll(): void
        hasResult(): boolean
        notify(): void
        getPayload(): Internal.FriendlyByteBuf
        getListenerList(): Internal.ListenerList
        hashCode(): number
        getSource(): () => Internal.NetworkEvent$Context
        equals(arg0: any): boolean
        getResult(): Internal.Event$Result
        toString(): string
        isCancelable(): boolean
        getPhase(): Internal.EventPriority
        setPhase(arg0: Internal.EventPriority): void
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get loginIndex(): number;
        get payload(): Internal.FriendlyByteBuf;
        get listenerList(): Internal.ListenerList;
        get source(): () => Internal.NetworkEvent$Context;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SqueezerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2ShortFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface AccessibleAction {
        getAccessibleActionDescription(arg0: number): string
        doAccessibleAction(arg0: number): boolean
        getAccessibleActionCount(): number
    }
    class ServerPlayer extends Internal.Player {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        botania$setCritTarget(arg0: Internal.LivingEntity): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number
        dynamicLightTick(): void
        handler$zib000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getSuffixes(): Internal.Collection<Internal.MutableComponent>
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        setForcedPose(arg0: Internal.Pose): void
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        getPrefixes(): Internal.Collection<Internal.MutableComponent>
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getVampAtts(): Internal.VampirismPlayerAttributes
        getClassification(arg0: boolean): Internal.MobCategory
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zjf000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable<any>): void
        handler$bbj000$getExitPortal(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: boolean, arg3: Internal.WorldBorder, arg4: Internal.CallbackInfoReturnable<any>): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        getStagesRawKJS(): Internal.Stages
        handler$bbk000$changeDimensionTail(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter, arg2: Internal.CallbackInfoReturnable<any>): void
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        getStages(): Internal.Stages
        handler$bbk000$changeDimensionHead(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter, arg2: Internal.CallbackInfoReturnable<any>): void
        hashCode(): number
        getLastPos(): BlockPos
        refreshTabListName(): void
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        darkutils$setSleepTimer(arg0: number): void
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getLanguage(): string
        onRemovedFromWorld(): void
        darkutils$setEnchantmentSeed(arg0: number): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        redirect$zcm001$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        refreshDisplayName(): void
        getForcedPose(): Internal.Pose
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get language(): string;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get lastPos(): BlockPos;
        get vampAtts(): Internal.VampirismPlayerAttributes;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        set dynamicLightEnabled(arg0: boolean);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StonecuttingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RegistryAccess {
    }
    interface ContainerEventHandler extends Internal.GuiEventListener {
    }
    interface WindowStateListener extends Internal.EventListener {
        windowStateChanged(arg0: Internal.WindowEvent): void
    }
    class ParticleEngine implements Internal.PreparableReloadListener, Internal.ParticleManagerAccess, Internal.ParticleEngineAccessor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        create$getProviders(): Internal.Map<any, any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        addBlockHitEffects(arg0: BlockPos, arg1: Internal.BlockHitResult): void
        toString(): string
        invokeMakeParticle(arg0: Internal.ParticleOptions, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle
        render(arg0: Internal.PoseStack, arg1: Internal.MultiBufferSource$BufferSource, arg2: Internal.LightTexture, arg3: Internal.Camera, arg4: number, arg5: Internal.Frustum): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SimplePreparableReloadListener <T> implements Internal.PreparableReloadListener {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P14 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AccessibleState extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toDisplayString(arg0: Internal.Locale): string
        toDisplayString(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly ACTIVE : Internal.AccessibleState;
        static readonly MANAGES_DESCENDANTS : Internal.AccessibleState;
        static readonly EDITABLE : Internal.AccessibleState;
        static readonly FOCUSED : Internal.AccessibleState;
        static readonly CHECKED : Internal.AccessibleState;
        static readonly VISIBLE : Internal.AccessibleState;
        static readonly PRESSED : Internal.AccessibleState;
        static readonly SINGLE_LINE : Internal.AccessibleState;
        static readonly VERTICAL : Internal.AccessibleState;
        static readonly COLLAPSED : Internal.AccessibleState;
        static readonly INDETERMINATE : Internal.AccessibleState;
        static readonly ARMED : Internal.AccessibleState;
        static readonly SHOWING : Internal.AccessibleState;
        static readonly FOCUSABLE : Internal.AccessibleState;
        static readonly BUSY : Internal.AccessibleState;
        static readonly EXPANDED : Internal.AccessibleState;
        static readonly MULTISELECTABLE : Internal.AccessibleState;
        static readonly ICONIFIED : Internal.AccessibleState;
        static readonly RESIZABLE : Internal.AccessibleState;
        static readonly SELECTABLE : Internal.AccessibleState;
        static readonly EXPANDABLE : Internal.AccessibleState;
        static readonly MODAL : Internal.AccessibleState;
        static readonly SELECTED : Internal.AccessibleState;
        static readonly TRUNCATED : Internal.AccessibleState;
        static readonly OPAQUE : Internal.AccessibleState;
        static readonly ENABLED : Internal.AccessibleState;
        static readonly HORIZONTAL : Internal.AccessibleState;
        static readonly TRANSIENT : Internal.AccessibleState;
        static readonly MULTI_LINE : Internal.AccessibleState;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PlayerKJS {
        setStagesKJS(arg0: Internal.Stages): void
        getStagesRawKJS(): Internal.Stages
        getStagesKJS(): Internal.Stages
    }
    class ConfigGroup {
        getClass(): Internal.Class<any>
        addEnum<E>(id: string, value: E, setter: (arg0: E) => void, nameMap: Internal.NameMap<E>): Internal.EnumConfig<E>
        addEnum<E>(id: string, value: E, setter: (arg0: E) => void, nameMap: Internal.NameMap<E>, def: E): Internal.EnumConfig<E>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.Component
        notifyAll(): void
        save(accepted: boolean): void
        notify(): void
        getTooltip(): Internal.Component
        hashCode(): number
        getPath(): string
        addList<E, CV>(id: string, c: Internal.List<E>, type: CV, def: E): Internal.ListConfig<E, CV>
        getGroups(): Internal.Collection<Internal.ConfigGroup>
        addString(id: string, value: string, setter: (arg0: string) => void, def: string, pattern: Internal.Pattern): Internal.StringConfig
        addString(id: string, value: string, setter: (arg0: string) => void, def: string): Internal.StringConfig
        add<T, CV>(id: string, type: CV, value: T, callback: (arg0: T) => void, defaultValue: T): CV
        getValues(): Internal.Collection<Internal.ConfigValue>
        addBool(id: string, value: boolean, setter: (arg0: boolean) => void, def: boolean): Internal.BooleanConfig
        addItemStack(id: string, value: Internal.ItemStack, setter: (arg0: Internal.ItemStack) => void, def: Internal.ItemStack, singleItemOnly: boolean, allowEmpty: boolean): Internal.ItemStackConfig
        getNameKey(): string
        addTristate(id: string, value: Internal.Tristate, setter: (arg0: Internal.Tristate) => void, def: Internal.Tristate): Internal.EnumConfig<Internal.Tristate>
        addTristate(id: string, value: Internal.Tristate, setter: (arg0: Internal.Tristate) => void): Internal.EnumConfig<Internal.Tristate>
        setNameKey(key: string): Internal.ConfigGroup
        equals(arg0: any): boolean
        getGroup(id: string): Internal.ConfigGroup
        toString(): string
        addLong(id: string, value: number, setter: (arg0: number) => void, def: number, min: number, max: number): Internal.LongConfig
        addInt(id: string, value: number, setter: (arg0: number) => void, def: number, min: number, max: number): Internal.IntConfig
        addDouble(id: string, value: number, setter: (arg0: number) => void, def: number, min: number, max: number): Internal.DoubleConfig
        parent : Internal.ConfigGroup;
        readonly id : string;
        savedCallback : Internal.ConfigCallback;
        get path(): string;
        get nameKey(): string;
        get values(): Internal.Collection<Internal.ConfigValue>;
        get name(): Internal.Component;
        get tooltip(): Internal.Component;
        get groups(): Internal.Collection<Internal.ConfigGroup>;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MapCodec <A> extends Internal.CompressorHolder implements Internal.MapDecoder<A>, Internal.MapEncoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setPartial(arg0: () => A): Internal.MapCodec<A>
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        notifyAll(): void
        deprecated(arg0: number): Internal.MapCodec<A>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<A>
        notify(): void
        hashCode(): number
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.MapCodec<S_>
        comap<B_>(arg0: (arg0: B_) => A): Internal.MapEncoder<B_>
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>, arg2: () => string): Internal.MapCodec<A_>
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>): Internal.MapCodec<A_>
        fieldOf(arg0: string): Internal.MapCodec<A>
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.MapCodec<S_>
        map<B_>(arg0: (arg0: A) => B_): Internal.MapDecoder<B_>
        dependent<E_>(arg0: Internal.MapCodec<E_>, arg1: (arg0: A) => com.mojang.datafixers.util.Pair<E_, Internal.MapCodec<E_>>, arg2: (arg0: A, arg1: E_) => A): Internal.MapCodec<A>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.MapEncoder<B_>
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>
        decoder(): Internal.Decoder<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapCodec<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<any>
        encoder(): Internal.Encoder<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.MapCodec<A>
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.MapCodec<A>
        orElse(arg0: A): Internal.MapCodec<A>
        forGetter<O_>(arg0: (arg0: O_) => A): Internal.RecordCodecBuilder<O_, A>
        ap<E_>(arg0: Internal.MapDecoder<(arg0: A) => E_>): Internal.MapDecoder<E_>
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.MapDecoder<B_>
        codec(): Internal.Codec<A>
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>
        static unit<A_>(arg0: () => A_): Internal.MapCodec<A_>
        orElseGet(arg0: () => A): Internal.MapCodec<A>
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.MapCodec<A>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.MapCodec<A>
        stable(): Internal.MapCodec<A>
        equals(arg0: any): boolean
        mapResult(arg0: Internal.MapCodec$ResultFunction<A>): Internal.MapCodec<A>
        toString(): string
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
        get class(): Internal.Class<any>;
        set partial(arg0: () => A);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeRegistryEntry <V> {
        getRegistryType(): Internal.Class<V>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): V
    }
    interface LongToDoubleFunction {
        applyAsDouble(arg0: number): number
    }
    interface MinecraftServerAccessor {
        getResources(): Internal.ServerResources
    }
    class LevelSettings {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface UnaryOperator <T> extends java_.util.function_.Function<T, T> {
        compose<V_>(arg0: (arg0: V_) => T): (arg0: V_) => T
        apply(arg0: T): T
        andThen<V_>(arg0: (arg0: T) => V_): (arg0: T) => V_
    }
    class RenderContext implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        preConcetenateTransform(arg0: Internal.AffineTransform): void
        getAreaOfInterest(): Internal.Shape
        concetenateTransform(arg0: Internal.AffineTransform): void
        setAreaOfInterest(arg0: Internal.Shape): void
        notifyAll(): void
        getRenderingHints(): Internal.RenderingHints
        notify(): void
        setTransform(arg0: Internal.AffineTransform): void
        hashCode(): number
        equals(arg0: any): boolean
        setRenderingHints(arg0: Internal.RenderingHints): void
        preConcatenateTransform(arg0: Internal.AffineTransform): void
        clone(): any
        concatenateTransform(arg0: Internal.AffineTransform): void
        toString(): string
        getTransform(): Internal.AffineTransform
        get transform(): Internal.AffineTransform;
        get areaOfInterest(): Internal.Shape;
        get renderingHints(): Internal.RenderingHints;
        get class(): Internal.Class<any>;
        set transform(arg0: Internal.AffineTransform);
        set areaOfInterest(arg0: Internal.Shape);
        set renderingHints(arg0: Internal.RenderingHints);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchKey {
        cancel(): void
        pollEvents(): Internal.List<Internal.WatchEvent<any>>
        watchable(): Internal.Watchable
        isValid(): boolean
        reset(): boolean
    }
    interface ObjectSpliterator <K> extends Internal.Spliterator<K> {
        trySplit(): Internal.ObjectSpliterator<K>
        trySplit(): Internal.Spliterator<any>
        tryAdvance(arg0: (arg0: K) => void): boolean
        characteristics(): number
        getComparator(): Internal.Comparator<K>
        getExactSizeIfKnown(): number
        estimateSize(): number
        skip(arg0: number): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: K) => void): void
    }
    class BiomeDictionary$Type {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        static getAll(): Internal.Collection<Internal.BiomeDictionary$Type>
        static getType(arg0: string, arg1: Internal.BiomeDictionary$Type[]): Internal.BiomeDictionary$Type
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static fromVanilla(arg0: Internal.Biome$BiomeCategory): Internal.BiomeDictionary$Type
        notify(): void
        static hasType(arg0: string): boolean
        static readonly SNOWY : Internal.BiomeDictionary$Type;
        static readonly BEACH : Internal.BiomeDictionary$Type;
        static readonly UNDERGROUND : Internal.BiomeDictionary$Type;
        static readonly SAVANNA : Internal.BiomeDictionary$Type;
        static readonly MESA : Internal.BiomeDictionary$Type;
        static readonly RARE : Internal.BiomeDictionary$Type;
        static readonly SPOOKY : Internal.BiomeDictionary$Type;
        static readonly WET : Internal.BiomeDictionary$Type;
        static readonly SPARSE : Internal.BiomeDictionary$Type;
        static readonly MOUNTAIN : Internal.BiomeDictionary$Type;
        static readonly DRY : Internal.BiomeDictionary$Type;
        static readonly RIVER : Internal.BiomeDictionary$Type;
        static readonly MAGICAL : Internal.BiomeDictionary$Type;
        static readonly NETHER : Internal.BiomeDictionary$Type;
        static readonly WATER : Internal.BiomeDictionary$Type;
        static readonly DENSE : Internal.BiomeDictionary$Type;
        static readonly JUNGLE : Internal.BiomeDictionary$Type;
        static readonly SANDY : Internal.BiomeDictionary$Type;
        static readonly OCEAN : Internal.BiomeDictionary$Type;
        static readonly HILLS : Internal.BiomeDictionary$Type;
        static readonly HOT : Internal.BiomeDictionary$Type;
        static readonly FOREST : Internal.BiomeDictionary$Type;
        static readonly MUSHROOM : Internal.BiomeDictionary$Type;
        static readonly OVERWORLD : Internal.BiomeDictionary$Type;
        static readonly PLATEAU : Internal.BiomeDictionary$Type;
        static readonly PLAINS : Internal.BiomeDictionary$Type;
        static readonly SWAMP : Internal.BiomeDictionary$Type;
        static readonly PEAK : Internal.BiomeDictionary$Type;
        static readonly END : Internal.BiomeDictionary$Type;
        static readonly COLD : Internal.BiomeDictionary$Type;
        static readonly DEAD : Internal.BiomeDictionary$Type;
        static readonly MODIFIED : Internal.BiomeDictionary$Type;
        static readonly VOID : Internal.BiomeDictionary$Type;
        static readonly LUSH : Internal.BiomeDictionary$Type;
        static readonly CONIFEROUS : Internal.BiomeDictionary$Type;
        static readonly SLOPE : Internal.BiomeDictionary$Type;
        static readonly WASTELAND : Internal.BiomeDictionary$Type;
        get all(): Internal.Collection<Internal.BiomeDictionary$Type>;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ShortBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ShortBuffer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.ShortBuffer
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ShortBuffer): number
        notify(): void
        asReadOnlyBuffer(): Internal.ShortBuffer
        put(arg0: number[]): Internal.ShortBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer
        put(arg0: number, arg1: number[]): Internal.ShortBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        put(arg0: number, arg1: Internal.ShortBuffer, arg2: number, arg3: number): Internal.ShortBuffer
        put(arg0: Internal.ShortBuffer): Internal.ShortBuffer
        put(arg0: number, arg1: number): Internal.ShortBuffer
        put(arg0: number): Internal.ShortBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.Buffer
        slice(): Internal.ShortBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.ShortBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(): number
        get(arg0: number, arg1: number[]): Internal.ShortBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        get(arg0: number[]): Internal.ShortBuffer
        limit(arg0: number): Internal.ShortBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.Buffer
        flip(): Internal.ShortBuffer
        order(): Internal.ByteOrder
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.ShortBuffer
        duplicate(): Internal.ShortBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        static allocate(arg0: number): Internal.ShortBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.ShortBuffer
        mismatch(arg0: Internal.ShortBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.Buffer
        reset(): Internal.ShortBuffer
        toString(): string
        position(arg0: number): Internal.ShortBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.ShortBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        mark(): Internal.Buffer
        mark(): Internal.ShortBuffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ItemInventory implements Internal.Container {
        getClass(): Internal.Class<any>
        getItems(): Internal.List<Internal.ItemStack>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        save(): void
        toString(): string
        notify(): void
        readonly filter : Internal.ItemStack;
        readonly filterItem : Internal.InventoryFilterItem;
        get class(): Internal.Class<any>;
        get items(): Internal.List<Internal.ItemStack>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class InputEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isControlDown(): boolean
        notifyAll(): void
        isMetaDown(): boolean
        getID(): number
        consume(): void
        getModifiersEx(): number
        notify(): void
        isShiftDown(): boolean
        paramString(): string
        isConsumed(): boolean
        static getModifiersExText(arg0: number): string
        hashCode(): number
        getSource(): any
        isAltGraphDown(): boolean
        equals(arg0: any): boolean
        static getMaskForButton(arg0: number): number
        getWhen(): number
        toString(): string
        getComponent(): java_.awt.Component
        getModifiers(): number
        isAltDown(): boolean
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly BUTTON1_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly BUTTON3_MASK : 4;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly COMPONENT_RESIZED : 101;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get altGraphDown(): boolean;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get metaDown(): boolean;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class TeamProperty <T> {
        getClass(): Internal.Class<any>
        readValue(buf: Internal.FriendlyByteBuf): T
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        fromNBT(tag: Internal.Tag): Internal.Optional<T>
        notifyAll(): void
        notify(): void
        toNBT(value: T): Internal.Tag
        getType(): Internal.TeamPropertyType<T>
        hashCode(): number
        equals(o: any): boolean
        toString(): string
        toString(value: T): string
        fromString(arg0: string): Internal.Optional<T>
        writeValue(buf: Internal.FriendlyByteBuf, value: T): void
        write(arg0: Internal.FriendlyByteBuf): void
        config(config: Internal.ConfigGroup, value: Internal.TeamPropertyValue<T>): void
        readonly defaultValue : T;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LongConfig extends Internal.NumberConfig<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<number>
        notifyAll(): void
        isEqual(v1: number, v2: number): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<number>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(v: number): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(arg0: any): Internal.Component
        getStringForGUI(v: number): Internal.Component
        getPath(): string
        copy(value: number): number
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: number, c: (arg0: number) => void, def: number): Internal.ConfigValue<number>
        getColor(arg0: any): Internal.Color4I
        getColor(v: number): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(callback: (arg0: number) => void, string: string): boolean
        getIcon(v: number): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<number>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<number>
        setNameKey(key: string): Internal.ConfigValue<number>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: number): boolean
        fader(v: boolean): Internal.NumberConfig<number>
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: number) => void;
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NameMap$Builder <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        color(p: (arg0: T) => Internal.Color4I): Internal.NameMap$Builder<T>
        notifyAll(): void
        icon(p: (arg0: T) => Internal.Icon): Internal.NameMap$Builder<T>
        notify(): void
        baseNameKey(key: string): Internal.NameMap$Builder<T>
        hashCode(): number
        nameKey(p: (arg0: T) => string): Internal.NameMap$Builder<T>
        equals(arg0: any): boolean
        name(p: (arg0: T) => Internal.Component): Internal.NameMap$Builder<T>
        create(): Internal.NameMap<T>
        toString(): string
        id(p: (arg0: T) => string): Internal.NameMap$Builder<T>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LineMetrics {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getUnderlineThickness(): number
        getBaselineOffsets(): number[]
        notifyAll(): void
        notify(): void
        getAscent(): number
        getBaselineIndex(): number
        getStrikethroughOffset(): number
        getHeight(): number
        hashCode(): number
        equals(arg0: any): boolean
        getStrikethroughThickness(): number
        getNumChars(): number
        toString(): string
        getUnderlineOffset(): number
        getDescent(): number
        getLeading(): number
        get strikethroughThickness(): number;
        get descent(): number;
        get ascent(): number;
        get leading(): number;
        get underlineThickness(): number;
        get strikethroughOffset(): number;
        get baselineOffsets(): number[];
        get baselineIndex(): number;
        get numChars(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        get underlineOffset(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ZonedDateTime implements Internal.Temporal, Internal.ChronoZonedDateTime<Internal.LocalDate>, Internal.Serializable {
        getClass(): Internal.Class<any>
        plusHours(arg0: number): Internal.ZonedDateTime
        isEqual(arg0: Internal.ChronoZonedDateTime<any>): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: Internal.ChronoZonedDateTime<any>): number
        compareTo(arg0: any): number
        static ofLocal(arg0: Internal.LocalDateTime, arg1: Internal.ZoneId, arg2: Internal.ZoneOffset): Internal.ZonedDateTime
        getDayOfWeek(): Internal.DayOfWeek
        plusSeconds(arg0: number): Internal.ZonedDateTime
        getMinute(): number
        static ofStrict(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneId): Internal.ZonedDateTime
        static from(arg0: Internal.TemporalAccessor): Internal.ZonedDateTime
        plusNanos(arg0: number): Internal.ZonedDateTime
        getMonth(): Internal.Month
        withHour(arg0: number): Internal.ZonedDateTime
        plusMonths(arg0: number): Internal.ZonedDateTime
        plusYears(arg0: number): Internal.ZonedDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.ZonedDateTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.ZonedDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        getZone(): Internal.ZoneId
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ZonedDateTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<any>
        plus(arg0: Internal.TemporalAmount): Internal.ZonedDateTime
        plus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<any>
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        getYear(): number
        toEpochSecond(): number
        toLocalDateTime(): Internal.LocalDateTime
        toLocalDateTime(): Internal.ChronoLocalDateTime<any>
        withDayOfMonth(arg0: number): Internal.ZonedDateTime
        isAfter(arg0: Internal.ChronoZonedDateTime<any>): boolean
        withMonth(arg0: number): Internal.ZonedDateTime
        toOffsetDateTime(): Internal.OffsetDateTime
        static ofInstant(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneId): Internal.ZonedDateTime
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ZonedDateTime
        minus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<any>
        minus(arg0: Internal.TemporalAmount): Internal.ZonedDateTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ZonedDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        minusHours(arg0: number): Internal.ZonedDateTime
        withFixedOffsetZone(): Internal.ZonedDateTime
        notifyAll(): void
        getOffset(): Internal.ZoneOffset
        range(arg0: Internal.TemporalField): Internal.ValueRange
        plusMinutes(arg0: number): Internal.ZonedDateTime
        withYear(arg0: number): Internal.ZonedDateTime
        notify(): void
        plusDays(arg0: number): Internal.ZonedDateTime
        minusMinutes(arg0: number): Internal.ZonedDateTime
        withLaterOffsetAtOverlap(): Internal.ChronoZonedDateTime<any>
        withLaterOffsetAtOverlap(): Internal.ZonedDateTime
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.ZonedDateTime
        static now(arg0: Internal.ZoneId): Internal.ZonedDateTime
        static now(): Internal.ZonedDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneId): Internal.ZonedDateTime
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneId): Internal.ZonedDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime, arg2: Internal.ZoneId): Internal.ZonedDateTime
        get(arg0: Internal.TemporalField): number
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ZonedDateTime
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<any>
        withEarlierOffsetAtOverlap(): Internal.ZonedDateTime
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.ZonedDateTime
        getHour(): number
        getChronology(): Internal.Chronology
        withMinute(arg0: number): Internal.ZonedDateTime
        getMonthValue(): number
        minusYears(arg0: number): Internal.ZonedDateTime
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ZonedDateTime
        minusWeeks(arg0: number): Internal.ZonedDateTime
        withDayOfYear(arg0: number): Internal.ZonedDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.ZonedDateTime
        static parse(arg0: Internal.CharSequence): Internal.ZonedDateTime
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.ChronoZonedDateTime<any>): boolean
        minusDays(arg0: number): Internal.ZonedDateTime
        withNano(arg0: number): Internal.ZonedDateTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.ZonedDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoZonedDateTime<any>
        with(arg0: Internal.TemporalAdjuster): Internal.ZonedDateTime
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoZonedDateTime<any>
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        minusMonths(arg0: number): Internal.ZonedDateTime
        toLocalDate(): Internal.LocalDate
        toLocalDate(): Internal.ChronoLocalDate
        equals(arg0: any): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.ZonedDateTime
        withSecond(arg0: number): Internal.ZonedDateTime
        get offset(): Internal.ZoneOffset;
        get year(): number;
        get dayOfYear(): number;
        get nano(): number;
        get chronology(): Internal.Chronology;
        get minute(): number;
        get second(): number;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get hour(): number;
        get zone(): Internal.ZoneId;
        get dayOfMonth(): number;
        get monthValue(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeBlock {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean
        getTags(): Internal.Set<ResourceLocation>
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>
        isStickyBlock(arg0: Internal.BlockState): boolean
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes
        isSlimeBlock(arg0: Internal.BlockState): boolean
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[]
    }
    class LocalTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.LocalTime>, Internal.Serializable {
        getClass(): Internal.Class<any>
        plusHours(arg0: number): Internal.LocalTime
        atDate(arg0: Internal.LocalDate): Internal.LocalDateTime
        compareTo(arg0: Internal.LocalTime): number
        compareTo(arg0: any): number
        toSecondOfDay(): number
        plusSeconds(arg0: number): Internal.LocalTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.LocalTime
        plusNanos(arg0: number): Internal.LocalTime
        withHour(arg0: number): Internal.LocalTime
        static ofNanoOfDay(arg0: number): Internal.LocalTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.LocalTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.LocalTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.LocalTime
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        static ofSecondOfDay(arg0: number): Internal.LocalTime
        toNanoOfDay(): number
        toEpochSecond(arg0: Internal.LocalDate, arg1: Internal.ZoneOffset): number
        isAfter(arg0: Internal.LocalTime): boolean
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.LocalTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalTime
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        minusHours(arg0: number): Internal.LocalTime
        notifyAll(): void
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        plusMinutes(arg0: number): Internal.LocalTime
        notify(): void
        minusMinutes(arg0: number): Internal.LocalTime
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.LocalTime
        static now(arg0: Internal.ZoneId): Internal.LocalTime
        static now(): Internal.LocalTime
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalTime
        static of(arg0: number, arg1: number): Internal.LocalTime
        get(arg0: Internal.TemporalField): number
        getHour(): number
        withMinute(arg0: number): Internal.LocalTime
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalTime
        static parse(arg0: Internal.CharSequence): Internal.LocalTime
        isBefore(arg0: Internal.LocalTime): boolean
        withNano(arg0: number): Internal.LocalTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.LocalTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        equals(arg0: any): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.LocalTime
        withSecond(arg0: number): Internal.LocalTime
        static readonly MIN : Internal.LocalTime;
        static readonly NOON : Internal.LocalTime;
        static readonly MAX : Internal.LocalTime;
        static readonly MIDNIGHT : Internal.LocalTime;
        get hour(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BooleanProperty extends Internal.TeamProperty<any> {
        getClass(): Internal.Class<any>
        readValue(buf: Internal.FriendlyByteBuf): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        fromNBT(tag: Internal.Tag): Internal.Optional<boolean>
        notifyAll(): void
        notify(): void
        toNBT(arg0: any): Internal.Tag
        toNBT(value: boolean): Internal.Tag
        getType(): Internal.TeamPropertyType<boolean>
        hashCode(): number
        equals(o: any): boolean
        toString(): string
        toString(value: boolean): string
        fromString(string: string): Internal.Optional<boolean>
        writeValue(buf: Internal.FriendlyByteBuf, value: boolean): void
        write(buf: Internal.FriendlyByteBuf): void
        config(config: Internal.ConfigGroup, value: Internal.TeamPropertyValue<boolean>): void
        readonly defaultValue : boolean;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<boolean>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WorldGenSettings {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CustomTranslationTextComponent extends Internal.TranslatableComponent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getString(): string
        notify(): void
        static readonly CODEC : Internal.Codec<Internal.CustomTranslationTextComponent>;
        static readonly DEFAULT : Internal.CustomTranslationTextComponent;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecipeTypeJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        hashCode(): number
        notifyAll(): void
        equals(obj: any): boolean
        isCustom(): boolean
        getId(): string
        toString(): string
        getIdRL(): ResourceLocation
        notify(): void
        readonly factory : () => Internal.RecipeJS;
        readonly serializer : Internal.RecipeSerializer<any>;
        get mod(): string;
        get idRL(): ResourceLocation;
        get custom(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICustomPacket <T> {
        setName(arg0: ResourceLocation): void
        getThis(): T
        getName(): ResourceLocation
        getIndex(): number
        getDirection(): Internal.NetworkDirection
        setData(arg0: Internal.FriendlyByteBuf): void
        setIndex(arg0: number): void
        getInternalData(): Internal.FriendlyByteBuf
    }
    abstract class AsynchronousFileChannel implements Internal.AsynchronousChannel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        read<A_>(arg0: Internal.ByteBuffer, arg1: number, arg2: A_, arg3: Internal.CompletionHandler<number, A_>): void
        read(arg0: Internal.ByteBuffer, arg1: number): java_.util.concurrent.Future<number>
        notifyAll(): void
        notify(): void
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        tryLock(): Internal.FileLock
        isOpen(): boolean
        truncate(arg0: number): Internal.AsynchronousFileChannel
        size(): number
        hashCode(): number
        equals(arg0: any): boolean
        lock<A_>(arg0: A_, arg1: Internal.CompletionHandler<Internal.FileLock, A_>): void
        lock<A_>(arg0: number, arg1: number, arg2: boolean, arg3: A_, arg4: Internal.CompletionHandler<Internal.FileLock, A_>): void
        lock(): java_.util.concurrent.Future<Internal.FileLock>
        lock(arg0: number, arg1: number, arg2: boolean): java_.util.concurrent.Future<Internal.FileLock>
        toString(): string
        force(arg0: boolean): void
        close(): void
        write(arg0: Internal.ByteBuffer, arg1: number): java_.util.concurrent.Future<number>
        write<A_>(arg0: Internal.ByteBuffer, arg1: number, arg2: A_, arg3: Internal.CompletionHandler<number, A_>): void
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: any[]): Internal.AsynchronousFileChannel
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.AsynchronousFileChannel
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PartyTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer, message: string): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        listAllies(source: Internal.CommandSourceStack): number
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getOwner(): Internal.UUID
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        notify(): void
        getColoredName(): Internal.Component
        serializeNBT(): Internal.SNBTCompoundTag
        isOwner(profile: Internal.UUID): boolean
        hashCode(): number
        leave(player: Internal.ServerPlayer): number
        join(source: Internal.CommandSourceStack): number
        info(source: Internal.CommandSourceStack): number
        settings(source: Internal.CommandSourceStack, key: Internal.TeamProperty<any>, value: string): number
        isAlly(profile: Internal.UUID): boolean
        getProperty<T_>(property: Internal.TeamProperty<T_>): T_
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        sendMessage(from: Internal.UUID, text: Internal.Component): void
        deserializeNBT(tag: Internal.CompoundTag): void
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        getOnlineRanked(rank: Internal.TeamRank): Internal.List<Internal.ServerPlayer>
        removeAlly(source: Internal.CommandSourceStack, players: Internal.Collection<Internal.GameProfile>): number
        denyInvite(source: Internal.CommandSourceStack): number
        isFreeToJoin(): boolean
        kick(from: Internal.ServerPlayer, players: Internal.Collection<Internal.GameProfile>): number
        getDisplayName(): string
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>
        getType(): Internal.TeamType
        getOwnerPlayer(): Internal.ServerPlayer
        setProperty<T_>(property: Internal.TeamProperty<T_>, value: T_): void
        equals(o: any): boolean
        addAlly(source: Internal.CommandSourceStack, players: Internal.Collection<Internal.GameProfile>): number
        transferOwnership(from: Internal.ServerPlayer, to: Internal.ServerPlayer): number
        toString(): string
        invite(from: Internal.ServerPlayer, players: Internal.Collection<Internal.GameProfile>): number
        getMembers(): Internal.Set<Internal.UUID>
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get ownerPlayer(): Internal.ServerPlayer;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BooleanConsumer {
        accept(arg0: boolean): void
    }
    abstract class PlayerDataJS <E, P> implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): P
        getName(): string
        notifyAll(): void
        getProfile(): Internal.GameProfile
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        notify(): void
        getMinecraftPlayer(): E
        hashCode(): number
        equals(arg0: any): boolean
        hasClientMod(): boolean
        toString(): string
        getData(): Internal.AttachedData
        get data(): Internal.AttachedData;
        get minecraftPlayer(): E;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): P;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Delayed extends Internal.Comparable<Internal.Delayed> {
        getDelay(arg0: Internal.TimeUnit): number
        compareTo(arg0: Internal.Delayed): number
    }
    class Thread$State extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Thread$State
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Thread$State[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Thread$State): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Thread$State>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Thread$State>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly NEW : Internal.Thread$State;
        static readonly TERMINATED : Internal.Thread$State;
        static readonly RUNNABLE : Internal.Thread$State;
        static readonly BLOCKED : Internal.Thread$State;
        static readonly WAITING : Internal.Thread$State;
        static readonly TIMED_WAITING : Internal.Thread$State;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Thread$State>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientWrapper {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.ClientPlayerJS
        notifyAll(): void
        setTitle(t: string): void
        getCurrentScreen(): Internal.Screen
        getMinecraft(): Internal.Minecraft
        notify(): void
        getLevel(): Internal.ClientLevelJS
        hashCode(): number
        equals(arg0: any): boolean
        isKeyDown(key: number): boolean
        getCurrentWorldName(): string
        toString(): string
        setCurrentScreen(gui: Internal.Screen): void
        get minecraft(): Internal.Minecraft;
        get currentScreen(): Internal.Screen;
        get level(): Internal.ClientLevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ClientPlayerJS;
        get currentWorldName(): string;
        set currentScreen(gui: Internal.Screen);
        set title(t: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClocheRenderFunction$ClocheRenderReference {
        getClass(): Internal.Class<any>
        serialize(): Internal.JsonObject
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getBlock(): Internal.Block
        static read(arg0: Internal.FriendlyByteBuf): Internal.ClocheRenderFunction$ClocheRenderReference
        getType(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        write(arg0: Internal.FriendlyByteBuf): void
        notify(): void
        static deserialize(arg0: Internal.JsonObject): Internal.ClocheRenderFunction$ClocheRenderReference
        get block(): Internal.Block;
        get type(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PlayerAccess {
        botania$setCritTarget(arg0: Internal.LivingEntity): void
    }
    class ResolvedModule {
        reference(): Internal.ModuleReference
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        configuration(): Internal.Configuration
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        reads(): Internal.Set<Internal.ResolvedModule>
        name(): string
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MenuComponent implements Internal.Serializable {
        setName(arg0: string): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getParent(): Internal.MenuContainer
        getName(): string
        dispatchEvent(arg0: Internal.AWTEvent): void
        notifyAll(): void
        getAccessibleContext(): Internal.AccessibleContext
        notify(): void
        postEvent(arg0: Internal.Event): boolean
        hashCode(): number
        equals(arg0: any): boolean
        removeNotify(): void
        toString(): string
        getFont(): java_.awt.Font
        setFont(arg0: java_.awt.Font): void
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get name(): string;
        get class(): Internal.Class<any>;
        get font(): java_.awt.Font;
        set name(arg0: string);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LunarEvent {
        getClass(): Internal.Class<any>
        onBlockTick(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getChance(): number
        notifyAll(): void
        getTextComponents(): Internal.LunarTextComponents
        notify(): void
        setClientSettings(arg0: Internal.LunarEventClientSettings): void
        setLunarEventClient(arg0: Internal.LunarEventClient<any>, arg1: string): Internal.LunarEventClient<any>
        hashCode(): number
        getValidMoonPhases(): Internal.Set<number>
        blockSleeping(): boolean
        startNotification(): Internal.LunarTextComponents$Notification
        setKey(arg0: string): Internal.LunarEvent
        getKey(): string
        onBlockItemDrop(arg0: Internal.ServerLevel, arg1: Internal.ItemStack): void
        getClient(): Internal.LunarEventClient<any>
        getClientSettings(): Internal.LunarEventClientSettings
        getSpawnMultiplierForMonsterCategory(arg0: Internal.MobCategory): number
        livingEntityTick(arg0: Internal.LivingEntity, arg1: net.minecraft.world.level.Level): void
        codec(): Internal.Codec<Internal.LunarEvent>
        getMinNumberOfNightsBetween(): number
        equals(arg0: any): boolean
        getLunarSpawner(): Internal.LunarMobSpawnInfo
        endNotification(): Internal.LunarTextComponents$Notification
        toString(): string
        static readonly CODEC : Internal.Codec<Internal.LunarEvent>;
        get chance(): number;
        get validMoonPhases(): Internal.Set<number>;
        get client(): Internal.LunarEventClient<any>;
        get class(): Internal.Class<any>;
        get minNumberOfNightsBetween(): number;
        get textComponents(): Internal.LunarTextComponents;
        get key(): string;
        get lunarSpawner(): Internal.LunarMobSpawnInfo;
        get clientSettings(): Internal.LunarEventClientSettings;
        set key(arg0: string);
        set clientSettings(arg0: Internal.LunarEventClientSettings);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        shouldRiderSit(): boolean
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        onRemovedFromWorld(): void
        isMultipartEntity(): boolean
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        getPersistentData(): Internal.CompoundTag
        canRiderInteract(): boolean
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        revive(): void
        isAddedToWorld(): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        getParts(): any[]
    }
    interface IOpenableScreen extends Internal.Runnable {
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        openContextMenu(panel: Internal.Panel): void
        openGui(): void
        openGuiLater(): void
        run(): void
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
    }
    class HideJEIEventJS <T> extends Internal.EventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        notifyAll(): void
        getAllIngredients(): Internal.Collection<T>
        notify(): void
        hide(o: any): void
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        hideAll(): void
        canCancel(): boolean
        get allIngredients(): Internal.Collection<T>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchEvent <T> {
        kind(): Internal.WatchEvent$Kind<T>
        count(): number
        context(): T
    }
    class ItemStackConfig extends Internal.ConfigValue<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ItemStack>
        notifyAll(): void
        isEqual(v1: Internal.ItemStack, v2: Internal.ItemStack): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.ItemStack>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        hashCode(): number
        getStringForGUI(v: Internal.ItemStack): Internal.Component
        getStringForGUI(arg0: any): Internal.Component
        getPath(): string
        copy(value: Internal.ItemStack): Internal.ItemStack
        copy(arg0: any): any
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.ItemStack, c: (arg0: Internal.ItemStack) => void, def: Internal.ItemStack): Internal.ConfigValue<Internal.ItemStack>
        getColor(v: Internal.ItemStack): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        getIcon(v: Internal.ItemStack): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.ItemStack>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.ItemStack>
        setNameKey(key: string): Internal.ConfigValue<Internal.ItemStack>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.ItemStack): boolean
        readonly allowEmpty : boolean;
        defaultValue : Internal.ItemStack;
        id : string;
        readonly singleItemOnly : boolean;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.ItemStack) => void;
        value : Internal.ItemStack;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.ItemStack);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    class RecipeEventJS extends Internal.EventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        forEachRecipe(filter: (arg0: any) => boolean, consumer: (arg0: Internal.RecipeJS) => void): void
        countRecipes(filter: (arg0: any) => boolean): number
        notify(): void
        remove(filter: (arg0: any) => boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: string): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: object): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: string): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: object): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.ItemStackJS): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: string): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: object): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.ItemStackJS): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: string): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: object): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS): number
        replaceOutput(ingredient: Internal.IngredientJS, with_: string): number
        replaceOutput(ingredient: Internal.IngredientJS, with_: object): number
        replaceOutput(ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        replaceOutput(ingredient: string, with_: string): number
        replaceOutput(ingredient: string, with_: object): number
        replaceOutput(ingredient: string, with_: Internal.ItemStackJS): number
        replaceOutput(ingredient: object, with_: string): number
        replaceOutput(ingredient: object, with_: object): number
        replaceOutput(ingredient: object, with_: Internal.ItemStackJS): number
        replaceOutput(ingredient: Internal.ItemStackJS, with_: string): number
        replaceOutput(ingredient: Internal.ItemStackJS, with_: object): number
        replaceOutput(ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: string, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: object, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: string, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: object, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.ItemStackJS, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: string, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: object, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.ItemStackJS, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: string, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: object, exact: boolean): number
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): number
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        printAllTypes(): void
        customFilter(filter: (arg0: any) => boolean): (arg0: any) => boolean
        isCancelled(): boolean
        printTypes(): void
        getRecipeFunction(id: string): Internal.RecipeFunction
        localvar$zpa000$modify_HammerLib(arg0: Internal.HashMap<any, any>): Internal.HashMap<any, any>
        custom(o: any): Internal.RecipeJS
        forEachRecipeAsync(filter: (arg0: any) => boolean, consumer: (arg0: Internal.RecipeJS) => void): void
        printExamples(type: string): void
        addRecipe(r: Internal.RecipeJS, type: Internal.RecipeTypeJS, args1: Internal.ListJS): Internal.RecipeJS
        stage(filter: (arg0: any) => boolean, stage: string): void
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: string, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: object, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: string, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: object, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.ItemStackJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.IngredientJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: string, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: object, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.ItemStackJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.IngredientJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: string, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: object, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): number
        replaceInput(ingredient: Internal.IngredientJS, with_: string): number
        replaceInput(ingredient: Internal.IngredientJS, with_: object): number
        replaceInput(ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        replaceInput(ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number
        replaceInput(ingredient: string, with_: string): number
        replaceInput(ingredient: string, with_: object): number
        replaceInput(ingredient: string, with_: Internal.ItemStackJS): number
        replaceInput(ingredient: string, with_: Internal.IngredientJS): number
        replaceInput(ingredient: object, with_: string): number
        replaceInput(ingredient: object, with_: object): number
        replaceInput(ingredient: object, with_: Internal.ItemStackJS): number
        replaceInput(ingredient: object, with_: Internal.IngredientJS): number
        replaceInput(ingredient: Internal.ItemStackJS, with_: string): number
        replaceInput(ingredient: Internal.ItemStackJS, with_: object): number
        replaceInput(ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS): number
        replaceInput(ingredient: Internal.ItemStackJS, with_: Internal.IngredientJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: string): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: object): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: string): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: object): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.ItemStackJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: string, with_: Internal.IngredientJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: string): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: object): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.ItemStackJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: object, with_: Internal.IngredientJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: string): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: object): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.ItemStackJS): number
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.ItemStackJS, with_: Internal.IngredientJS): number
        equals(arg0: any): boolean
        toString(): string
        /**
        * Holds all the recipes collected from documents.
        */
        getRecipes(): Document.RecipeHolder
        canCancel(): boolean
        setItemErrors(b: boolean): void
        static instance : Internal.RecipeEventJS;
        static readonly FORGE_CONDITIONAL : "forge:conditional";
        static customIngredientMap : Internal.Map<Internal.UUID, Internal.IngredientWithCustomPredicateJS>;
        /**
        * Holds all the recipes collected from documents.
        */
        get recipes(): Document.RecipeHolder;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        set itemErrors(b: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: string, input: string): Internal.CookingRecipeJS;
        smelting(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: string, input: object): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        smelting(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: object, input: string): Internal.CookingRecipeJS;
        smelting(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: string, input: string): Internal.CookingRecipeJS;
        smoking(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: string, input: object): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        smoking(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: object, input: string): Internal.CookingRecipeJS;
        smoking(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: string, input: string): Internal.CookingRecipeJS;
        blasting(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: string, input: object): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        blasting(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: object, input: string): Internal.CookingRecipeJS;
        blasting(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        shaped(output: string, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped(output: string, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped(output: string, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped(output: string, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped(output: object, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped(output: object, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped(output: object, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped(output: object, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        shapeless(output: string, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless(output: string, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless(output: string, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless(output: string, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        shapeless(output: Internal.ItemStackJS, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless(output: Internal.ItemStackJS, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        shapeless(output: object, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless(output: object, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless(output: object, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless(output: object, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        campfireCooking(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        campfireCooking(output: string, input: string): Internal.CookingRecipeJS;
        campfireCooking(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        campfireCooking(output: string, input: object): Internal.CookingRecipeJS;
        campfireCooking(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        campfireCooking(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        campfireCooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        campfireCooking(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        campfireCooking(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        campfireCooking(output: object, input: string): Internal.CookingRecipeJS;
        campfireCooking(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        campfireCooking(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: string, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: object): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: object): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: object): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: string, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
    }
    class Pair$Mu <S> implements Internal.K1 {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntToLongFunction {
        applyAsLong(arg0: number): number
    }
    abstract class MappedByteBuffer extends Internal.ByteBuffer {
        asIntBuffer(): Internal.IntBuffer
        getClass(): Internal.Class<any>
        compact(): Internal.MappedByteBuffer
        compact(): Internal.ByteBuffer
        asLongBuffer(): Internal.LongBuffer
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuffer): number
        isLoaded(): boolean
        put(arg0: Internal.ByteBuffer): Internal.ByteBuffer
        put(arg0: number, arg1: number): Internal.ByteBuffer
        put(arg0: number, arg1: Internal.ByteBuffer, arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number): Internal.ByteBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        slice(arg0: number, arg1: number): Internal.ByteBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.MappedByteBuffer
        slice(): Internal.ByteBuffer
        slice(): Internal.MappedByteBuffer
        slice(): Internal.Buffer
        limit(arg0: number): Internal.Buffer
        limit(arg0: number): Internal.ByteBuffer
        limit(arg0: number): Internal.MappedByteBuffer
        limit(): number
        order(): Internal.ByteOrder
        order(arg0: Internal.ByteOrder): Internal.ByteBuffer
        asFloatBuffer(): Internal.FloatBuffer
        asCharBuffer(): Internal.CharBuffer
        static allocateDirect(arg0: number): Internal.ByteBuffer
        putInt(arg0: number, arg1: number): Internal.ByteBuffer
        putInt(arg0: number): Internal.ByteBuffer
        duplicate(): Internal.MappedByteBuffer
        duplicate(): Internal.Buffer
        duplicate(): Internal.ByteBuffer
        remaining(): number
        putFloat(arg0: number): Internal.ByteBuffer
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer
        getInt(): number
        getInt(arg0: number): number
        getChar(): string
        getChar(arg0: number): string
        static allocate(arg0: number): Internal.ByteBuffer
        reset(): Internal.Buffer
        reset(): Internal.MappedByteBuffer
        reset(): Internal.ByteBuffer
        force(): Internal.MappedByteBuffer
        force(arg0: number, arg1: number): Internal.MappedByteBuffer
        position(arg0: number): Internal.ByteBuffer
        position(arg0: number): Internal.MappedByteBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        asShortBuffer(): Internal.ShortBuffer
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer
        putDouble(arg0: number): Internal.ByteBuffer
        getDouble(): number
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        getFloat(): number
        putLong(arg0: number, arg1: number): Internal.ByteBuffer
        putLong(arg0: number): Internal.ByteBuffer
        notify(): void
        asReadOnlyBuffer(): Internal.ByteBuffer
        capacity(): number
        isReadOnly(): boolean
        load(): Internal.MappedByteBuffer
        asDoubleBuffer(): Internal.DoubleBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        get(arg0: number): number
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        get(): number
        get(arg0: number, arg1: number[]): Internal.ByteBuffer
        get(arg0: number[]): Internal.ByteBuffer
        arrayOffset(): number
        putShort(arg0: number): Internal.ByteBuffer
        putShort(arg0: number, arg1: number): Internal.ByteBuffer
        flip(): Internal.Buffer
        flip(): Internal.ByteBuffer
        flip(): Internal.MappedByteBuffer
        hasArray(): boolean
        getShort(arg0: number): number
        getShort(): number
        putChar(arg0: number, arg1: string): Internal.ByteBuffer
        putChar(arg0: string): Internal.ByteBuffer
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.MappedByteBuffer
        clear(): Internal.ByteBuffer
        getLong(arg0: number): number
        getLong(): number
        alignmentOffset(arg0: number, arg1: number): number
        rewind(): Internal.MappedByteBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.ByteBuffer
        mismatch(arg0: Internal.ByteBuffer): number
        equals(arg0: any): boolean
        toString(): string
        alignedSlice(arg0: number): Internal.ByteBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.ByteBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        mark(): Internal.MappedByteBuffer
        mark(): Internal.ByteBuffer
        mark(): Internal.Buffer
        get loaded(): boolean;
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TeamPropertyValue <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        copy(): Internal.TeamPropertyValue<T>
        notify(): void
        value : T;
        readonly key : Internal.TeamProperty<T>;
        consumer : (arg0: T) => void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ChannelMetadata {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasDisconnect(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        defaultMaxMessagesPerRead(): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FloatBuffer extends Internal.Buffer implements Internal.Comparable<Internal.FloatBuffer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.FloatBuffer
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.FloatBuffer): number
        notify(): void
        asReadOnlyBuffer(): Internal.FloatBuffer
        put(arg0: number[]): Internal.FloatBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer
        put(arg0: number, arg1: number[]): Internal.FloatBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        put(arg0: number, arg1: Internal.FloatBuffer, arg2: number, arg3: number): Internal.FloatBuffer
        put(arg0: Internal.FloatBuffer): Internal.FloatBuffer
        put(arg0: number, arg1: number): Internal.FloatBuffer
        put(arg0: number): Internal.FloatBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.Buffer
        slice(): Internal.FloatBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.FloatBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(): number
        get(arg0: number, arg1: number[]): Internal.FloatBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        get(arg0: number[]): Internal.FloatBuffer
        limit(arg0: number): Internal.FloatBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.Buffer
        flip(): Internal.FloatBuffer
        order(): Internal.ByteOrder
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.FloatBuffer
        duplicate(): Internal.FloatBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        static allocate(arg0: number): Internal.FloatBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.FloatBuffer
        mismatch(arg0: Internal.FloatBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.Buffer
        reset(): Internal.FloatBuffer
        toString(): string
        position(arg0: number): Internal.FloatBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.FloatBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        mark(): Internal.Buffer
        mark(): Internal.FloatBuffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RenderingHints$Key {
        isCompatibleValue(arg0: any): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VampirismPlayerAttributes {
        getClass(): Internal.Class<any>
        getHuntSpecial(): Internal.HunterPlayerSpecialAttribute
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get(arg0: Internal.Player): Internal.VampirismPlayerAttributes
        getVampSpecial(): Internal.VampirePlayerSpecialAttributes
        toString(): string
        notify(): void
        hunterLevel : number;
        lordLevel : number;
        faction : Internal.IPlayableFaction<any>;
        vampireLevel : number;
        get class(): Internal.Class<any>;
        get huntSpecial(): Internal.HunterPlayerSpecialAttribute;
        get vampSpecial(): Internal.VampirePlayerSpecialAttributes;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LongSummaryStatistics implements Internal.LongConsumer, java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMax(): number
        notifyAll(): void
        getAverage(): number
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        notify(): void
        accept(arg0: number): void
        accept(arg0: number): void
        getMin(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getCount(): number
        getSum(): number
        combine(arg0: Internal.LongSummaryStatistics): void
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Graphics {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        drawOval(arg0: number, arg1: number, arg2: number, arg3: number): void
        fillArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        notifyAll(): void
        getClipRect(): Internal.Rectangle
        fillRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        notify(): void
        translate(arg0: number, arg1: number): void
        drawString(arg0: string, arg1: number, arg2: number): void
        drawString(arg0: Internal.AttributedCharacterIterator, arg1: number, arg2: number): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getFontMetrics(): Internal.FontMetrics
        draw3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void
        fillPolygon(arg0: number[], arg1: number[], arg2: number): void
        fillPolygon(arg0: Internal.Polygon): void
        getClipBounds(): Internal.Rectangle
        getClipBounds(arg0: Internal.Rectangle): Internal.Rectangle
        hashCode(): number
        drawChars(arg0: string[], arg1: number, arg2: number, arg3: number, arg4: number): void
        drawRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        fill3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void
        create(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Graphics
        create(): Internal.Graphics
        setClip(arg0: number, arg1: number, arg2: number, arg3: number): void
        setClip(arg0: Internal.Shape): void
        setFont(arg0: java_.awt.Font): void
        drawPolyline(arg0: number[], arg1: number[], arg2: number): void
        fillRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        clipRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        getColor(): java_.awt.Color
        drawArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        drawLine(arg0: number, arg1: number, arg2: number, arg3: number): void
        copyArea(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        drawBytes(arg0: number[], arg1: number, arg2: number, arg3: number, arg4: number): void
        clearRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        setPaintMode(): void
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: java_.awt.Color, arg10: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: java_.awt.Color, arg4: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: java_.awt.Color, arg6: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.ImageObserver): boolean
        setColor(arg0: java_.awt.Color): void
        hitClip(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        equals(arg0: any): boolean
        getClip(): Internal.Shape
        toString(): string
        finalize(): void
        getFont(): java_.awt.Font
        dispose(): void
        fillOval(arg0: number, arg1: number, arg2: number, arg3: number): void
        setXORMode(arg0: java_.awt.Color): void
        drawPolygon(arg0: number[], arg1: number[], arg2: number): void
        drawPolygon(arg0: Internal.Polygon): void
        drawRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        get color(): java_.awt.Color;
        get clipBounds(): Internal.Rectangle;
        get fontMetrics(): Internal.FontMetrics;
        get class(): Internal.Class<any>;
        get clip(): Internal.Shape;
        get font(): java_.awt.Font;
        set color(arg0: java_.awt.Color);
        set xORMode(arg0: java_.awt.Color);
        set clip(arg0: Internal.Shape);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DefaultChapterGroup extends Internal.ChapterGroup {
        getClass(): Internal.Class<any>
        isDefaultGroup(): boolean
        getIndex(): number
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        getPath(): string
        clearCachedData(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        editedFromGUI(): void
        hasTag(tag: string): boolean
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        getChildren(): Internal.Collection<Internal.QuestObject>
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getAltTitle(): Internal.Component
        getVisibleChapters(data: Internal.TeamData): Internal.List<Internal.Chapter>
        deleteSelf(): void
        cacheProgress(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        notify(): void
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getFirstVisibleChapter(data: Internal.TeamData): Internal.Chapter
        getQuestFile(): Internal.QuestFile
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        disableToast : boolean;
        readonly file : Internal.QuestFile;
        readonly chapters : Internal.List<Internal.Chapter>;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        guiCollapsed : boolean;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get path(): string;
        get defaultGroup(): boolean;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class QuestFile extends Internal.QuestObject {
        getClass(): Internal.Class<any>
        clearCachedProgress(): void
        getAllTasks(): Internal.List<Internal.Task>
        newID(): number
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getFolder(): Internal.Path
        isServerSide(): boolean
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        getAllObjects(): Internal.Collection<Internal.QuestObjectBase>
        deleteObject(arg0: number): void
        getPath(): string
        create(type: (arg0: any) => boolean, parent: number, extra: Internal.CompoundTag): Internal.QuestObjectBase
        clearCachedData(): void
        getRandomLootCrate(entity: Internal.Entity, random: Internal.Random): Internal.LootCrate
        getQuest(id: number): Internal.Quest
        editedFromGUI(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        writeNetDataFull(buffer: Internal.FriendlyByteBuf): void
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        getID(o: any): number
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        refreshGui(): void
        isLoading(): boolean
        getChildren(): Internal.Collection<Internal.QuestObject>
        onStarted(data: Internal.QuestProgressEventData<any>): void
        refreshIDMap(): void
        getAltTitle(): Internal.MutableComponent
        getAltTitle(): Internal.Component
        getVisibleChapters(data: Internal.TeamData): Internal.List<Internal.Chapter>
        getBase(id: number): Internal.QuestObjectBase
        deleteSelf(): void
        collect<T_>(filter: (arg0: Internal.QuestObjectBase) => boolean): Internal.List<T_>
        collect<T_>(clazz: Internal.Class<T_>): Internal.List<T_>
        cacheProgress(): boolean
        readNetDataFull(buffer: Internal.FriendlyByteBuf): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getSubmitTasks(): Internal.List<Internal.Task>
        getReward(id: number): Internal.Reward
        getNullableTeamData(id: Internal.UUID): Internal.TeamData
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        canEdit(): boolean
        save(): void
        getSide(): Internal.Env
        getDefaultQuestShape(): string
        notify(): void
        remove(id: number): Internal.QuestObjectBase
        getChapter(id: number): Internal.Chapter
        getAllData(): Internal.Collection<Internal.TeamData>
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        readDataFull(folder: Internal.Path): void
        load(): void
        hashCode(): number
        getAltIcon(): Internal.Icon
        get(id: number): Internal.QuestObject
        writeDataFull(folder: Internal.Path): void
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getData(teamId: Internal.UUID): Internal.TeamData
        getData(player: Internal.Entity): Internal.TeamData
        getData(team: Internal.TeamBase): Internal.TeamData
        getParentID(): number
        getLootCrate(id: string): Internal.LootCrate
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        updateLootCrates(): void
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getAllChapters(): Internal.List<Internal.Chapter>
        getFirstVisibleChapter(data: Internal.TeamData): Internal.Chapter
        getRewardTable(id: number): Internal.RewardTable
        addData(data: Internal.TeamData, override: boolean): void
        getQuestFile(): Internal.QuestFile
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        readID(tag: Internal.Tag): number
        readID(id: number): number
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        getChapterGroup(id: number): Internal.ChapterGroup
        getTask(id: number): Internal.Task
        disableToast : boolean;
        defaultTeamConsumeItems : boolean;
        gridScale : number;
        icon : Internal.ItemStack;
        defaultQuestDisableJEI : boolean;
        title : string;
        readonly rewardTables : Internal.List<Internal.RewardTable>;
        defaultQuestShape : string;
        readonly rewardTypeIds : (arg0: any) => any;
        readonly lootCrateNoDrop : Internal.EntityWeight;
        lockMessage : string;
        id : number;
        fileVersion : number;
        pauseGame : boolean;
        defaultRewardAutoClaim : Internal.RewardAutoClaim;
        readonly chapterGroups : Internal.List<Internal.ChapterGroup>;
        readonly defaultChapterGroup : Internal.DefaultChapterGroup;
        readonly emergencyItems : Internal.List<Internal.ItemStack>;
        emergencyItemsCooldown : number;
        dropLootCrates : boolean;
        disableGui : boolean;
        readonly taskTypeIds : (arg0: any) => any;
        static VERSION : 13;
        invalid : boolean;
        static sendNotifications : Internal.Tristate;
        defaultRewardTeam : boolean;
        get side(): Internal.Env;
        get allTasks(): Internal.List<Internal.Task>;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get loading(): boolean;
        get allObjects(): Internal.Collection<Internal.QuestObjectBase>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get serverSide(): boolean;
        get path(): string;
        get allData(): Internal.Collection<Internal.TeamData>;
        get folder(): Internal.Path;
        get children(): Internal.Collection<Internal.QuestObject>;
        get allChapters(): Internal.List<Internal.Chapter>;
        get altTitle(): Internal.Component;
        get submitTasks(): Internal.List<Internal.Task>;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Object2LongEntry implements Internal.Comparable<Internal.Object2LongEntry> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(arg0: any): number
        compareTo(o: Internal.Object2LongEntry): number
        notify(): void
        readonly value : number;
        readonly key : any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FluidStackJS implements Internal.WrappedJS, Internal.Copyable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getNbt(): Internal.CompoundTag
        getChance(): number
        notifyAll(): void
        getId(): string
        getTags(): Internal.Collection<ResourceLocation>
        notify(): void
        toNBT(): Internal.CompoundTag
        setChance(c: number): void
        hashCode(): number
        static of(o: any, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS
        static of(o: any): Internal.FluidStackJS
        withAmount(amount: number): Internal.FluidStackJS
        copy(): Internal.Copyable
        copy(): Internal.FluidStackJS
        withChance(c: number): Internal.FluidStackJS
        setAmount(arg0: number): void
        getAmount(): number
        withNBT(nbt: Internal.CompoundTag): Internal.FluidStackJS
        hasTag(tag: ResourceLocation): boolean
        isEmpty(): boolean
        hasChance(): boolean
        strongEquals(o: any): boolean
        getFluidStack(): dev.architectury.fluid.FluidStack
        toJson(): Internal.JsonObject
        equals(o: any): boolean
        getFluid(): Internal.Fluid
        static fromJson(e: Internal.JsonElement): Internal.FluidStackJS
        toString(): string
        removeChance(): void
        setNbt(arg0: Internal.CompoundTag): void
        get nbt(): Internal.CompoundTag;
        get amount(): number;
        get chance(): number;
        get fluidStack(): dev.architectury.fluid.FluidStack;
        get fluid(): Internal.Fluid;
        get id(): string;
        get class(): Internal.Class<any>;
        get tags(): Internal.Collection<ResourceLocation>;
        get empty(): boolean;
        set nbt(arg0: Internal.CompoundTag);
        set amount(arg0: number);
        set chance(c: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IDSqueezerRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        duration(i: number): Internal.IDSqueezerRecipeJS
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Function13 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13) => R>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function4<T10, T11, T12, T13, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function6<T8, T9, T10, T11, T12, T13, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function5<T9, T10, T11, T12, T13, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function8<T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function7<T7, T8, T9, T10, T11, T12, T13, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function3<T11, T12, T13, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function10<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12, arg1: T13) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function9<T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function11<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>
        curry(): (arg0: T1) => Internal.Function12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>
    }
    class TeamRank extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isAlly(): boolean
        isNone(): boolean
        static valueOf(name: string): Internal.TeamRank
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.TeamRank[]
        is(rank: Internal.TeamRank): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.TeamRank): number
        isMember(): boolean
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TeamRank>>
        isOfficer(): boolean
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.TeamRank>
        getPower(): number
        isEnemy(): boolean
        isInvited(): boolean
        isOwner(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly OWNER : Internal.TeamRank;
        static readonly INVITED : Internal.TeamRank;
        static readonly ALLY : Internal.TeamRank;
        static readonly NAME_MAP : Internal.NameMap<Internal.TeamRank>;
        static readonly ENEMY : Internal.TeamRank;
        static readonly OFFICER : Internal.TeamRank;
        static readonly VALUES : Internal.TeamRank[];
        static readonly NONE : Internal.TeamRank;
        static readonly MEMBER : Internal.TeamRank;
        get owner(): boolean;
        get ally(): boolean;
        get officer(): boolean;
        get member(): boolean;
        get invited(): boolean;
        get enemy(): boolean;
        get none(): boolean;
        get power(): number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TeamRank>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractCollection <E> implements Internal.Collection<E> {
        add(arg0: E): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        notifyAll(): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        notify(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface VertexWriter {
        seekToVertex(arg0: number): void
        writeVertexList(arg0: Internal.VertexList): void
        writeVertex(arg0: Internal.VertexList, arg1: number): void
        intoReader(): Internal.VertexList
    }
    class ServerResources implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NonNullConsumer <T> {
        accept(arg0: T): void
    }
    class Window$Type extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Window$Type
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Window$Type[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Window$Type): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Window$Type>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Window$Type>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly POPUP : Internal.Window$Type;
        static readonly UTILITY : Internal.Window$Type;
        static readonly NORMAL : Internal.Window$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Window$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrivilegedAction <T> {
        run(): T
    }
    class ElementBuffer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        bind(): void
        unbind(): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly eboIndexType : Internal.GlNumericType;
        readonly elementCount : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ComponentOrientation implements Internal.Serializable {
        isLeftToRight(): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getOrientation(arg0: Internal.ResourceBundle): Internal.ComponentOrientation
        static getOrientation(arg0: Internal.Locale): Internal.ComponentOrientation
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        isHorizontal(): boolean
        static readonly RIGHT_TO_LEFT : Internal.ComponentOrientation;
        static readonly UNKNOWN : Internal.ComponentOrientation;
        static readonly LEFT_TO_RIGHT : Internal.ComponentOrientation;
        get leftToRight(): boolean;
        get horizontal(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AtlasSet implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GraphicsDevice$WindowTranslucency extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.GraphicsDevice$WindowTranslucency
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.GraphicsDevice$WindowTranslucency[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.GraphicsDevice$WindowTranslucency): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.GraphicsDevice$WindowTranslucency>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.GraphicsDevice$WindowTranslucency>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly PERPIXEL_TRANSPARENT : Internal.GraphicsDevice$WindowTranslucency;
        static readonly TRANSLUCENT : Internal.GraphicsDevice$WindowTranslucency;
        static readonly PERPIXEL_TRANSLUCENT : Internal.GraphicsDevice$WindowTranslucency;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.GraphicsDevice$WindowTranslucency>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LinkedHashMap <K, V> extends Internal.HashMap<any, any> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        notifyAll(): void
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V, arg2: V): boolean
        replace(arg0: K, arg1: V): V
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        notify(): void
        put(arg0: K, arg1: V): V
        remove(arg0: any, arg1: any): boolean
        remove(arg0: any): V
        containsValue(arg0: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TranslatableComponent extends Internal.BaseComponent implements Internal.ContextAwareComponent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getString(): string
        notify(): void
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Collector <T, A, R> {
        characteristics(): Internal.Set<Internal.Collector$Characteristics>
        supplier(): () => A
        finisher(): (arg0: A) => R
        accumulator(): (arg0: A, arg1: T) => void
        combiner(): (arg0: any, arg1: any) => any
    }
    interface LevelRendererAccessor {
        flywheel$getDestructionProgress(): (arg0: any) => any
    }
    class FoodProperties {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CompletionStage <T> {
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletionStage<T>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<void>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U, arg2: Internal.Executor): Internal.CompletionStage<U>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletionStage<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>
        thenAcceptBoth<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>
        applyToEither<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        thenApply<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>, arg1: Internal.Executor): Internal.CompletionStage<U>
        thenAccept(arg0: (arg0: T) => void): Internal.CompletionStage<void>
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<void>
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>
        handle<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U, arg1: Internal.Executor): Internal.CompletionStage<U>
        thenCompose<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V, arg2: Internal.Executor): Internal.CompletionStage<V>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void, arg2: Internal.Executor): Internal.CompletionStage<void>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletionStage<T>
        thenCombine<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletionStage<T>
        thenApplyAsync<U>(arg0: (arg0: T) => U, arg1: Internal.Executor): Internal.CompletionStage<U>
        thenApplyAsync<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletionStage<void>
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletionStage<void>
        toCompletableFuture(): Internal.CompletableFuture<T>
    }
    class ScriptFile implements Internal.Comparable<Internal.ScriptFile> {
        getError(): Internal.Throwable
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        load(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(o: Internal.ScriptFile): number
        compareTo(arg0: any): number
        notify(): void
        readonly source : Internal.ScriptSource;
        readonly pack : Internal.ScriptPack;
        readonly info : Internal.ScriptFileInfo;
        get error(): Internal.Throwable;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntIterable extends Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: (arg0: any) => void): void
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
    }
    interface ItemAccessor {
        setCategory(arg0: Internal.CreativeModeTab): void
        getCategory(): Internal.CreativeModeTab
    }
    interface FilterInfo {
        pop(): void
        add(arg0: Internal.Component): void
        push(): void
    }
    interface EntityAccessor {
        getIsInsidePortal(): boolean
    }
    class GoalSelector implements Internal.AccessorGoalSelector {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getAvailableGoals(): Internal.Set<any>
        notify(): void
        get availableGoals(): Internal.Set<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2CharFunction extends Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface LongSupplier {
        getAsLong(): number
    }
    interface Component extends Internal.Message, Internal.FormattedText {
        getString(): string
    }
    interface IForgeFriendlyByteBuf {
        readRegistryIdSafe<T>(arg0: Internal.Class<T>): T
        readRegistryId<T>(): T
        readFluidStack(): Internal.FluidStack
        writeRegistryId<T>(arg0: T): void
        readRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>): T
        writeFluidStack(arg0: Internal.FluidStack): void
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<any>, arg1: ResourceLocation): void
        writeRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>, arg1: T): void
    }
    interface IntConsumer extends Internal.Consumer<number>, java_.util.function_.IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        andThen(arg0: java_.util.function_.IntConsumer): (arg0: any) => void
        andThen(arg0: (arg0: number) => void): (arg0: number) => void
        andThen(arg0: (arg0: any) => void): (arg0: any) => void
        accept(arg0: any): void
        accept(arg0: number): void
        accept(arg0: number): void
    }
    abstract class EntityEventJS extends Internal.LevelEventJS {
        cancel(): void
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        notifyAll(): void
        getEntity(): Internal.EntityJS
        notify(): void
        getLevel(): Internal.LevelJS
        post(id: string, sub: string): boolean
        post(id: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        canCancel(): boolean
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LayoutItem {
        size(): number
        attributeCount(): number
        vertexAttribPointer(arg0: number, arg1: number, arg2: number): void
    }
    interface Color extends Internal.SpecialEquality {
        getRgbKJS(): number
        getArgbKJS(): number
        getHexKJS(): string
        createTextColorKJS(): Internal.TextColor
        getFireworkColorKJS(): number
        getSerializeKJS(): string
        specialEquals(o: any, shallow: boolean): boolean
    }
    class Frame extends Internal.Window implements Internal.MenuContainer {
        getLocation(arg0: Internal.Point): Internal.Point
        getLocation(): Internal.Point
        requestFocusInWindow(): boolean
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause): boolean
        isOpaque(): boolean
        static getFrames(): Internal.Frame[]
        setModalExclusionType(arg0: Internal.Dialog$ModalExclusionType): void
        paint(arg0: Internal.Graphics): void
        removeWindowListener(arg0: Internal.WindowListener): void
        getInputMethodListeners(): Internal.InputMethodListener[]
        setLayout(arg0: Internal.LayoutManager): void
        mouseDown(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getOwner(): Internal.Window
        getInputMethodRequests(): Internal.InputMethodRequests
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        removeAll(): void
        getMinimumSize(): Internal.Dimension
        getAlignmentY(): number
        getWindowStateListeners(): Internal.WindowStateListener[]
        getAlignmentX(): number
        dispatchEvent(arg0: Internal.AWTEvent): void
        setFocusableWindowState(arg0: boolean): void
        getMostRecentFocusOwner(): java_.awt.Component
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void
        pack(): void
        postEvent(arg0: Internal.Event): boolean
        toBack(): void
        createBufferStrategy(arg0: number): void
        createBufferStrategy(arg0: number, arg1: Internal.BufferCapabilities): void
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point): boolean
        size(): Internal.Dimension
        getType(): Internal.Window$Type
        enableInputMethods(arg0: boolean): void
        mouseUp(arg0: Internal.Event, arg1: number, arg2: number): boolean
        removeContainerListener(arg0: Internal.ContainerListener): void
        addComponentListener(arg0: Internal.ComponentListener): void
        setName(arg0: string): void
        removeInputMethodListener(arg0: Internal.InputMethodListener): void
        getMaximizedBounds(): Internal.Rectangle
        removeHierarchyListener(arg0: Internal.HierarchyListener): void
        removeWindowFocusListener(arg0: Internal.WindowFocusListener): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getHeight(): number
        getIgnoreRepaint(): boolean
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior
        removeMouseWheelListener(arg0: Internal.MouseWheelListener): void
        applyComponentOrientation(arg0: Internal.ComponentOrientation): void
        isAlwaysOnTopSupported(): boolean
        validate(): void
        getParent(): java_.awt.Container
        isMinimumSizeSet(): boolean
        getWindowFocusListeners(): Internal.WindowFocusListener[]
        setComponentOrientation(arg0: Internal.ComponentOrientation): void
        setBounds(arg0: Internal.Rectangle): void
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void
        static getWindows(): Internal.Window[]
        isValidateRoot(): boolean
        addNotify(): void
        addInputMethodListener(arg0: Internal.InputMethodListener): void
        toString(): string
        getFocusCycleRootAncestor(): java_.awt.Container
        setFocusTraversalPolicyProvider(arg0: boolean): void
        addWindowFocusListener(arg0: Internal.WindowFocusListener): void
        getName(): string
        countComponents(): number
        isFocusTraversable(): boolean
        inside(arg0: number, arg1: number): boolean
        nextFocus(): void
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>
        getInputContext(): Internal.InputContext
        isCursorSet(): boolean
        setMenuBar(arg0: Internal.MenuBar): void
        getMouseWheelListeners(): Internal.MouseWheelListener[]
        getComponents(): java_.awt.Component[]
        removeMouseMotionListener(arg0: Internal.MouseMotionListener): void
        doLayout(): void
        isLocationByPlatform(): boolean
        add(arg0: java_.awt.Component, arg1: number): java_.awt.Component
        add(arg0: string, arg1: java_.awt.Component): java_.awt.Component
        add(arg0: java_.awt.Component, arg1: any): void
        add(arg0: java_.awt.Component, arg1: any, arg2: number): void
        add(arg0: java_.awt.Component): java_.awt.Component
        add(arg0: Internal.PopupMenu): void
        setVisible(arg0: boolean): void
        removeKeyListener(arg0: Internal.KeyListener): void
        setFocusCycleRoot(arg0: boolean): void
        setTitle(arg0: string): void
        isResizable(): boolean
        isVisible(): boolean
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        setDropTarget(arg0: Internal.DropTarget): void
        list(arg0: Internal.PrintStream, arg1: number): void
        list(arg0: Internal.PrintWriter, arg1: number): void
        list(arg0: Internal.PrintStream): void
        list(): void
        list(arg0: Internal.PrintWriter): void
        isFocused(): boolean
        revalidate(): void
        removeWindowStateListener(arg0: Internal.WindowStateListener): void
        removeNotify(): void
        getWarningString(): string
        static getOwnerlessWindows(): Internal.Window[]
        gotFocus(arg0: Internal.Event, arg1: any): boolean
        handleEvent(arg0: Internal.Event): boolean
        notifyAll(): void
        isForegroundSet(): boolean
        show(): void
        show(arg0: boolean): void
        update(arg0: Internal.Graphics): void
        getShape(): Internal.Shape
        isFocusTraversalPolicySet(): boolean
        setMaximumSize(arg0: Internal.Dimension): void
        remove(arg0: Internal.MenuComponent): void
        remove(arg0: number): void
        remove(arg0: java_.awt.Component): void
        addMouseWheelListener(arg0: Internal.MouseWheelListener): void
        imageUpdate(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        checkImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): number
        checkImage(arg0: Internal.Image, arg1: Internal.ImageObserver): number
        getLayout(): Internal.LayoutManager
        addKeyListener(arg0: Internal.KeyListener): void
        getContainerListeners(): Internal.ContainerListener[]
        hashCode(): number
        getComponentListeners(): Internal.ComponentListener[]
        isMaximumSizeSet(): boolean
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        getWindowListeners(): Internal.WindowListener[]
        getCursorType(): number
        getCursor(): Internal.Cursor
        createImage(arg0: number, arg1: number): Internal.Image
        createImage(arg0: Internal.ImageProducer): Internal.Image
        mouseMove(arg0: Internal.Event, arg1: number, arg2: number): boolean
        areFocusTraversalKeysSet(arg0: number): boolean
        getKeyListeners(): Internal.KeyListener[]
        setType(arg0: Internal.Window$Type): void
        layout(): void
        setExtendedState(arg0: number): void
        getBaseline(arg0: number, arg1: number): number
        print(arg0: Internal.Graphics): void
        paintComponents(arg0: Internal.Graphics): void
        getFocusListeners(): Internal.FocusListener[]
        resize(arg0: number, arg1: number): void
        resize(arg0: Internal.Dimension): void
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities): Internal.VolatileImage
        isAutoRequestFocus(): boolean
        setState(arg0: number): void
        location(): Internal.Point
        lostFocus(arg0: Internal.Event, arg1: any): boolean
        getDropTarget(): Internal.DropTarget
        keyDown(arg0: Internal.Event, arg1: number): boolean
        getLocale(): Internal.Locale
        setOpacity(arg0: number): void
        getIconImage(): Internal.Image
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[]
        getBounds(arg0: Internal.Rectangle): Internal.Rectangle
        getBounds(): Internal.Rectangle
        setPreferredSize(arg0: Internal.Dimension): void
        enable(): void
        enable(arg0: boolean): void
        getMousePosition(arg0: boolean): Internal.Point
        getMousePosition(): Internal.Point
        action(arg0: Internal.Event, arg1: any): boolean
        setIconImages(arg0: Internal.List<Internal.Image>): void
        addContainerListener(arg0: Internal.ContainerListener): void
        setComponentZOrder(arg0: java_.awt.Component, arg1: number): void
        firePropertyChange(arg0: string, arg1: string, arg2: string): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        addMouseMotionListener(arg0: Internal.MouseMotionListener): void
        getComponentOrientation(): Internal.ComponentOrientation
        setFocusable(arg0: boolean): void
        getTreeLock(): any
        isBackgroundSet(): boolean
        addHierarchyListener(arg0: Internal.HierarchyListener): void
        findComponentAt(arg0: number, arg1: number): java_.awt.Component
        findComponentAt(arg0: Internal.Point): java_.awt.Component
        setLocationByPlatform(arg0: boolean): void
        setEnabled(arg0: boolean): void
        isLightweight(): boolean
        isEnabled(): boolean
        minimumSize(): Internal.Dimension
        bounds(): Internal.Rectangle
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void
        repaint(): void
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void
        repaint(arg0: number): void
        getMouseMotionListeners(): Internal.MouseMotionListener[]
        setMinimumSize(arg0: Internal.Dimension): void
        getModalExclusionType(): Internal.Dialog$ModalExclusionType
        transferFocus(): void
        printComponents(arg0: Internal.Graphics): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaximumSize(): Internal.Dimension
        getLocationOnScreen(): Internal.Point
        keyUp(arg0: Internal.Event, arg1: number): boolean
        getWidth(): number
        notify(): void
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy): void
        addWindowListener(arg0: Internal.WindowListener): void
        paintAll(arg0: Internal.Graphics): void
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set<Internal.AWTKeyStroke>): void
        hasFocus(): boolean
        isPreferredSizeSet(): boolean
        addWindowStateListener(arg0: Internal.WindowStateListener): void
        getIconImages(): Internal.List<Internal.Image>
        getFocusableWindowState(): boolean
        isDoubleBuffered(): boolean
        getPropertyChangeListeners(): Internal.PropertyChangeListener[]
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[]
        getColorModel(): Internal.ColorModel
        isValid(): boolean
        getInsets(): Internal.Insets
        getFocusTraversalKeysEnabled(): boolean
        hide(): void
        getPreferredSize(): Internal.Dimension
        setUndecorated(arg0: boolean): void
        disable(): void
        isUndecorated(): boolean
        equals(arg0: any): boolean
        prepareImage(arg0: Internal.Image, arg1: Internal.ImageObserver): boolean
        prepareImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        isFocusableWindow(): boolean
        isFocusable(): boolean
        setLocationRelativeTo(arg0: java_.awt.Component): void
        getClass(): Internal.Class<any>
        insets(): Internal.Insets
        setIconImage(arg0: Internal.Image): void
        setMixingCutoutShape(arg0: Internal.Shape): void
        isActive(): boolean
        getMenuBar(): Internal.MenuBar
        mouseExit(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getHierarchyListeners(): Internal.HierarchyListener[]
        getOpacity(): number
        isShowing(): boolean
        mouseEnter(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getTitle(): string
        mouseDrag(arg0: Internal.Event, arg1: number, arg2: number): boolean
        preferredSize(): Internal.Dimension
        getMouseListeners(): Internal.MouseListener[]
        setFont(arg0: java_.awt.Font): void
        setAutoRequestFocus(arg0: boolean): void
        toFront(): void
        deliverEvent(arg0: Internal.Event): void
        getForeground(): java_.awt.Color
        getComponentCount(): number
        isAncestorOf(arg0: java_.awt.Component): boolean
        getExtendedState(): number
        getFont(): java_.awt.Font
        dispose(): void
        setCursor(arg0: number): void
        setCursor(arg0: Internal.Cursor): void
        getGraphicsConfiguration(): Internal.GraphicsConfiguration
        isDisplayable(): boolean
        getComponent(arg0: number): java_.awt.Component
        setLocale(arg0: Internal.Locale): void
        removeComponentListener(arg0: Internal.ComponentListener): void
        requestFocus(arg0: Internal.FocusEvent$Cause): void
        requestFocus(): void
        locate(arg0: number, arg1: number): java_.awt.Component
        addFocusListener(arg0: Internal.FocusListener): void
        getComponentAt(arg0: Internal.Point): java_.awt.Component
        getComponentAt(arg0: number, arg1: number): java_.awt.Component
        isAlwaysOnTop(): boolean
        isFocusCycleRoot(): boolean
        isFocusCycleRoot(arg0: java_.awt.Container): boolean
        setFocusTraversalKeysEnabled(arg0: boolean): void
        getComponentZOrder(arg0: java_.awt.Component): number
        setBackground(arg0: java_.awt.Color): void
        printAll(arg0: Internal.Graphics): void
        getToolkit(): Internal.Toolkit
        transferFocusUpCycle(): void
        isFontSet(): boolean
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        isFocusTraversalPolicyProvider(): boolean
        setLocation(arg0: number, arg1: number): void
        setLocation(arg0: Internal.Point): void
        getGraphics(): Internal.Graphics
        removeFocusListener(arg0: Internal.FocusListener): void
        setIgnoreRepaint(arg0: boolean): void
        transferFocusBackward(): void
        getOwnedWindows(): Internal.Window[]
        setMaximizedBounds(arg0: Internal.Rectangle): void
        move(arg0: number, arg1: number): void
        transferFocusDownCycle(): void
        applyResourceBundle(arg0: Internal.ResourceBundle): void
        applyResourceBundle(arg0: string): void
        setResizable(arg0: boolean): void
        setForeground(arg0: java_.awt.Color): void
        invalidate(): void
        getBufferStrategy(): Internal.BufferStrategy
        getAccessibleContext(): Internal.AccessibleContext
        setShape(arg0: Internal.Shape): void
        isFocusOwner(): boolean
        getSize(): Internal.Dimension
        getSize(arg0: Internal.Dimension): Internal.Dimension
        getX(): number
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        getY(): number
        getState(): number
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy
        setAlwaysOnTop(arg0: boolean): void
        getFocusOwner(): java_.awt.Component
        removeMouseListener(arg0: Internal.MouseListener): void
        getBackground(): java_.awt.Color
        addMouseListener(arg0: Internal.MouseListener): void
        static readonly PROPERTIES : 4;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly MAXIMIZED_HORIZ : 2;
        static readonly WIDTH : 1;
        static readonly FRAMEBITS : 16;
        static readonly MAXIMIZED_BOTH : 6;
        static readonly NW_RESIZE_CURSOR : 6;
        static readonly SE_RESIZE_CURSOR : 5;
        static readonly NE_RESIZE_CURSOR : 7;
        static readonly SW_RESIZE_CURSOR : 4;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly MAXIMIZED_VERT : 4;
        static readonly ERROR : 64;
        static readonly CROSSHAIR_CURSOR : 1;
        static readonly HAND_CURSOR : 12;
        static readonly N_RESIZE_CURSOR : 8;
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly SOMEBITS : 8;
        static readonly ICONIFIED : 1;
        static readonly HEIGHT : 2;
        static readonly S_RESIZE_CURSOR : 9;
        static readonly TEXT_CURSOR : 2;
        static readonly W_RESIZE_CURSOR : 10;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly DEFAULT_CURSOR : 0;
        static readonly E_RESIZE_CURSOR : 11;
        static readonly WAIT_CURSOR : 3;
        static readonly NORMAL : 0;
        static readonly MOVE_CURSOR : 13;
        get parent(): java_.awt.Container;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get foreground(): java_.awt.Color;
        get type(): Internal.Window$Type;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get state(): number;
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get height(): number;
        get frames(): Internal.Frame[];
        get shape(): Internal.Shape;
        get displayable(): boolean;
        get active(): boolean;
        get maximumSizeSet(): boolean;
        get autoRequestFocus(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get componentCount(): number;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): java_.awt.Container;
        get focusCycleRoot(): boolean;
        get focusTraversable(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get alwaysOnTopSupported(): boolean;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get alwaysOnTop(): boolean;
        get ownerlessWindows(): Internal.Window[];
        get enabled(): boolean;
        get valid(): boolean;
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get locationByPlatform(): boolean;
        get colorModel(): Internal.ColorModel;
        get bufferStrategy(): Internal.BufferStrategy;
        get keyListeners(): Internal.KeyListener[];
        get resizable(): boolean;
        get validateRoot(): boolean;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get opacity(): number;
        get maximizedBounds(): Internal.Rectangle;
        get font(): java_.awt.Font;
        get warningString(): string;
        get iconImage(): Internal.Image;
        get cursorType(): number;
        get modalExclusionType(): Internal.Dialog$ModalExclusionType;
        get windowFocusListeners(): Internal.WindowFocusListener[];
        get graphics(): Internal.Graphics;
        get foregroundSet(): boolean;
        get menuBar(): Internal.MenuBar;
        get doubleBuffered(): boolean;
        get ownedWindows(): Internal.Window[];
        get visible(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): java_.awt.Component;
        get iconImages(): Internal.List<Internal.Image>;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get background(): java_.awt.Color;
        get name(): string;
        get focused(): boolean;
        get focusableWindow(): boolean;
        get containerListeners(): Internal.ContainerListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get mostRecentFocusOwner(): java_.awt.Component;
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get title(): string;
        get ignoreRepaint(): boolean;
        get lightweight(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get focusableWindowState(): boolean;
        get windowStateListeners(): Internal.WindowStateListener[];
        get class(): Internal.Class<any>;
        get owner(): Internal.Window;
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get extendedState(): number;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get windows(): Internal.Window[];
        get windowListeners(): Internal.WindowListener[];
        get undecorated(): boolean;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        set cursor(arg0: Internal.Cursor);
        set iconImage(arg0: Internal.Image);
        set locationRelativeTo(arg0: java_.awt.Component);
        set alwaysOnTop(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation);
        set dropTarget(arg0: Internal.DropTarget);
        set modalExclusionType(arg0: Internal.Dialog$ModalExclusionType);
        set foreground(arg0: java_.awt.Color);
        set locale(arg0: Internal.Locale);
        set type(arg0: Internal.Window$Type);
        set title(arg0: string);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set menuBar(arg0: Internal.MenuBar);
        set focusableWindowState(arg0: boolean);
        set locationByPlatform(arg0: boolean);
        set state(arg0: number);
        set visible(arg0: boolean);
        set shape(arg0: Internal.Shape);
        set resizable(arg0: boolean);
        set extendedState(arg0: number);
        set autoRequestFocus(arg0: boolean);
        set focusable(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape);
        set undecorated(arg0: boolean);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy);
        set iconImages(arg0: Internal.List<Internal.Image>);
        set background(arg0: java_.awt.Color);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension);
        set opacity(arg0: number);
        set maximizedBounds(arg0: Internal.Rectangle);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VarHandle$AccessMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.VarHandle$AccessMode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.VarHandle$AccessMode[]
        methodName(): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.VarHandle$AccessMode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.VarHandle$AccessMode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.VarHandle$AccessMode>
        hashCode(): number
        equals(arg0: any): boolean
        static valueFromMethodName(arg0: string): Internal.VarHandle$AccessMode
        name(): string
        toString(): string
        ordinal(): number
        static readonly WEAK_COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly SET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly SET_OPAQUE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND : Internal.VarHandle$AccessMode;
        static readonly SET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_PLAIN : Internal.VarHandle$AccessMode;
        static readonly SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_RELEASE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_OPAQUE : Internal.VarHandle$AccessMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.VarHandle$AccessMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeLevel extends Internal.ICapabilityProvider {
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        increaseMaxEntityRadius(arg0: number): number
        getMaxEntityRadius(): number
    }
    interface Stack <K> {
        pop(): K
        top(): K
        isEmpty(): boolean
        push(arg0: K): void
        peek(arg0: number): K
    }
    class MethodHandles$Lookup {
        getClass(): Internal.Class<any>
        findStaticVarHandle(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.VarHandle
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        hasFullPrivilegeAccess(): boolean
        findStaticGetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle
        lookupClass(): Internal.Class<any>
        defineHiddenClass(arg0: number[], arg1: boolean, arg2: any[]): Internal.MethodHandles$Lookup
        notify(): void
        unreflectSetter(arg0: Internal.Field): Internal.MethodHandle
        findVirtual(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        findConstructor(arg0: Internal.Class<any>, arg1: Internal.MethodType): Internal.MethodHandle
        dropLookupMode(arg0: number): Internal.MethodHandles$Lookup
        findStaticSetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle
        bind(arg0: any, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        hashCode(): number
        findGetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle
        hasPrivateAccess(): boolean
        unreflectGetter(arg0: Internal.Field): Internal.MethodHandle
        accessClass(arg0: Internal.Class<any>): Internal.Class<any>
        findSpecial(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType, arg3: Internal.Class<any>): Internal.MethodHandle
        in(arg0: Internal.Class<any>): Internal.MethodHandles$Lookup
        defineClass(arg0: number[]): Internal.Class<any>
        unreflectConstructor(arg0: Internal.Constructor<any>): Internal.MethodHandle
        findClass(arg0: string): Internal.Class<any>
        unreflectVarHandle(arg0: Internal.Field): Internal.VarHandle
        defineHiddenClassWithClassData(arg0: number[], arg1: any, arg2: boolean, arg3: any[]): Internal.MethodHandles$Lookup
        lookupModes(): number
        findStatic(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        ensureInitialized(arg0: Internal.Class<any>): Internal.Class<any>
        unreflectSpecial(arg0: Internal.Method, arg1: Internal.Class<any>): Internal.MethodHandle
        unreflect(arg0: Internal.Method): Internal.MethodHandle
        findVarHandle(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.VarHandle
        findSetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle
        equals(arg0: any): boolean
        toString(): string
        previousLookupClass(): Internal.Class<any>
        revealDirect(arg0: Internal.MethodHandle): Internal.MethodHandleInfo
        static readonly MODULE : 16;
        static readonly PACKAGE : 8;
        static readonly PUBLIC : 1;
        static readonly ORIGINAL : 64;
        static readonly UNCONDITIONAL : 32;
        static readonly PROTECTED : 4;
        static readonly PRIVATE : 2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Channel$Unsafe {
        disconnect(arg0: Internal.ChannelPromise): void
        deregister(arg0: Internal.ChannelPromise): void
        recvBufAllocHandle(): Internal.RecvByteBufAllocator$Handle
        closeForcibly(): void
        beginRead(): void
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): void
        flush(): void
        voidPromise(): Internal.ChannelPromise
        localAddress(): Internal.SocketAddress
        outboundBuffer(): Internal.ChannelOutboundBuffer
        close(arg0: Internal.ChannelPromise): void
        write(arg0: any, arg1: Internal.ChannelPromise): void
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): void
        remoteAddress(): Internal.SocketAddress
        register(arg0: Internal.EventLoop, arg1: Internal.ChannelPromise): void
    }
    class ZoneRules implements Internal.Serializable {
        getTransitions(): Internal.List<Internal.ZoneOffsetTransition>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDaylightSavings(arg0: Internal.Instant): Internal.Duration
        getTransitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>
        previousTransition(arg0: Internal.Instant): Internal.ZoneOffsetTransition
        notifyAll(): void
        getOffset(arg0: Internal.LocalDateTime): Internal.ZoneOffset
        getOffset(arg0: Internal.Instant): Internal.ZoneOffset
        notify(): void
        isFixedOffset(): boolean
        hashCode(): number
        getTransition(arg0: Internal.LocalDateTime): Internal.ZoneOffsetTransition
        getValidOffsets(arg0: Internal.LocalDateTime): Internal.List<Internal.ZoneOffset>
        static of(arg0: Internal.ZoneOffset, arg1: Internal.ZoneOffset, arg2: Internal.List<Internal.ZoneOffsetTransition>, arg3: Internal.List<Internal.ZoneOffsetTransition>, arg4: Internal.List<Internal.ZoneOffsetTransitionRule>): Internal.ZoneRules
        static of(arg0: Internal.ZoneOffset): Internal.ZoneRules
        equals(arg0: any): boolean
        nextTransition(arg0: Internal.Instant): Internal.ZoneOffsetTransition
        getStandardOffset(arg0: Internal.Instant): Internal.ZoneOffset
        toString(): string
        isDaylightSavings(arg0: Internal.Instant): boolean
        isValidOffset(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset): boolean
        get fixedOffset(): boolean;
        get transitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>;
        get transitions(): Internal.List<Internal.ZoneOffsetTransition>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Tags$IOptionalNamedTag <T> extends Internal.Tag$Named<T> {
        isDefaulted(): boolean
    }
    interface CompositeContext {
        compose(arg0: Internal.Raster, arg1: Internal.Raster, arg2: Internal.WritableRaster): void
        dispose(): void
    }
    interface HierarchyBoundsListener extends Internal.EventListener {
        ancestorResized(arg0: Internal.HierarchyEvent): void
        ancestorMoved(arg0: Internal.HierarchyEvent): void
    }
    class ScriptManager {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        loadFromDirectory(): void
        load(): void
        hashCode(): number
        isClassAllowed(name: string): boolean
        notifyAll(): void
        equals(arg0: any): boolean
        loadJavaClass(scope: Internal.Scriptable, args: any[]): Internal.NativeJavaClass
        unload(): void
        toString(): string
        notify(): void
        readonly exampleScript : string;
        readonly type : Internal.ScriptType;
        firstLoad : boolean;
        readonly directory : Internal.Path;
        readonly packs : Internal.Map<string, Internal.ScriptPack>;
        readonly events : Internal.EventsJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FontMetrics implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaxCharBounds(arg0: Internal.Graphics): Internal.Rectangle2D
        notifyAll(): void
        notify(): void
        getHeight(): number
        getMaxAscent(): number
        hashCode(): number
        getFontRenderContext(): Internal.FontRenderContext
        bytesWidth(arg0: number[], arg1: number, arg2: number): number
        getLineMetrics(arg0: string[], arg1: number, arg2: number, arg3: Internal.Graphics): Internal.LineMetrics
        getLineMetrics(arg0: string, arg1: Internal.Graphics): Internal.LineMetrics
        getLineMetrics(arg0: Internal.CharacterIterator, arg1: number, arg2: number, arg3: Internal.Graphics): Internal.LineMetrics
        getLineMetrics(arg0: string, arg1: number, arg2: number, arg3: Internal.Graphics): Internal.LineMetrics
        getDescent(): number
        hasUniformLineMetrics(): boolean
        getLeading(): number
        getStringBounds(arg0: string[], arg1: number, arg2: number, arg3: Internal.Graphics): Internal.Rectangle2D
        getStringBounds(arg0: Internal.CharacterIterator, arg1: number, arg2: number, arg3: Internal.Graphics): Internal.Rectangle2D
        getStringBounds(arg0: string, arg1: Internal.Graphics): Internal.Rectangle2D
        getStringBounds(arg0: string, arg1: number, arg2: number, arg3: Internal.Graphics): Internal.Rectangle2D
        charWidth(arg0: string): number
        charWidth(arg0: number): number
        getMaxDecent(): number
        getMaxDescent(): number
        charsWidth(arg0: string[], arg1: number, arg2: number): number
        getAscent(): number
        stringWidth(arg0: string): number
        getMaxAdvance(): number
        equals(arg0: any): boolean
        toString(): string
        getFont(): java_.awt.Font
        getWidths(): number[]
        get maxAscent(): number;
        get descent(): number;
        get maxDescent(): number;
        get ascent(): number;
        get maxDecent(): number;
        get leading(): number;
        get fontRenderContext(): Internal.FontRenderContext;
        get maxAdvance(): number;
        get widths(): number[];
        get class(): Internal.Class<any>;
        get height(): number;
        get font(): java_.awt.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Drawable {
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        draw(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void
        draw3D(matrixStack: Internal.PoseStack): void
    }
    class TextureAtlasSprite implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPixelRGBA(arg0: number, arg1: number, arg2: number): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FilterOutputStream extends Internal.OutputStream {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        flush(): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static nullOutputStream(): Internal.OutputStream
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number[]): void
        write(arg0: number): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongStream$Builder extends Internal.LongConsumer {
        add(arg0: number): Internal.LongStream$Builder
        build(): Internal.LongStream
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        accept(arg0: number): void
    }
    interface BlockStateKJS {
        setDestroySpeedKJS(arg0: number): void
        setLightEmissionKJS(arg0: number): void
        setRequiresToolKJS(arg0: boolean): void
        setMaterialKJS(arg0: Internal.Material): void
    }
    abstract class Writer implements Internal.Appendable, Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        flush(): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static nullWriter(): Internal.Writer
        toString(): string
        close(): void
        write(arg0: string, arg1: number, arg2: number): void
        write(arg0: number): void
        write(arg0: string): void
        write(arg0: string[], arg1: number, arg2: number): void
        write(arg0: string[]): void
        notify(): void
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string): Internal.Writer
        append(arg0: string): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Writer
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TwoHandedAnimation {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setTwoHanded(arg0: boolean): void
        hashCode(): number
        isTwoHanded(): boolean
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get twoHanded(): boolean;
        get class(): Internal.Class<any>;
        set twoHanded(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AsynchronousChannel extends Internal.Channel {
        isOpen(): boolean
        close(): void
    }
    abstract class GraphicsConfigTemplate implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isGraphicsConfigSupported(arg0: Internal.GraphicsConfiguration): boolean
        hashCode(): number
        getBestConfiguration(arg0: Internal.GraphicsConfiguration[]): Internal.GraphicsConfiguration
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly UNNECESSARY : 3;
        static readonly PREFERRED : 2;
        static readonly REQUIRED : 1;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Enum <E> implements Internal.Constable, Internal.Comparable<E>, Internal.Serializable {
        getClass(): Internal.Class<any>
        getDeclaringClass(): Internal.Class<E>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        name(): string
        toString(): string
        compareTo(arg0: any): number
        compareTo(arg0: E): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<E>>
        notify(): void
        ordinal(): number
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<E>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Dist extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Dist
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Dist[]
        isClient(): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Dist): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dist>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Dist>
        isDedicatedServer(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DEDICATED_SERVER : Internal.Dist;
        static readonly CLIENT : Internal.Dist;
        get dedicatedServer(): boolean;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dist>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class FakeServerPlayerDataJS extends Internal.ServerPlayerDataJS {
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.ServerPlayerJS
        getPlayer(): Internal.PlayerJS<any>
        getName(): string
        notifyAll(): void
        getProfile(): Internal.GameProfile
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        notify(): void
        getMinecraftPlayer(): Internal.Player
        getMinecraftPlayer(): Internal.ServerPlayer
        hashCode(): number
        equals(arg0: any): boolean
        hasClientMod(): boolean
        toString(): string
        getData(): Internal.AttachedData
        player : Internal.ServerPlayer;
        get server(): Internal.ServerJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.ServerPlayer;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ProgressChange {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        write(buffer: Internal.FriendlyByteBuf): void
        notify(): void
        readonly file : Internal.QuestFile;
        origin : Internal.QuestObjectBase;
        reset : boolean;
        time : Internal.Date;
        notifications : boolean;
        player : Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceManagerReloadListener extends Internal.PreparableReloadListener {
    }
    interface RenderedImage {
        getTileHeight(): number
        getMinTileX(): number
        getTile(arg0: number, arg1: number): Internal.Raster
        getMinTileY(): number
        getTileWidth(): number
        getProperty(arg0: string): any
        getColorModel(): Internal.ColorModel
        getNumYTiles(): number
        getSources(): Internal.Vector<Internal.RenderedImage>
        getWidth(): number
        getTileGridXOffset(): number
        copyData(arg0: Internal.WritableRaster): Internal.WritableRaster
        getTileGridYOffset(): number
        getSampleModel(): Internal.SampleModel
        getHeight(): number
        getPropertyNames(): string[]
        getNumXTiles(): number
        getData(arg0: Internal.Rectangle): Internal.Raster
        getData(): Internal.Raster
        getMinX(): number
        getMinY(): number
    }
    class GameProfile {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        isLegacy(): boolean
        hashCode(): number
        notifyAll(): void
        getProperties(): Internal.PropertyMap
        equals(arg0: any): boolean
        getId(): Internal.UUID
        toString(): string
        notify(): void
        isComplete(): boolean
        get legacy(): boolean;
        get name(): string;
        get id(): Internal.UUID;
        get complete(): boolean;
        get class(): Internal.Class<any>;
        get properties(): Internal.PropertyMap;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DirectMethodHandleDesc extends Internal.MethodHandleDesc {
        owner(): Internal.ClassDesc
        invocationType(): Internal.MethodTypeDesc
        kind(): Internal.DirectMethodHandleDesc$Kind
        equals(arg0: any): boolean
        refKind(): number
        methodName(): string
        isOwnerInterface(): boolean
        lookupDescriptor(): string
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc
    }
    abstract class Image {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getProperty(arg0: string, arg1: Internal.ImageObserver): any
        notifyAll(): void
        getWidth(arg0: Internal.ImageObserver): number
        getCapabilities(arg0: Internal.GraphicsConfiguration): Internal.ImageCapabilities
        notify(): void
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image
        setAccelerationPriority(arg0: number): void
        getHeight(arg0: Internal.ImageObserver): number
        flush(): void
        hashCode(): number
        getSource(): Internal.ImageProducer
        equals(arg0: any): boolean
        getAccelerationPriority(): number
        toString(): string
        getGraphics(): Internal.Graphics
        static readonly SCALE_DEFAULT : 1;
        static readonly UndefinedProperty : any;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        get accelerationPriority(): number;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        set accelerationPriority(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorMobEffect {
        getType(): Internal.MobEffectCategory
    }
    interface CharacterIterator extends Internal.Cloneable {
        next(): string
        current(): string
        getIndex(): number
        previous(): string
        last(): string
        getEndIndex(): number
        setIndex(arg0: number): string
        clone(): any
        getBeginIndex(): number
        first(): string
    }
    interface ModuleFinder {
        find(arg0: string): Internal.Optional<Internal.ModuleReference>
        findAll(): Internal.Set<Internal.ModuleReference>
    }
    abstract class QuestObject extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        notify(): void
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        getRelativeProgressFromChildren(arg0: Internal.TeamData): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        getPath(): string
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        clearCachedData(): void
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        refreshJEI(): number
        editedFromGUI(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        getQuestChapter(): Internal.Chapter
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        getQuestFile(): Internal.QuestFile
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        getChildren(): Internal.Collection<Internal.QuestObject>
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getAltTitle(): Internal.Component
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        deleteSelf(): void
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        cacheProgress(): boolean
        disableToast : boolean;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DropTarget implements Internal.DropTargetListener, Internal.Serializable {
        removeDropTargetListener(arg0: Internal.DropTargetListener): void
        drop(arg0: Internal.DropTargetDropEvent): void
        getDropTargetContext(): Internal.DropTargetContext
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        dragEnter(arg0: Internal.DropTargetDragEvent): void
        notifyAll(): void
        setComponent(arg0: java_.awt.Component): void
        dropActionChanged(arg0: Internal.DropTargetDragEvent): void
        isActive(): boolean
        notify(): void
        addDropTargetListener(arg0: Internal.DropTargetListener): void
        setFlavorMap(arg0: Internal.FlavorMap): void
        getFlavorMap(): Internal.FlavorMap
        setActive(arg0: boolean): void
        addNotify(): void
        hashCode(): number
        equals(arg0: any): boolean
        removeNotify(): void
        toString(): string
        dragOver(arg0: Internal.DropTargetDragEvent): void
        getComponent(): java_.awt.Component
        dragExit(arg0: Internal.DropTargetEvent): void
        setDefaultActions(arg0: number): void
        getDefaultActions(): number
        get flavorMap(): Internal.FlavorMap;
        get component(): java_.awt.Component;
        get defaultActions(): number;
        get active(): boolean;
        get dropTargetContext(): Internal.DropTargetContext;
        get class(): Internal.Class<any>;
        set flavorMap(arg0: Internal.FlavorMap);
        set component(arg0: java_.awt.Component);
        set defaultActions(arg0: number);
        set active(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PrintJob {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        end(): void
        finalize(): void
        getGraphics(): Internal.Graphics
        getPageDimension(): Internal.Dimension
        getPageResolution(): number
        notify(): void
        lastPageFirst(): boolean
        get pageDimension(): Internal.Dimension;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        get pageResolution(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockItemBuilder extends Internal.ItemBuilder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        maxStackSize(v: number): Internal.ItemBuilder
        translationKey(key: string): Internal.BuilderBase
        color(index: number, c: number): Internal.ItemBuilder
        getBuilderType(): string
        displayName(name: string): Internal.BuilderBase
        newID(pre: string, post: string): ResourceLocation
        notifyAll(): void
        maxDamage(v: number): Internal.ItemBuilder
        tooltip(text: Internal.Component): Internal.ItemBuilder
        type(t: Internal.ItemType): Internal.ItemBuilder
        containerItem(id: string): Internal.ItemBuilder
        notify(): void
        subtypes(fn: (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>): Internal.ItemBuilder
        tier(t: string): Internal.ItemBuilder
        hashCode(): number
        getAttackSpeed(): number
        burnTime(v: number): Internal.ItemBuilder
        tag(tag: ResourceLocation): Internal.BuilderBase
        parentModel(m: string): Internal.ItemBuilder
        group(g: string): Internal.ItemBuilder
        attackDamage(f: number): Internal.ItemBuilder
        texture(tex: string): Internal.ItemBuilder
        food(b: (arg0: Internal.FoodBuilder) => void): Internal.ItemBuilder
        getMiningSpeed(): number
        miningSpeed(f: number): Internal.ItemBuilder
        unstackable(): Internal.ItemBuilder
        getAttackDamage(): number
        equals(arg0: any): boolean
        attackSpeed(f: number): Internal.ItemBuilder
        toString(): string
        glow(v: boolean): Internal.ItemBuilder
        rarity(v: Rarity): Internal.ItemBuilder
        createItemProperties(): Internal.Item$Properties
        toolTier : Internal.Tier;
        foodBuilder : Internal.FoodBuilder;
        defaultTags : Internal.Set<ResourceLocation>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Internal.Map<string, Internal.ArmorMaterial>;
        readonly id : ResourceLocation;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Internal.Map<string, Internal.Tier>;
        blockBuilder : Internal.BlockBuilder;
        attackDamageBaseline : number;
        blockItem : Internal.BlockItem;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Container extends Internal.Clearable {
    }
    interface AccessorModelBakery {
        getSpriteAtlasManager(): Internal.AtlasSet
    }
    abstract class FileChannel extends Internal.AbstractInterruptibleChannel implements Internal.SeekableByteChannel, Internal.GatheringByteChannel, Internal.ScatteringByteChannel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        transferFrom(arg0: Internal.ReadableByteChannel, arg1: number, arg2: number): number
        read(arg0: Internal.ByteBuffer, arg1: number): number
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        read(arg0: Internal.ByteBuffer): number
        read(arg0: Internal.ByteBuffer[]): number
        notifyAll(): void
        transferTo(arg0: number, arg1: number, arg2: Internal.WritableByteChannel): number
        notify(): void
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        tryLock(): Internal.FileLock
        isOpen(): boolean
        truncate(arg0: number): Internal.FileChannel
        truncate(arg0: number): Internal.SeekableByteChannel
        size(): number
        hashCode(): number
        equals(arg0: any): boolean
        lock(): Internal.FileLock
        lock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        toString(): string
        force(arg0: boolean): void
        position(arg0: number): Internal.FileChannel
        position(arg0: number): Internal.SeekableByteChannel
        position(): number
        close(): void
        write(arg0: Internal.ByteBuffer): number
        write(arg0: Internal.ByteBuffer, arg1: number): number
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        write(arg0: Internal.ByteBuffer[]): number
        map(arg0: Internal.FileChannel$MapMode, arg1: number, arg2: number): Internal.MappedByteBuffer
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.FileChannel
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.FileChannel
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DefaultedVertexConsumer implements Internal.VertexConsumer {
        getClass(): Internal.Class<any>
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SeekableByteChannel extends Internal.ByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        truncate(arg0: number): Internal.SeekableByteChannel
        size(): number
        position(): number
        position(arg0: number): Internal.SeekableByteChannel
        close(): void
        write(arg0: Internal.ByteBuffer): number
    }
    class Heightmap$Types extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Heightmap$Types
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Heightmap$Types[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Heightmap$Types): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Heightmap$Types>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Heightmap$Types>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly OCEAN_FLOOR : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING_NO_LEAVES : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE : Internal.Heightmap$Types;
        static readonly OCEAN_FLOOR_WG : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE_WG : Internal.Heightmap$Types;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Heightmap$Types>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeFluidState {
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean
    }
    class RewardTable extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        editedFromGUIOnServer(): void
        notify(): void
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getTitle(): Internal.Component
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        getPath(): string
        clearCachedData(): void
        getTotalWeight(includeEmpty: boolean): number
        getParentID(): number
        static parseCodeString(id: string): number
        refreshJEI(): number
        editedFromGUI(): void
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        getQuestChapter(): Internal.Chapter
        static getID(object: Internal.QuestObjectBase): number
        getQuestFile(): Internal.QuestFile
        onEditButtonClicked(gui: Internal.Runnable): void
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        addMouseOverText(list: Internal.TooltipList, includeWeight: boolean, includeEmpty: boolean): void
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getFilename(): string
        getAltTitle(): Internal.Component
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        deleteSelf(): void
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        emptyWeight : number;
        icon : Internal.ItemStack;
        title : string;
        lootSize : number;
        lootTableId : ResourceLocation;
        useTitle : boolean;
        readonly file : Internal.QuestFile;
        filename : string;
        lootCrate : Internal.LootCrate;
        invalid : boolean;
        readonly fakeQuest : Internal.Quest;
        static sendNotifications : Internal.Tristate;
        id : number;
        readonly rewards : Internal.List<Internal.WeightedReward>;
        hideTooltip : boolean;
        get path(): string;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DyeColor extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.Color {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRgbKJS(): number
        static valueOf(arg0: string): Internal.DyeColor
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.DyeColor[]
        static getColor(arg0: Internal.ItemStack): Internal.DyeColor
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DyeColor): number
        getSerializeKJS(): string
        getTag(): Internal.Tags$IOptionalNamedTag<Internal.Item>
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DyeColor>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.DyeColor>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        getHexKJS(): string
        createTextColorKJS(): Internal.TextColor
        getArgbKJS(): number
        toString(): string
        getFireworkColorKJS(): number
        specialEquals(o: any, shallow: boolean): boolean
        ordinal(): number
        static readonly WHITE : Internal.DyeColor;
        static readonly GRAY : Internal.DyeColor;
        static readonly BLUE : Internal.DyeColor;
        static readonly PURPLE : Internal.DyeColor;
        static readonly GREEN : Internal.DyeColor;
        static readonly RED : Internal.DyeColor;
        static readonly PINK : Internal.DyeColor;
        static readonly LIGHT_GRAY : Internal.DyeColor;
        static readonly LIGHT_BLUE : Internal.DyeColor;
        static readonly LIME : Internal.DyeColor;
        static readonly MAGENTA : Internal.DyeColor;
        static readonly BLACK : Internal.DyeColor;
        static readonly YELLOW : Internal.DyeColor;
        static readonly CYAN : Internal.DyeColor;
        static readonly BROWN : Internal.DyeColor;
        static readonly ORANGE : Internal.DyeColor;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get tag(): Internal.Tags$IOptionalNamedTag<Internal.Item>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DyeColor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Products$P9 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Paint extends Internal.Transparency {
        createContext(arg0: Internal.ColorModel, arg1: Internal.Rectangle, arg2: Internal.Rectangle2D, arg3: Internal.AffineTransform, arg4: Internal.RenderingHints): Internal.PaintContext
        getTransparency(): number
    }
    class NetworkInterface {
        getClass(): Internal.Class<any>
        getInterfaceAddresses(): Internal.List<Internal.InterfaceAddress>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getIndex(): number
        supportsMulticast(): boolean
        getSubInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        notifyAll(): void
        inetAddresses(): Internal.Stream<Internal.InetAddress>
        notify(): void
        isPointToPoint(): boolean
        isUp(): boolean
        hashCode(): number
        static getByName(arg0: string): Internal.NetworkInterface
        isLoopback(): boolean
        subInterfaces(): Internal.Stream<Internal.NetworkInterface>
        getParent(): Internal.NetworkInterface
        static getByIndex(arg0: number): Internal.NetworkInterface
        static getByInetAddress(arg0: Internal.InetAddress): Internal.NetworkInterface
        getMTU(): number
        static networkInterfaces(): Internal.Stream<Internal.NetworkInterface>
        getDisplayName(): string
        equals(arg0: any): boolean
        getHardwareAddress(): number[]
        toString(): string
        isVirtual(): boolean
        static getNetworkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        getInetAddresses(): Internal.Enumeration<Internal.InetAddress>
        get parent(): Internal.NetworkInterface;
        get hardwareAddress(): number[];
        get virtual(): boolean;
        get displayName(): string;
        get pointToPoint(): boolean;
        get interfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        get name(): string;
        get index(): number;
        get up(): boolean;
        get class(): Internal.Class<any>;
        get loopback(): boolean;
        get mTU(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Future <V> extends java_.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(): Internal.Future<V>
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        isDone(): boolean
        sync(): Internal.Future<V>
        syncUninterruptibly(): Internal.Future<V>
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isCancellable(): boolean
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        await(): Internal.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
    }
    abstract class IngredientAction extends Internal.IngredientActionFilter {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        checkFilter(index: number, stack: Internal.ItemStack): boolean
        static getRemaining(container: Internal.CraftingContainer, index: number, ingredientActions: Internal.List<Internal.IngredientAction>): Internal.ItemStack
        notifyAll(): void
        static parseList(json: Internal.JsonElement): Internal.List<Internal.IngredientAction>
        static filterOf(o: any): Internal.IngredientActionFilter
        notify(): void
        copyFrom(filter: Internal.IngredientActionFilter): void
        transform(arg0: Internal.ItemStack, arg1: number, arg2: Internal.CraftingContainer): Internal.ItemStack
        toJson(): Internal.JsonObject
        toJson(json: Internal.JsonObject): void
        static readList(buf: Internal.FriendlyByteBuf): Internal.List<Internal.IngredientAction>
        static writeList(buf: Internal.FriendlyByteBuf, list: Internal.List<Internal.IngredientAction>): void
        getType(): string
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static readonly FACTORY_MAP : Internal.Map<string, (arg0: Internal.JsonObject) => Internal.IngredientAction>;
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
        get type(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Item extends Internal.ForgeRegistryEntry<any> implements Internal.ItemLike, Internal.IForgeItem, Internal.IEnchantableItem, Internal.AccessorItem, Internal.ItemFTBL, Internal.ItemAccessor, Internal.IPlaceableItem, Internal.ItemKJS {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notifyAll(): void
        getId(): string
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getRenderPropertiesInternal(): any
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptPackInfo {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly displayName : Internal.Component;
        readonly namespace : string;
        readonly pathStart : string;
        readonly scripts : Internal.List<Internal.ScriptFileInfo>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInt2IntMap extends Internal.AbstractInt2IntFunction implements Internal.Int2IntMap, Internal.Serializable {
        getClass(): Internal.Class<any>
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: any, arg1: any): any
        replace(arg0: number, arg1: number): number
        replace(arg0: any, arg1: any, arg2: any): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        containsValue(arg0: number): boolean
        containsValue(arg0: any): boolean
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number
        mergeInt(arg0: number, arg1: number, arg2: java_.util.function_.IntBinaryOperator): number
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>
        entrySet(): Internal.Set<any>
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number
        notifyAll(): void
        values(): Internal.Collection<any>
        values(): Internal.IntCollection
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number
        replaceAll(arg0: (arg0: number, arg1: number) => number): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        remove(arg0: any): any
        remove(arg0: any): number
        remove(arg0: number): number
        remove(arg0: number, arg1: number): boolean
        remove(arg0: any, arg1: any): boolean
        notify(): void
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        hashCode(): number
        get(arg0: any): any
        get(arg0: any): number
        get(arg0: number): number
        putAll(arg0: Internal.Map<number, number>): void
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        apply(arg0: number): number
        forEach(arg0: (arg0: number, arg1: number) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        isEmpty(): boolean
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        toString(): string
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: any, arg1: any): any
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BufferBuilder extends Internal.DefaultedVertexConsumer implements Internal.BufferVertexConsumer, Internal.BufferBuilderExtension {
        getClass(): Internal.Class<any>
        flywheel$getVertices(): number
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        flywheel$injectForRender(arg0: Internal.ByteBuffer, arg1: Internal.VertexFormat, arg2: number): void
        notifyAll(): void
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        flywheel$freeBuffer(): void
        toString(): string
        getVertexFormat(): Internal.VertexFormat
        putBulkData(arg0: Internal.ByteBuffer): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
        flywheel$appendBufferUnsafe(arg0: Internal.ByteBuffer): void
        get vertexFormat(): Internal.VertexFormat;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MobSpawnSettings$MobSpawnCost {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CustomIngredientActionCallback {
        transform(arg0: string, arg1: number, arg2: Internal.InventoryJS): any
        transform(arg0: object, arg1: number, arg2: Internal.InventoryJS): any
        transform(arg0: Internal.ItemStackJS, arg1: number, arg2: Internal.InventoryJS): any
    }
    abstract class RenderStateShard implements Internal.RenderTypeAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2ShortFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        removeShort(arg0: any): number
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): number
        getShort(arg0: any): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IForgeModelState {
        getPartTransformation(arg0: any): Internal.Transformation
    }
    interface IntIterator extends Internal.PrimitiveIterator$OfInt {
        next(): any
        next(): number
        hasNext(): boolean
        skip(arg0: number): number
        nextInt(): number
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: (arg0: any) => void): void
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        remove(): void
    }
    interface Char2ByteFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class IntBuffer extends Internal.Buffer implements Internal.Comparable<Internal.IntBuffer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.IntBuffer
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.IntBuffer): number
        notify(): void
        asReadOnlyBuffer(): Internal.IntBuffer
        put(arg0: number[]): Internal.IntBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer
        put(arg0: number, arg1: number[]): Internal.IntBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        put(arg0: number, arg1: Internal.IntBuffer, arg2: number, arg3: number): Internal.IntBuffer
        put(arg0: Internal.IntBuffer): Internal.IntBuffer
        put(arg0: number, arg1: number): Internal.IntBuffer
        put(arg0: number): Internal.IntBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.Buffer
        slice(): Internal.IntBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.IntBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(): number
        get(arg0: number, arg1: number[]): Internal.IntBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        get(arg0: number[]): Internal.IntBuffer
        limit(arg0: number): Internal.IntBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.Buffer
        flip(): Internal.IntBuffer
        order(): Internal.ByteOrder
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.IntBuffer
        duplicate(): Internal.IntBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        static allocate(arg0: number): Internal.IntBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.IntBuffer
        mismatch(arg0: Internal.IntBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.Buffer
        reset(): Internal.IntBuffer
        toString(): string
        position(arg0: number): Internal.IntBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.IntBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        mark(): Internal.Buffer
        mark(): Internal.IntBuffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChronoLocalDateTime <D> extends Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDateTime<any>> {
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<D>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<D>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        isEqual(arg0: Internal.ChronoLocalDateTime<any>): boolean
        toLocalTime(): Internal.LocalTime
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: Internal.ChronoLocalDateTime<any>): number
        compareTo(arg0: any): number
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        getChronology(): Internal.Chronology
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        atZone(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        toInstant(arg0: Internal.ZoneOffset): Internal.Instant
        isBefore(arg0: Internal.ChronoLocalDateTime<any>): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<D>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<D>
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDateTime<D>
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDateTime<D>
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        toLocalDate(): D
        toEpochSecond(arg0: Internal.ZoneOffset): number
        equals(arg0: any): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        isAfter(arg0: Internal.ChronoLocalDateTime<any>): boolean
    }
    class ChronoUnit extends Internal.Enum<any> implements Internal.TemporalUnit {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ChronoUnit
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ChronoUnit[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChronoUnit): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChronoUnit>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ChronoUnit>
        isDurationEstimated(): boolean
        getDuration(): Internal.Duration
        hashCode(): number
        equals(arg0: any): boolean
        isTimeBased(): boolean
        name(): string
        addTo<R_>(arg0: R_, arg1: number): R_
        toString(): string
        isDateBased(): boolean
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number
        ordinal(): number
        isSupportedBy(arg0: Internal.Temporal): boolean
        static readonly FOREVER : Internal.ChronoUnit;
        static readonly MICROS : Internal.ChronoUnit;
        static readonly SECONDS : Internal.ChronoUnit;
        static readonly DECADES : Internal.ChronoUnit;
        static readonly MILLENNIA : Internal.ChronoUnit;
        static readonly DAYS : Internal.ChronoUnit;
        static readonly MILLIS : Internal.ChronoUnit;
        static readonly HALF_DAYS : Internal.ChronoUnit;
        static readonly MONTHS : Internal.ChronoUnit;
        static readonly YEARS : Internal.ChronoUnit;
        static readonly HOURS : Internal.ChronoUnit;
        static readonly WEEKS : Internal.ChronoUnit;
        static readonly NANOS : Internal.ChronoUnit;
        static readonly CENTURIES : Internal.ChronoUnit;
        static readonly MINUTES : Internal.ChronoUnit;
        static readonly ERAS : Internal.ChronoUnit;
        get duration(): Internal.Duration;
        get durationEstimated(): boolean;
        get timeBased(): boolean;
        get dateBased(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChronoUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number
        compare(arg0: any, arg1: any): number
        compare(arg0: number, arg1: number): number
        thenComparingLong(arg0: Internal.ToLongFunction<number>): Internal.Comparator<number>
        thenComparingInt(arg0: Internal.ToIntFunction<number>): Internal.Comparator<number>
        thenComparing(arg0: Internal.Comparator<number>): Internal.Comparator<number>
        thenComparing(arg0: Internal.LongComparator): Internal.LongComparator
        thenComparing<U_>(arg0: (arg0: number) => U_, arg1: Internal.Comparator<U_>): Internal.Comparator<number>
        thenComparing<U_>(arg0: (arg0: number) => U_): Internal.Comparator<number>
        thenComparingDouble(arg0: Internal.ToDoubleFunction<number>): Internal.Comparator<number>
        equals(arg0: any): boolean
        reversed(): Internal.LongComparator
        reversed(): Internal.Comparator<any>
    }
    class Products$P5 <F, T1, T2, T3, T4, T5> {
        t4(): Internal.App<F, T4>
        getClass(): Internal.Class<any>
        t5(): Internal.App<F, T5>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function5<T1, T2, T3, T4, T5, R>): Internal.App<F, R>
        notifyAll(): void
        notify(): void
        hashCode(): number
        and<T6, T7, T8>(arg0: Internal.Products$P3<F, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T6>(arg0: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        and<T6, T7>(arg0: Internal.Products$P2<F, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MinecraftAccess {
        getFontManager(): Internal.FontManager
    }
    interface DoubleToLongFunction {
        applyAsLong(arg0: number): number
    }
    class HierarchyEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getChangedParent(): java_.awt.Container
        getChanged(): java_.awt.Component
        notifyAll(): void
        getID(): number
        notify(): void
        paramString(): string
        getChangeFlags(): number
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        toString(): string
        getComponent(): java_.awt.Component
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly HIERARCHY_FIRST : 1400;
        static readonly HIERARCHY_CHANGED : 1400;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly ANCESTOR_RESIZED : 1402;
        static readonly HIERARCHY_LAST : 1402;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly PARENT_CHANGED : 1;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly SHOWING_CHANGED : 4;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly ANCESTOR_MOVED : 1401;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly DISPLAYABILITY_CHANGED : 2;
        get component(): java_.awt.Component;
        get changedParent(): java_.awt.Container;
        get changeFlags(): number;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get changed(): java_.awt.Component;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Thread implements Internal.Runnable {
        setName(arg0: string): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getThreadGroup(): Internal.ThreadGroup
        getName(): string
        static getAllStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>
        notifyAll(): void
        static onSpinWait(): void
        getId(): number
        run(): void
        notify(): void
        setContextClassLoader(arg0: Internal.ClassLoader): void
        static sleep(arg0: number): void
        static sleep(arg0: number, arg1: number): void
        getStackTrace(): Internal.StackTraceElement[]
        hashCode(): number
        isDaemon(): boolean
        static yield(): void
        interrupt(): void
        static enumerate(arg0: Internal.Thread[]): number
        join(): void
        join(arg0: number, arg1: number): void
        join(arg0: number): void
        suspend(): void
        static activeCount(): number
        resume(): void
        static currentThread(): Internal.Thread
        setUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void
        isInterrupted(): boolean
        static dumpStack(): void
        static setDefaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void
        start(): void
        static interrupted(): boolean
        getUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        checkAccess(): void
        static getDefaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        isAlive(): boolean
        setDaemon(arg0: boolean): void
        static holdsLock(arg0: any): boolean
        getState(): Internal.Thread$State
        stop(): void
        getContextClassLoader(): Internal.ClassLoader
        equals(arg0: any): boolean
        getPriority(): number
        countStackFrames(): number
        toString(): string
        setPriority(arg0: number): void
        static readonly MIN_PRIORITY : 1;
        static readonly MAX_PRIORITY : 10;
        static readonly NORM_PRIORITY : 5;
        get allStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>;
        get alive(): boolean;
        get priority(): number;
        get uncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get daemon(): boolean;
        get defaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get threadGroup(): Internal.ThreadGroup;
        get contextClassLoader(): Internal.ClassLoader;
        get name(): string;
        get id(): number;
        get stackTrace(): Internal.StackTraceElement[];
        get state(): Internal.Thread$State;
        get class(): Internal.Class<any>;
        set defaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        set contextClassLoader(arg0: Internal.ClassLoader);
        set name(arg0: string);
        set priority(arg0: number);
        set uncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EventsJS$ScriptEventHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RewardClaimType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        canClaim(): boolean
        static valueOf(name: string): Internal.RewardClaimType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.RewardClaimType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.RewardClaimType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RewardClaimType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.RewardClaimType>
        cantClaim(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        isClaimed(): boolean
        ordinal(): number
        static readonly CLAIMED : Internal.RewardClaimType;
        static readonly CAN_CLAIM : Internal.RewardClaimType;
        static readonly CANT_CLAIM : Internal.RewardClaimType;
        get claimed(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RewardClaimType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerPlayerJS extends Internal.PlayerJS<any> {
        getXpLevel(): number
        getLastAttackedEntity(): Internal.LivingEntityJS
        setY(y: number): void
        setX(x: number): void
        isOnScoreboardTeam(teamID: string): boolean
        isLiving(): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        paint(renderer: Internal.CompoundTag): void
        getOffHandItem(): Internal.ItemStackJS
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        setXpLevel(l: number): void
        getHasCustomName(): boolean
        ban(banner: string, reason: string, expiresInMillis: number): void
        runCommandSilent(command: string): number
        setSelectedSlot(index: number): void
        isBoss(): boolean
        getDistanceSq(x: number, y: number, z: number): number
        getDistanceSq(pos: BlockPos): number
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        setLegsArmorItem(item: string): void
        setLegsArmorItem(item: Internal.ItemStackJS): void
        setLegsArmorItem(item: object): void
        isAdvancementDone(id: ResourceLocation): boolean
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        setGameMode(mode: string): void
        isMiningBlock(): boolean
        setAbsorptionAmount(amount: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getType(): string
        setCustomNameAlwaysVisible(b: boolean): void
        addMotion(x: number, y: number, z: number): void
        isFake(): boolean
        setCreativeMode(mode: boolean): void
        getFallDistance(): number
        damageHeldItem(): void
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageHeldItem(hand: Hand, amount: number): void
        setOnFire(seconds: number): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        isUndead(): boolean
        getInventory(): Internal.InventoryJS
        getDistance(x: number, y: number, z: number): number
        getDistance(pos: BlockPos): number
        getReachDistance(): number
        getCustomName(): Internal.Text
        getStepHeight(): number
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        kick(reason: Internal.Component): void
        kick(): void
        getLastAttackedEntityTime(): number
        isMonster(): boolean
        addItemCooldown(item: Internal.Item, ticks: number): void
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        isOnGround(): boolean
        toString(): string
        isSilent(): boolean
        setXp(xp: number): void
        getMaxAirSupply(): number
        getName(): Internal.Text
        getFeetArmorItem(): Internal.ItemStackJS
        getHasClientMod(): boolean
        setStepHeight(stepHeight: number): void
        isWaterCreature(): boolean
        setPosition(x: number, y: number, z: number): void
        setPosition(block: Internal.BlockContainerJS): void
        closeInventory(): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        isOp(): boolean
        setMovementSpeed(speed: number): void
        isChild(): boolean
        setEquipment(slot: EquipmentSlot, item: string): void
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void
        setEquipment(slot: EquipmentSlot, item: object): void
        giveInHand(item: string): void
        giveInHand(item: Internal.ItemStackJS): void
        giveInHand(item: object): void
        getLegsArmorItem(): Internal.ItemStackJS
        isCreativeMode(): boolean
        getNoClip(): boolean
        getFullNBT(): Internal.CompoundTag
        setYaw(yaw: number): void
        getYaw(): number
        setNoGravity(noGravity: boolean): void
        setHeldItem(hand: Hand, item: string): void
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void
        setHeldItem(hand: Hand, item: object): void
        getRevengeTimer(): number
        notifyAll(): void
        unlockAdvancement(id: ResourceLocation): void
        getId(): Internal.UUID
        addXPLevels(l: number): void
        getOpenInventory(): Internal.AbstractContainerMenu
        hashCode(): number
        getChestArmorItem(): Internal.ItemStackJS
        isFrame(): boolean
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        setChestArmorItem(item: string): void
        setChestArmorItem(item: Internal.ItemStackJS): void
        setChestArmorItem(item: object): void
        getCustomNameAlwaysVisible(): boolean
        addXP(xp: number): void
        getMainHandItem(): Internal.ItemStackJS
        setHealth(hp: number): void
        getBlock(): Internal.BlockContainerJS
        isElytraFlying(): boolean
        isInWater(): boolean
        dismountRidingEntity(): void
        isSleeping(): boolean
        getPotionEffects(): Internal.EntityPotionEffectsJS
        swingArm(hand: Hand): void
        isInvulnerable(): boolean
        revokeAdvancement(id: ResourceLocation): void
        setHeadArmorItem(item: string): void
        setHeadArmorItem(item: Internal.ItemStackJS): void
        setHeadArmorItem(item: object): void
        isPeacefulCreature(): boolean
        getMouseItem(): Internal.ItemStackJS
        getMotionZ(): number
        getMotionX(): number
        getMotionY(): number
        sendData(channel: string, data: Internal.CompoundTag): void
        getRevengeTarget(): Internal.LivingEntityJS
        getTags(): Internal.Set<string>
        setInvisible(invisible: boolean): void
        getIdleTime(): number
        getMovementSpeed(): number
        addFood(f: number, m: number): void
        getHealth(): number
        getServer(): Internal.ServerJS
        setFeetArmorItem(item: string): void
        setFeetArmorItem(item: Internal.ItemStackJS): void
        setFeetArmorItem(item: object): void
        give(item: string): void
        give(item: Internal.ItemStackJS): void
        give(item: object): void
        setMaxHealth(hp: number): void
        setSpawnLocation(c: Internal.BlockContainerJS): void
        isSpectator(): boolean
        getDisplayName(): Internal.Text
        getXp(): number
        addExhaustion(exhaustion: number): void
        setOffHandItem(item: string): void
        setOffHandItem(item: Internal.ItemStackJS): void
        setOffHandItem(item: object): void
        getFoodLevel(): number
        isInvisible(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaxHealth(): number
        isUnderWater(): boolean
        getHeldItem(hand: Hand): Internal.ItemStackJS
        getEyeHeight(): number
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS
        notify(): void
        setAirSupply(air: number): void
        removePassengers(): void
        isOnLadder(): boolean
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        boostElytraFlight(): void
        getData(): Internal.AttachedData
        getLastDamageSource(): Internal.DamageSourceJS
        setStatusMessage(message: Internal.Component): void
        isSwimming(): boolean
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        equals(arg0: any): boolean
        isPassenger(e: Internal.EntityJS): boolean
        getClass(): Internal.Class<any>
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        setFallDistance(fallDistance: number): void
        sendInventoryUpdate(): void
        setCustomName(name: Internal.Component): void
        setMainHandItem(item: string): void
        setMainHandItem(item: Internal.ItemStackJS): void
        setMainHandItem(item: object): void
        tell(message: Internal.Component): void
        getTeamId(): string
        setNoClip(noClip: boolean): void
        setRevengeTarget(target: Internal.LivingEntityJS): void
        getAirSupply(): number
        setFullNBT(nbt: Internal.CompoundTag): void
        getAttackingEntity(): Internal.LivingEntityJS
        isHoldingInAnyHand(ingredient: any): boolean
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageEquipment(slot: EquipmentSlot, amount: number): void
        damageEquipment(slot: EquipmentSlot): void
        isAlive(): boolean
        getHeadArmorItem(): Internal.ItemStackJS
        setMouseItem(item: string): void
        setMouseItem(item: Internal.ItemStackJS): void
        setMouseItem(item: object): void
        isPlayer(): boolean
        getStats(): Internal.PlayerStatsJS
        getAbsorptionAmount(): number
        isCrouching(): boolean
        getSpawnLocation(): Internal.BlockContainerJS
        getTicksExisted(): number
        getStages(): Internal.Stages
        setSilent(isSilent: boolean): void
        heal(hp: number): void
        setMotionZ(z: number): void
        setMotionY(y: number): void
        setMotionX(x: number): void
        isAmbientCreature(): boolean
        rayTrace(): Internal.RayTraceResultJS
        rayTrace(distance: number): Internal.RayTraceResultJS
        getSelectedSlot(): number
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean
        getX(): number
        getY(): number
        spawn(): void
        getZ(): number
        setFoodLevel(foodLevel: number): void
        getNoGravity(): boolean
        readonly server : Internal.ServerJS;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.ServerPlayer;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get movementSpeed(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get maxHealth(): number;
        get id(): Internal.UUID;
        get pitch(): number;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get noClip(): boolean;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get revengeTimer(): number;
        get displayName(): Internal.Text;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get hasClientMod(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get spawnLocation(): Internal.BlockContainerJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get sleeping(): boolean;
        get airSupply(): number;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get op(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: string);
        set mainHandItem(item: Internal.ItemStackJS);
        set mainHandItem(item: object);
        set invisible(invisible: boolean);
        set creativeMode(mode: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: string);
        set legsArmorItem(item: Internal.ItemStackJS);
        set legsArmorItem(item: object);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: string);
        set headArmorItem(item: Internal.ItemStackJS);
        set headArmorItem(item: object);
        set pitch(pitch: number);
        set motionZ(z: number);
        set spawnLocation(c: Internal.BlockContainerJS);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set feetArmorItem(item: string);
        set feetArmorItem(item: Internal.ItemStackJS);
        set feetArmorItem(item: object);
        set health(hp: number);
        set offHandItem(item: string);
        set offHandItem(item: Internal.ItemStackJS);
        set offHandItem(item: object);
        set chestArmorItem(item: string);
        set chestArmorItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: object);
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component);
        set yaw(yaw: number);
        set glowing(glowing: boolean);
        set mouseItem(item: string);
        set mouseItem(item: Internal.ItemStackJS);
        set mouseItem(item: object);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set gameMode(mode: string);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Point2D implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getX(): number
        getY(): number
        distance(arg0: Internal.Point2D): number
        distance(arg0: number, arg1: number): number
        static distance(arg0: number, arg1: number, arg2: number, arg3: number): number
        setLocation(arg0: number, arg1: number): void
        setLocation(arg0: Internal.Point2D): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        static distanceSq(arg0: number, arg1: number, arg2: number, arg3: number): number
        distanceSq(arg0: Internal.Point2D): number
        distanceSq(arg0: number, arg1: number): number
        notify(): void
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        set location(arg0: Internal.Point2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Stages {
        add(stage: string): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        set(stage: string, enabled: boolean): boolean
        getAll(): Internal.Collection<string>
        static added(event: (arg0: Internal.StageChangeEvent) => void): void
        notifyAll(): void
        replace(stages: Internal.Collection<string>): void
        clear(): boolean
        static invokeAdded(stages: Internal.Stages, stage: string): void
        toggle(stage: string): boolean
        addNoUpdate(arg0: string): boolean
        sync(): void
        notify(): void
        remove(stage: string): boolean
        static removed(event: (arg0: Internal.StageChangeEvent) => void): void
        hashCode(): number
        equals(arg0: any): boolean
        static get(player: Internal.Player): Internal.Stages
        toString(): string
        static invokeRemoved(stages: Internal.Stages, stage: string): void
        has(stage: string): boolean
        static overrideCreation(event: (arg0: Internal.StageCreationEvent) => void): void
        removeNoUpdate(arg0: string): boolean
        readonly player : Internal.Player;
        get all(): Internal.Collection<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EvaluatorException extends Internal.RhinoException {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocalizedMessage(): string
        getScriptStack(limit: number, hideFunction: string): any[]
        getScriptStack(): any[]
        notifyAll(): void
        initColumnNumber(columnNumber: number): void
        getCause(): Internal.Throwable
        notify(): void
        getScriptStackTrace(limit: number, functionName: string): string
        getScriptStackTrace(): string
        addSuppressed(arg0: Internal.Throwable): void
        getStackTrace(): Internal.StackTraceElement[]
        columnNumber(): number
        hashCode(): number
        getSuppressed(): Internal.Throwable[]
        details(): string
        printStackTrace(s: Internal.PrintWriter): void
        printStackTrace(s: Internal.PrintStream): void
        printStackTrace(): void
        initSourceName(sourceName: string): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        initLineSource(lineSource: string): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        lineSource(): string
        equals(arg0: any): boolean
        initLineNumber(lineNumber: number): void
        toString(): string
        sourceName(): string
        lineNumber(): number
        fillInStackTrace(): Internal.Throwable
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function <K, V> extends java_.util.function_.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V
        apply(arg0: K): V
        containsKey(arg0: any): boolean
        get(arg0: any): V
        clear(): void
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
    }
    class AccessibleStateSet {
        add(arg0: Internal.AccessibleState): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        contains(arg0: Internal.AccessibleState): boolean
        addAll(arg0: Internal.AccessibleState[]): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toArray(): Internal.AccessibleState[]
        clear(): void
        toString(): string
        notify(): void
        remove(arg0: Internal.AccessibleState): boolean
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IForgeMobEffect {
        getCurativeItems(): Internal.List<Internal.ItemStack>
        getSortOrder(arg0: Internal.MobEffectInstance): number
    }
    class Throwable implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        printStackTrace(): void
        printStackTrace(arg0: Internal.PrintStream): void
        printStackTrace(arg0: Internal.PrintWriter): void
        getLocalizedMessage(): string
        notifyAll(): void
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        getCause(): Internal.Throwable
        notify(): void
        addSuppressed(arg0: Internal.Throwable): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        getStackTrace(): Internal.StackTraceElement[]
        hashCode(): number
        equals(arg0: any): boolean
        getSuppressed(): Internal.Throwable[]
        toString(): string
        fillInStackTrace(): Internal.Throwable
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Pattern implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        splitAsStream(arg0: Internal.CharSequence): Internal.Stream<string>
        pattern(): string
        flags(): number
        asMatchPredicate(): (arg0: string) => boolean
        matcher(arg0: Internal.CharSequence): Internal.Matcher
        static matches(arg0: string, arg1: Internal.CharSequence): boolean
        notify(): void
        static quote(arg0: string): string
        split(arg0: Internal.CharSequence, arg1: number): string[]
        split(arg0: Internal.CharSequence): string[]
        static compile(arg0: string): Internal.Pattern
        static compile(arg0: string, arg1: number): Internal.Pattern
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        asPredicate(): (arg0: string) => boolean
        static readonly DOTALL : 32;
        static readonly UNICODE_CASE : 64;
        static readonly LITERAL : 16;
        static readonly UNICODE_CHARACTER_CLASS : 256;
        static readonly CASE_INSENSITIVE : 2;
        static readonly CANON_EQ : 128;
        static readonly COMMENTS : 4;
        static readonly UNIX_LINES : 1;
        static readonly MULTILINE : 8;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2ShortFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface BiConsumer <T, U> {
        andThen(arg0: (arg0: T, arg1: U) => void): (arg0: T, arg1: U) => void
        accept(arg0: T, arg1: U): void
    }
    class ScriptType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isServer(): boolean
        static valueOf(name: string): Internal.ScriptType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ScriptType[]
        isClient(): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ScriptType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ScriptType>>
        notify(): void
        getLogFile(): Internal.Path
        getDeclaringClass(): Internal.Class<Internal.ScriptType>
        hashCode(): number
        equals(arg0: any): boolean
        static of(level: Internal.LevelReader): Internal.ScriptType
        name(): string
        toString(): string
        ordinal(): number
        readonly console : Internal.ConsoleJS;
        readonly manager : () => Internal.ScriptManager;
        static readonly SERVER : Internal.ScriptType;
        readonly executor : Internal.ExecutorService;
        readonly warnings : Internal.List<string>;
        static readonly STARTUP : Internal.ScriptType;
        static readonly CLIENT : Internal.ScriptType;
        readonly errors : Internal.List<string>;
        get server(): boolean;
        get logFile(): Internal.Path;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ScriptType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ContentHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getContent(arg0: Internal.URLConnection): any
        getContent(arg0: Internal.URLConnection, arg1: Internal.Class[]): any
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface List <E> extends Internal.Collection<E> {
        replaceAll(arg0: (arg0: any) => any): void
        remove(arg0: any): boolean
        remove(arg0: number): E
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        get(arg0: number): E
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        listIterator(arg0: number): Internal.ListIterator<E>
        listIterator(): Internal.ListIterator<E>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    class ModuleDescriptor$Version implements Internal.Comparable<Internal.ModuleDescriptor$Version> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static parse(arg0: string): Internal.ModuleDescriptor$Version
        compareTo(arg0: Internal.ModuleDescriptor$Version): number
        compareTo(arg0: any): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Comparator <T> {
        compare(arg0: T, arg1: T): number
        thenComparingInt(arg0: Internal.ToIntFunction<T>): Internal.Comparator<T>
        thenComparingDouble(arg0: Internal.ToDoubleFunction<T>): Internal.Comparator<T>
        thenComparingLong(arg0: Internal.ToLongFunction<T>): Internal.Comparator<T>
        thenComparing(arg0: Internal.Comparator<T>): Internal.Comparator<T>
        thenComparing<U>(arg0: (arg0: T) => U, arg1: Internal.Comparator<U>): Internal.Comparator<T>
        thenComparing<U>(arg0: (arg0: T) => U): Internal.Comparator<T>
        equals(arg0: any): boolean
        reversed(): Internal.Comparator<T>
    }
    class MultipartBlockStateGenerator$Part {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        model(s: string): Internal.VariantBlockStateGenerator$Model
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BufferedImage extends Internal.Image implements Internal.WritableRenderedImage, Internal.Transparency {
        getMinTileX(): number
        getClass(): Internal.Class<any>
        getMinTileY(): number
        isTileWritable(arg0: number, arg1: number): boolean
        setRGB(arg0: number, arg1: number, arg2: number): void
        setRGB(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number, arg6: number): void
        coerceData(arg0: boolean): void
        getNumYTiles(): number
        getSampleModel(): Internal.SampleModel
        getWritableTile(arg0: number, arg1: number): Internal.WritableRaster
        removeTileObserver(arg0: Internal.TileObserver): void
        getPropertyNames(): string[]
        getNumXTiles(): number
        getRGB(arg0: number, arg1: number): number
        getRGB(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number, arg6: number): number[]
        getTile(arg0: number, arg1: number): Internal.Raster
        getTransparency(): number
        getType(): number
        getSource(): Internal.ImageProducer
        getMinX(): number
        getMinY(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getTileWidth(): number
        notifyAll(): void
        getSources(): Internal.Vector<Internal.RenderedImage>
        getWidth(): number
        getWidth(arg0: Internal.ImageObserver): number
        addTileObserver(arg0: Internal.TileObserver): void
        getTileGridXOffset(): number
        notify(): void
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image
        getWritableTileIndices(): Internal.Point[]
        getHeight(arg0: Internal.ImageObserver): number
        getHeight(): number
        flush(): void
        hashCode(): number
        getAccelerationPriority(): number
        createGraphics(): Internal.Graphics2D
        getGraphics(): Internal.Graphics
        getData(arg0: Internal.Rectangle): Internal.Raster
        getData(): Internal.Raster
        getAlphaRaster(): Internal.WritableRaster
        getRaster(): Internal.WritableRaster
        getTileHeight(): number
        getSubimage(arg0: number, arg1: number, arg2: number, arg3: number): Internal.BufferedImage
        getProperty(arg0: string, arg1: Internal.ImageObserver): any
        getProperty(arg0: string): any
        getColorModel(): Internal.ColorModel
        setData(arg0: Internal.Raster): void
        hasTileWriters(): boolean
        getCapabilities(arg0: Internal.GraphicsConfiguration): Internal.ImageCapabilities
        isAlphaPremultiplied(): boolean
        copyData(arg0: Internal.WritableRaster): Internal.WritableRaster
        setAccelerationPriority(arg0: number): void
        getTileGridYOffset(): number
        equals(arg0: any): boolean
        toString(): string
        releaseWritableTile(arg0: number, arg1: number): void
        static readonly TYPE_3BYTE_BGR : 5;
        static readonly TYPE_USHORT_565_RGB : 8;
        static readonly TYPE_INT_ARGB_PRE : 3;
        static readonly TYPE_USHORT_555_RGB : 9;
        static readonly TYPE_USHORT_GRAY : 11;
        static readonly BITMASK : 2;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly TYPE_BYTE_INDEXED : 13;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        static readonly TYPE_4BYTE_ABGR : 6;
        static readonly TYPE_INT_ARGB : 2;
        static readonly OPAQUE : 1;
        static readonly SCALE_DEFAULT : 1;
        static readonly TYPE_CUSTOM : 0;
        static readonly TYPE_INT_RGB : 1;
        static readonly TYPE_INT_BGR : 4;
        static readonly TRANSLUCENT : 3;
        static readonly UndefinedProperty : any;
        static readonly TYPE_BYTE_GRAY : 10;
        static readonly TYPE_4BYTE_ABGR_PRE : 7;
        static readonly TYPE_BYTE_BINARY : 12;
        get numXTiles(): number;
        get sources(): Internal.Vector<Internal.RenderedImage>;
        get data(): Internal.Raster;
        get alphaPremultiplied(): boolean;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get type(): number;
        get accelerationPriority(): number;
        get colorModel(): Internal.ColorModel;
        get class(): Internal.Class<any>;
        get tileGridXOffset(): number;
        get writableTileIndices(): Internal.Point[];
        get height(): number;
        get raster(): Internal.WritableRaster;
        get tileGridYOffset(): number;
        get tileWidth(): number;
        get minTileX(): number;
        get minTileY(): number;
        get minY(): number;
        get minX(): number;
        get propertyNames(): string[];
        get transparency(): number;
        get width(): number;
        get numYTiles(): number;
        get sampleModel(): Internal.SampleModel;
        get alphaRaster(): Internal.WritableRaster;
        get tileHeight(): number;
        set accelerationPriority(arg0: number);
        set data(arg0: Internal.Raster);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MATagRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiomeManager$NoiseBiomeSource {
    }
    class ModelGenerator {
        getClass(): Internal.Class<any>
        parent(s: string): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        textures(json: Internal.JsonObject): void
        hashCode(): number
        texture(name: string, texture: string): void
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        element(consumer: (arg0: Internal.ModelGenerator$Element) => void): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Month extends Internal.Enum<any> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getClass(): Internal.Class<any>
        minus(arg0: number): Internal.Month
        firstMonthOfQuarter(): Internal.Month
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        firstDayOfYear(arg0: boolean): number
        notifyAll(): void
        minLength(): number
        static values(): Internal.Month[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Month): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Month>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Month>
        hashCode(): number
        static of(arg0: number): Internal.Month
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.Month
        static valueOf(arg0: string): Internal.Month
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        length(arg0: boolean): number
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number): Internal.Month
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        name(): string
        toString(): string
        maxLength(): number
        ordinal(): number
        static readonly JANUARY : Internal.Month;
        static readonly JUNE : Internal.Month;
        static readonly MAY : Internal.Month;
        static readonly OCTOBER : Internal.Month;
        static readonly DECEMBER : Internal.Month;
        static readonly MARCH : Internal.Month;
        static readonly FEBRUARY : Internal.Month;
        static readonly AUGUST : Internal.Month;
        static readonly JULY : Internal.Month;
        static readonly SEPTEMBER : Internal.Month;
        static readonly NOVEMBER : Internal.Month;
        static readonly APRIL : Internal.Month;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.Month>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FileStore {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getUsableSpace(): number
        notifyAll(): void
        type(): string
        notify(): void
        getTotalSpace(): number
        getAttribute(arg0: string): any
        isReadOnly(): boolean
        getBlockSize(): number
        hashCode(): number
        supportsFileAttributeView(arg0: Internal.Class<Internal.FileAttributeView>): boolean
        supportsFileAttributeView(arg0: string): boolean
        equals(arg0: any): boolean
        name(): string
        toString(): string
        getUnallocatedSpace(): number
        getFileStoreAttributeView<V>(arg0: Internal.Class<V>): V
        get unallocatedSpace(): number;
        get readOnly(): boolean;
        get usableSpace(): number;
        get totalSpace(): number;
        get class(): Internal.Class<any>;
        get blockSize(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Either <L, R> implements Internal.App<Internal.Either$Mu<R>, L> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        swap(): Internal.Either<R, L>
        notifyAll(): void
        mapBoth<C_, D_>(arg0: (arg0: L) => C_, arg1: (arg0: R) => D_): Internal.Either<C_, D_>
        ifLeft(arg0: (arg0: L) => void): Internal.Either<L, R>
        static right<L_, R_>(arg0: R_): Internal.Either<L_, R_>
        right(): Internal.Optional<R>
        notify(): void
        ifRight(arg0: (arg0: R) => void): Internal.Either<L, R>
        orThrow(): L
        flatMap<L2_>(arg0: (arg0: L) => Internal.Either<L2_, R>): Internal.Either<L2_, R>
        mapRight<T_>(arg0: (arg0: R) => T_): Internal.Either<L, T_>
        left(): Internal.Optional<L>
        static left<L_, R_>(arg0: L_): Internal.Either<L_, R_>
        hashCode(): number
        static unbox<L_, R_>(arg0: Internal.App<Internal.Either$Mu<R_>, L_>): Internal.Either<L_, R_>
        equals(arg0: any): boolean
        mapLeft<T_>(arg0: (arg0: L) => T_): Internal.Either<T_, R>
        toString(): string
        map<T_>(arg0: (arg0: L) => T_, arg1: (arg0: R) => T_): T_
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GatheringByteChannel extends Internal.WritableByteChannel {
        isOpen(): boolean
        close(): void
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        write(arg0: Internal.ByteBuffer[]): number
        write(arg0: Internal.ByteBuffer): number
    }
    interface PrimitiveIterator$OfLong extends Internal.PrimitiveIterator<number, Internal.LongConsumer> {
        next(): number
        next(): any
        hasNext(): boolean
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: Internal.LongConsumer): void
        nextLong(): number
        remove(): void
    }
    interface ClassShutter {
        visibleToScripts(arg0: string, arg1: number): boolean
    }
    interface ChannelProgressiveFuture extends Internal.ChannelFuture, Internal.ProgressiveFuture<void> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>
        getNow(): void
        channel(): io.netty.channel.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): Internal.Future<void>
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>
        isDone(): boolean
        sync(): Internal.ChannelProgressiveFuture
        sync(): Internal.ChannelFuture
        sync(): Internal.Future<void>
        sync(): Internal.ProgressiveFuture<void>
        isVoid(): boolean
        syncUninterruptibly(): Internal.ChannelProgressiveFuture
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): Internal.Future<void>
        syncUninterruptibly(): Internal.ProgressiveFuture<void>
        get(): void
        get(arg0: number, arg1: Internal.TimeUnit): void
        isCancellable(): boolean
        await(): Internal.ChannelProgressiveFuture
        await(): Internal.ChannelFuture
        await(): Internal.Future<void>
        await(): Internal.ProgressiveFuture<void>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>
    }
    interface AccessorLivingEntity {
        setUseItemRemaining(arg0: number): void
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
    }
    abstract class ChunkAccess implements Internal.BlockGetter, Internal.BiomeManager$NoiseBiomeSource, Internal.FeatureAccess {
        getClass(): Internal.Class<any>
        getWorldForge(): Internal.LevelAccessor
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        localvar$bja000$modifyHeightmapType(arg0: Internal.Heightmap$Types): Internal.Heightmap$Types
        notify(): void
        get worldForge(): Internal.LevelAccessor;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NarrationSupplier {
    }
    class PainterObjectStorage {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getObject(key: string): Internal.PainterObject
        notifyAll(): void
        clear(): void
        handle(root: Internal.CompoundTag): void
        notify(): void
        remove(id: string): void
        createScreenObjects(): any[]
        createWorldObjects(): any[]
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getObjects(): Internal.Collection<Internal.PainterObject>
        get objects(): Internal.Collection<Internal.PainterObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Constable {
        describeConstable(): Internal.Optional<Internal.ConstantDesc>
    }
    interface MutableComponent extends Internal.Component {
        getString(): string
    }
    class KeyCompressor <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        decompress(arg0: number): T
        size(): number
        compress(arg0: T): number
        compress(arg0: string): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelInboundHandler extends Internal.ChannelHandler {
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
    }
    class ArsNouveauEnchantingApparatusRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Property {
        getClass(): Internal.Class<any>
        getValue(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getSignature(): string
        toString(): string
        isSignatureValid(arg0: Internal.PublicKey): boolean
        notify(): void
        hasSignature(): boolean
        get signature(): string;
        get name(): string;
        get class(): Internal.Class<any>;
        get value(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Enum$EnumDesc <E> extends Internal.DynamicConstantDesc<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc
        bootstrapMethod(): Internal.DirectMethodHandleDesc
        constantName(): string
        notifyAll(): void
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): E
        notify(): void
        constantType(): Internal.ClassDesc
        hashCode(): number
        equals(arg0: any): boolean
        bootstrapArgs(): Internal.ConstantDesc[]
        static of<E_>(arg0: Internal.ClassDesc, arg1: string): Internal.Enum$EnumDesc<E_>
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        toString(): string
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PathIterator {
        next(): void
        getWindingRule(): number
        currentSegment(arg0: number[]): number
        currentSegment(arg0: number[]): number
        isDone(): boolean
    }
    class ClientTeamManager {
        getClass(): Internal.Class<any>
        init(self: Internal.UUID, messages: Internal.List<Internal.TeamMessage>): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(id: Internal.UUID): Internal.Component
        hashCode(): number
        getTeam(id: Internal.UUID): Internal.ClientTeam
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getId(): Internal.UUID
        getKnownPlayer(id: Internal.UUID): Internal.KnownClientPlayer
        write(buffer: Internal.FriendlyByteBuf, now: number): void
        notify(): void
        readonly knownPlayers : Internal.Map<Internal.UUID, Internal.KnownClientPlayer>;
        selfTeam : Internal.ClientTeam;
        invalid : boolean;
        static INSTANCE : Internal.ClientTeamManager;
        readonly teamMap : Internal.Map<Internal.UUID, Internal.ClientTeam>;
        selfKnownPlayer : Internal.KnownClientPlayer;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Vector4f {
        setW(arg0: number): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setY(arg0: number): void
        set(arg0: number[]): void
        setX(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        setZ(arg0: number): void
        notify(): void
        get class(): Internal.Class<any>;
        set w(arg0: number);
        set x(arg0: number);
        set y(arg0: number);
        set z(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Stroke {
        createStrokedShape(arg0: Internal.Shape): Internal.Shape
    }
    interface LogBuilder {
        withLocation(location: Internal.StackTraceElement): Internal.LogBuilder
        withLocation(): Internal.LogBuilder
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        log(message: string, p0: any, p1: any, p2: any, p3: any): void
        log(message: string, p0: any): void
        log(): void
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        log(messageSupplier: org.apache.logging.log4j.util.Supplier<org.apache.logging.log4j.message.Message>): void
        log(message: org.apache.logging.log4j.message.Message): void
        log(message: string, params: org.apache.logging.log4j.util.Supplier<any>[]): void
        log(message: string, params: any[]): void
        log(message: string): void
        log(message: string, p0: any, p1: any, p2: any): void
        log(message: string, p0: any, p1: any): void
        log(message: Internal.CharSequence): void
        log(message: any): void
        withMarker(marker: Internal.Marker): Internal.LogBuilder
        withThrowable(throwable: Internal.Throwable): Internal.LogBuilder
    }
    interface IntToDoubleFunction {
        applyAsDouble(arg0: number): number
    }
    class LightTexture implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ToIntFunction <T> {
        applyAsInt(arg0: T): number
    }
    interface IFactionVillage {
        getGuardSuperClass(): Internal.Class<Internal.Mob>
        isBanner(arg0: Internal.ItemStack): boolean
        build(): Internal.IFactionVillage
        getCaptureEntries(): Internal.List<Internal.CaptureEntityEntry>
        getBadOmenEffect(): Internal.MobEffect
        getFactionVillageProfession(): Internal.VillagerProfession
        getTotemTopBlock(arg0: boolean): Internal.Block
        getBanner(): Internal.ItemStack
        getTaskMasterEntity(): Internal.EntityType<Internal.ITaskMasterEntity>
    }
    abstract class Screen extends Internal.AbstractContainerEventHandler implements Internal.Widget, Internal.ScreenAccessor, Internal.AccessScreen, Internal.AccessorScreen {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void
        handler$zcd000$getTooltipFromItem(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void
        notifyAll(): void
        getRenderables(): Internal.List<any>
        getMinecraft(): Internal.Minecraft
        notify(): void
        balm_getNarratables(): Internal.List<any>
        balm_getChildren(): Internal.List<any>
        balm_getRenderables(): Internal.List<any>
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getNarratables(): Internal.List<any>
        tooltipFont : Internal.Font;
        get minecraft(): Internal.Minecraft;
        get renderables(): Internal.List<any>;
        get narratables(): Internal.List<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Format implements Internal.Serializable, Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        formatToCharacterIterator(arg0: any): Internal.AttributedCharacterIterator
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        format(arg0: any): string
        format(arg0: any, arg1: Internal.StringBuffer, arg2: Internal.FieldPosition): Internal.StringBuffer
        clone(): any
        toString(): string
        notify(): void
        parseObject(arg0: string, arg1: Internal.ParsePosition): any
        parseObject(arg0: string): any
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RewardType$GuiProvider {
        openCreationGui(arg0: Internal.Runnable, arg1: Internal.Quest, arg2: (arg0: Internal.Reward) => void): void
    }
    interface Packet <T> {
    }
    class IntSummaryStatistics implements java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMax(): number
        notifyAll(): void
        getAverage(): number
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        notify(): void
        accept(arg0: number): void
        getMin(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getCount(): number
        getSum(): number
        combine(arg0: Internal.IntSummaryStatistics): void
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NarratableEntry extends Internal.NarrationSupplier {
    }
    interface LongIterable extends Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>
        iterator(): Internal.LongIterator
        longIterator(): Internal.LongIterator
        longSpliterator(): Internal.LongSpliterator
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.LongSpliterator
        forEach(arg0: Internal.LongConsumer): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: (arg0: any) => void): void
    }
    class Env extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toPlatform(): Internal.Dist
        static valueOf(name: string): Internal.Env
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Env[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Env): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Env>>
        notify(): void
        static fromPlatform(type: any): Internal.Env
        getDeclaringClass(): Internal.Class<Internal.Env>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SERVER : Internal.Env;
        static readonly CLIENT : Internal.Env;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Env>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FlavorEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractMultimap <K, V> implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>
        containsEntry(arg0: any, arg1: any): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        keys(): Internal.Multiset<K>
        asMap(): Internal.Map<K, Internal.Collection<V>>
        notifyAll(): void
        values(): Internal.Collection<V>
        clear(): void
        isEmpty(): boolean
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        get(arg0: K): Internal.Collection<V>
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: any): boolean
        toString(): string
        keySet(): Internal.Set<K>
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class OutputStream implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        flush(): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static nullOutputStream(): Internal.OutputStream
        close(): void
        write(arg0: number[]): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Graphics2D extends Internal.Graphics {
        getClass(): Internal.Class<any>
        rotate(arg0: number, arg1: number, arg2: number): void
        rotate(arg0: number): void
        drawOval(arg0: number, arg1: number, arg2: number, arg3: number): void
        getRenderingHint(arg0: Internal.RenderingHints$Key): any
        drawRenderableImage(arg0: Internal.RenderableImage, arg1: Internal.AffineTransform): void
        fillRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        translate(arg0: number, arg1: number): void
        translate(arg0: number, arg1: number): void
        hit(arg0: Internal.Rectangle, arg1: Internal.Shape, arg2: boolean): boolean
        getDeviceConfiguration(): Internal.GraphicsConfiguration
        fillPolygon(arg0: number[], arg1: number[], arg2: number): void
        fillPolygon(arg0: Internal.Polygon): void
        getClipBounds(): Internal.Rectangle
        getClipBounds(arg0: Internal.Rectangle): Internal.Rectangle
        drawRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        setComposite(arg0: Internal.Composite): void
        create(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Graphics
        create(): Internal.Graphics
        setClip(arg0: number, arg1: number, arg2: number, arg3: number): void
        setClip(arg0: Internal.Shape): void
        setFont(arg0: java_.awt.Font): void
        setStroke(arg0: Internal.Stroke): void
        drawPolyline(arg0: number[], arg1: number[], arg2: number): void
        getTransform(): Internal.AffineTransform
        setPaint(arg0: Internal.Paint): void
        setRenderingHint(arg0: Internal.RenderingHints$Key, arg1: any): void
        fill(arg0: Internal.Shape): void
        drawBytes(arg0: number[], arg1: number, arg2: number, arg3: number, arg4: number): void
        getComposite(): Internal.Composite
        hitClip(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        getClip(): Internal.Shape
        getFont(): java_.awt.Font
        dispose(): void
        addRenderingHints(arg0: Internal.Map<any, any>): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getStroke(): Internal.Stroke
        fillArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        drawRenderedImage(arg0: Internal.RenderedImage, arg1: Internal.AffineTransform): void
        notifyAll(): void
        getClipRect(): Internal.Rectangle
        scale(arg0: number, arg1: number): void
        getRenderingHints(): Internal.RenderingHints
        setBackground(arg0: java_.awt.Color): void
        notify(): void
        drawString(arg0: string, arg1: number, arg2: number): void
        drawString(arg0: Internal.AttributedCharacterIterator, arg1: number, arg2: number): void
        drawString(arg0: Internal.AttributedCharacterIterator, arg1: number, arg2: number): void
        drawString(arg0: string, arg1: number, arg2: number): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getFontMetrics(): Internal.FontMetrics
        transform(arg0: Internal.AffineTransform): void
        draw3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void
        drawGlyphVector(arg0: Internal.GlyphVector, arg1: number, arg2: number): void
        setTransform(arg0: Internal.AffineTransform): void
        hashCode(): number
        drawChars(arg0: string[], arg1: number, arg2: number, arg3: number, arg4: number): void
        getFontRenderContext(): Internal.FontRenderContext
        fill3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void
        getPaint(): Internal.Paint
        fillRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        shear(arg0: number, arg1: number): void
        clipRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        getColor(): java_.awt.Color
        drawArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        drawLine(arg0: number, arg1: number, arg2: number, arg3: number): void
        draw(arg0: Internal.Shape): void
        copyArea(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        clearRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        setPaintMode(): void
        drawImage(arg0: Internal.BufferedImage, arg1: Internal.BufferedImageOp, arg2: number, arg3: number): void
        drawImage(arg0: Internal.Image, arg1: Internal.AffineTransform, arg2: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: java_.awt.Color, arg10: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: java_.awt.Color, arg4: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: java_.awt.Color, arg6: Internal.ImageObserver): boolean
        drawImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.ImageObserver): boolean
        setColor(arg0: java_.awt.Color): void
        equals(arg0: any): boolean
        setRenderingHints(arg0: Internal.Map<any, any>): void
        toString(): string
        finalize(): void
        fillOval(arg0: number, arg1: number, arg2: number, arg3: number): void
        setXORMode(arg0: java_.awt.Color): void
        drawPolygon(arg0: number[], arg1: number[], arg2: number): void
        drawPolygon(arg0: Internal.Polygon): void
        drawRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        getBackground(): java_.awt.Color
        clip(arg0: Internal.Shape): void
        get color(): java_.awt.Color;
        get composite(): Internal.Composite;
        get background(): java_.awt.Color;
        get renderingHints(): Internal.RenderingHints;
        get fontRenderContext(): Internal.FontRenderContext;
        get clipBounds(): Internal.Rectangle;
        get paint(): Internal.Paint;
        get deviceConfiguration(): Internal.GraphicsConfiguration;
        get fontMetrics(): Internal.FontMetrics;
        get class(): Internal.Class<any>;
        get stroke(): Internal.Stroke;
        get font(): java_.awt.Font;
        set color(arg0: java_.awt.Color);
        set background(arg0: java_.awt.Color);
        set composite(arg0: Internal.Composite);
        set paint(arg0: Internal.Paint);
        set xORMode(arg0: java_.awt.Color);
        set stroke(arg0: Internal.Stroke);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Ingredient$Value {
    }
    interface ChannelPromise extends Internal.ChannelFuture, Internal.Promise<void> {
        cancel(arg0: boolean): boolean
        unvoid(): Internal.ChannelPromise
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>
        getNow(): void
        channel(): io.netty.channel.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelPromise
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): Internal.Future<void>
        awaitUninterruptibly(): Internal.Promise<void>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ChannelPromise
        sync(): Internal.ChannelFuture
        sync(): Internal.Future<void>
        sync(): Internal.Promise<void>
        setSuccess(arg0: void): Internal.ChannelPromise
        setSuccess(): Internal.ChannelPromise
        setSuccess(arg0: void): Internal.Promise<void>
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise
        setFailure(arg0: Internal.Throwable): Internal.Promise<void>
        isVoid(): boolean
        trySuccess(): boolean
        trySuccess(arg0: void): boolean
        syncUninterruptibly(): Internal.ChannelPromise
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): Internal.Future<void>
        syncUninterruptibly(): Internal.Promise<void>
        get(): void
        get(arg0: number, arg1: Internal.TimeUnit): void
        isCancellable(): boolean
        await(): Internal.ChannelPromise
        await(): Internal.ChannelFuture
        await(): Internal.Future<void>
        await(): Internal.Promise<void>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>
        setUncancellable(): boolean
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>
    }
    class ItemTransforms$TransformType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ItemTransforms$TransformType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ItemTransforms$TransformType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ItemTransforms$TransformType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ItemTransforms$TransformType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly HEAD : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly GROUND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIXED : Internal.ItemTransforms$TransformType;
        static readonly GUI : Internal.ItemTransforms$TransformType;
        static readonly NONE : Internal.ItemTransforms$TransformType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ConsoleJS {
        getClass(): Internal.Class<any>
        printObject(o: any, tree: boolean): void
        printObject(o: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        infof(message: any, args: any[]): void
        log(message: any): void
        notifyAll(): void
        errorf(message: string, args: any[]): void
        setMuted(m: boolean): void
        error(message: any): void
        error(message: string, throwable: Internal.Throwable): void
        error(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void
        notify(): void
        debugf(message: string, args: any[]): void
        trace(): void
        flush(): void
        hashCode(): number
        setWriteToFile(m: boolean): void
        setLineNumber(b: boolean): void
        warnf(message: string, args: any[]): void
        getScriptLine(): number
        info(message: any): void
        group(): void
        getMuted(): boolean
        debug(message: any): void
        printStackTrace(throwable: Internal.Throwable, skip: Internal.Pattern): void
        getLogger(): Internal.Logger
        shouldPrintDebug(): boolean
        setDebugEnabled(m: boolean): void
        warn(message: any): void
        warn(message: string, throwable: Internal.Throwable): void
        warn(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void
        resetFile(): void
        groupEnd(): void
        getDebugEnabled(): boolean
        printClass(className: string, tree: boolean): void
        printClass(className: string): void
        equals(arg0: any): boolean
        toString(): string
        getWriteToFile(): boolean
        static SERVER : Internal.ConsoleJS;
        static STARTUP : Internal.ConsoleJS;
        static CLIENT : Internal.ConsoleJS;
        get scriptLine(): number;
        get writeToFile(): boolean;
        get logger(): Internal.Logger;
        get debugEnabled(): boolean;
        get class(): Internal.Class<any>;
        get muted(): boolean;
        set writeToFile(m: boolean);
        set debugEnabled(m: boolean);
        set lineNumber(b: boolean);
        set muted(m: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Hashtable <K, V> extends Internal.Dictionary<any, any> implements Internal.Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        keys(): Internal.Enumeration<K>
        notifyAll(): void
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        contains(arg0: any): boolean
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        elements(): Internal.Enumeration<V>
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleComponent {
        getLocation(): Internal.Point
        requestFocus(): void
        addFocusListener(arg0: Internal.FocusListener): void
        getLocationOnScreen(): Internal.Point
        isFocusTraversable(): boolean
        setBackground(arg0: java_.awt.Color): void
        getAccessibleAt(arg0: Internal.Point): Internal.Accessible
        getBounds(): Internal.Rectangle
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        isShowing(): boolean
        setSize(arg0: Internal.Dimension): void
        setLocation(arg0: Internal.Point): void
        setFont(arg0: java_.awt.Font): void
        removeFocusListener(arg0: Internal.FocusListener): void
        setVisible(arg0: boolean): void
        getCursor(): Internal.Cursor
        setForeground(arg0: java_.awt.Color): void
        isVisible(): boolean
        setBounds(arg0: Internal.Rectangle): void
        getForeground(): java_.awt.Color
        setEnabled(arg0: boolean): void
        getSize(): Internal.Dimension
        contains(arg0: Internal.Point): boolean
        isEnabled(): boolean
        setCursor(arg0: Internal.Cursor): void
        getFont(): java_.awt.Font
        getBackground(): java_.awt.Color
    }
    class InputMethodEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        getCommittedCharacterCount(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getText(): Internal.AttributedCharacterIterator
        notifyAll(): void
        getID(): number
        consume(): void
        notify(): void
        getVisiblePosition(): Internal.TextHitInfo
        paramString(): string
        isConsumed(): boolean
        getCaret(): Internal.TextHitInfo
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        getWhen(): number
        toString(): string
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly CARET_POSITION_CHANGED : 1101;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly INPUT_METHOD_TEXT_CHANGED : 1100;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INPUT_METHOD_LAST : 1101;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly INPUT_METHOD_FIRST : 1100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        get consumed(): boolean;
        get visiblePosition(): Internal.TextHitInfo;
        get caret(): Internal.TextHitInfo;
        get text(): Internal.AttributedCharacterIterator;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get when(): number;
        get committedCharacterCount(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImageIcon extends Internal.Icon {
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        getClass(): Internal.Class<any>
        bindTexture(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        withBorder(color: Internal.Color4I, roundEdges: boolean): Internal.Icon
        notifyAll(): void
        withColor(color: Internal.Color4I): Internal.ImageIcon
        withColor(arg0: Internal.Color4I): Internal.Icon
        isEmpty(): boolean
        withUV(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Icon
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.ImageIcon
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon
        draw(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        withTint(c: Internal.Color4I): Internal.ImageIcon
        withTint(arg0: Internal.Color4I): Internal.Icon
        draw3D(matrixStack: Internal.PoseStack): void
        notify(): void
        static getIcon(id: string): Internal.Icon
        static getIcon(json: Internal.JsonElement): Internal.Icon
        static getIcon(id: ResourceLocation): Internal.Icon
        createPixelBuffer(): Internal.PixelBuffer
        getIngredient(): any
        hashCode(): number
        equals(o: any): boolean
        withPadding(padding: number): Internal.Icon
        toString(): string
        copy(): Internal.Icon
        copy(): Internal.ImageIcon
        hasPixelBuffer(): boolean
        combineWith(icon: Internal.Icon): Internal.Icon
        combineWith(icons: Internal.Icon[]): Internal.Icon
        getJson(): Internal.JsonElement
        minU : number;
        maxV : number;
        maxU : number;
        color : Internal.Color4I;
        readonly texture : ResourceLocation;
        static readonly MISSING_IMAGE : ResourceLocation;
        minV : number;
        tileSize : number;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjDoubleConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    interface Function10 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function3<T8, T9, T10, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9, arg1: T10) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function5<T6, T7, T8, T9, T10, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function4<T7, T8, T9, T10, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function7<T4, T5, T6, T7, T8, T9, T10, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function6<T5, T6, T7, T8, T9, T10, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function8<T3, T4, T5, T6, T7, T8, T9, T10, R>
        curry(): (arg0: T1) => Internal.Function9<T2, T3, T4, T5, T6, T7, T8, T9, T10, R>
    }
    interface AsKJS {
        asKJS(): any
    }
    interface ObjectBidirectionalIterator <K> extends Internal.ObjectIterator<K>, Internal.BidirectionalIterator<K> {
        next(): K
        previous(): K
        hasPrevious(): boolean
        back(arg0: number): number
        hasNext(): boolean
        skip(arg0: number): number
        forEachRemaining(arg0: (arg0: K) => void): void
        remove(): void
    }
    class DataResult$Mu implements Internal.K1 {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PropertyMap extends Internal.ForwardingMultimap<any, any> {
        getClass(): Internal.Class<any>
        containsEntry(arg0: any, arg1: any): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        forEach(arg0: (arg0: string, arg1: Internal.Property) => void): void
        keys(): Internal.Multiset<string>
        containsKey(arg0: any): boolean
        asMap(): Internal.Map<string, Internal.Collection<Internal.Property>>
        notifyAll(): void
        values(): Internal.Collection<Internal.Property>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: string, arg1: Internal.Iterable<Internal.Property>): Internal.Collection<Internal.Property>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: string, arg1: Internal.Property): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<Internal.Property>
        entries(): Internal.Collection<Internal.Map$Entry<string, Internal.Property>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<string, Internal.Property>): boolean
        putAll(arg0: string, arg1: Internal.Iterable<Internal.Property>): boolean
        equals(arg0: any): boolean
        get(arg0: string): Internal.Collection<Internal.Property>
        toString(): string
        keySet(): Internal.Set<string>
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ImmutableBox {
        hasPowerOf2Sides(): boolean
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB
        intersects(arg0: Internal.ImmutableBox): boolean
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        getMaxX(): number
        forEachContained(arg0: Internal.CoordinateConsumer): void
        getMaxY(): number
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox
        getMaxZ(): number
        empty(): boolean
        volume(): number
        sizeX(): number
        contains(arg0: number, arg1: number, arg2: number): boolean
        contains(arg0: Internal.ImmutableBox): boolean
        isContainedBy(arg0: Internal.GridAlignedBB): boolean
        toAABB(): Internal.AABB
        copy(): Internal.GridAlignedBB
        getMinZ(): number
        sizeY(): number
        getMinX(): number
        sizeZ(): number
        getMinY(): number
        sameAs(arg0: Internal.ImmutableBox): boolean
        sameAs(arg0: Internal.AABB): boolean
    }
    class ModuleLayer$Controller {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addReads(arg0: Internal.Module, arg1: Internal.Module): Internal.ModuleLayer$Controller
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        addExports(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller
        toString(): string
        addOpens(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller
        notify(): void
        layer(): Internal.ModuleLayer
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class HumanoidModel <T> extends Internal.AgeableListModel<any> implements Internal.ArmedModel, Internal.HeadedModel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getBodyParts_vampirism(): Internal.Iterable<any>
        handler$bih000$poseLeftArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void
        hashCode(): number
        handler$zpm000$rotationAngleCallback(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void
        notifyAll(): void
        equals(arg0: any): boolean
        handler$bih000$poseRightArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void
        toString(): string
        handler$bih000$setupAnim(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void
        notify(): void
        animationType : Internal.TwoHandedAnimation;
        get class(): Internal.Class<any>;
        get bodyParts_vampirism(): Internal.Iterable<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Enemy {
    }
    class FluidStack {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRawFluid(): Internal.Fluid
        notifyAll(): void
        getOrCreateChildTag(arg0: string): Internal.CompoundTag
        notify(): void
        getChildTag(arg0: string): Internal.CompoundTag
        containsFluid(arg0: Internal.FluidStack): boolean
        static readFromPacket(arg0: Internal.FriendlyByteBuf): Internal.FluidStack
        hashCode(): number
        setTag(arg0: Internal.CompoundTag): void
        copy(): Internal.FluidStack
        setAmount(arg0: number): void
        writeToNBT(arg0: Internal.CompoundTag): Internal.CompoundTag
        isFluidEqual(arg0: Internal.ItemStack): boolean
        isFluidEqual(arg0: Internal.FluidStack): boolean
        getAmount(): number
        removeChildTag(arg0: string): void
        isFluidStackIdentical(arg0: Internal.FluidStack): boolean
        grow(arg0: number): void
        hasTag(): boolean
        static loadFluidStackFromNBT(arg0: Internal.CompoundTag): Internal.FluidStack
        shrink(arg0: number): void
        getTranslationKey(): string
        isEmpty(): boolean
        getTag(): Internal.CompoundTag
        getDisplayName(): Internal.Component
        getOrCreateTag(): Internal.CompoundTag
        writeToPacket(arg0: Internal.FriendlyByteBuf): void
        equals(arg0: any): boolean
        getFluid(): Internal.Fluid
        toString(): string
        static areFluidStackTagsEqual(arg0: Internal.FluidStack, arg1: Internal.FluidStack): boolean
        static readonly CODEC : Internal.Codec<Internal.FluidStack>;
        static readonly EMPTY : Internal.FluidStack;
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get translationKey(): string;
        get displayName(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set amount(arg0: number);
        set tag(arg0: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AirBlock extends Internal.Block {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState
        getClass(): Internal.Class<any>
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction
        getTags(): Internal.Set<ResourceLocation>
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean
        setMaterialKJS(arg0: Internal.Material): void
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        setExplosionResistanceKJS(arg0: number): void
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean
        setJumpFactorKJS(arg0: number): void
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean
        getMaterial(): Internal.Material
        isStickyBlock(arg0: Internal.BlockState): boolean
        setSoundTypeKJS(arg0: Internal.SoundType): void
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes
        getBlockBuilderKJS(): Internal.BlockBuilder
        isSlimeBlock(arg0: Internal.BlockState): boolean
        getRegistryType(): Internal.Class<Internal.Block>
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean
        notifyAll(): void
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean
        getId(): string
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        notify(): void
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean
        getRenderPropertiesInternal(): any
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType
        hashCode(): number
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean
        initializeClient(arg0: (arg0: Internal.IBlockRenderProperties) => void): void
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack
        setFrictionKJS(arg0: number): void
        setHasCollisionKJS(arg0: boolean): void
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number
        getRegistryName(): ResourceLocation
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Block
        setRegistryName(arg0: string): Internal.Block
        setRegistryName(arg0: string, arg1: string): Internal.Block
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        setIsRandomlyTickingKJS(arg0: boolean): void
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>
        equals(arg0: any): boolean
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        setSpeedFactorKJS(arg0: number): void
        setBlockBuilderKJS(b: Internal.BlockBuilder): void
        toString(): string
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): Internal.Material;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: Internal.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MultiBufferSource$BufferSource implements Internal.MultiBufferSource, Internal.AccessorMultiBufferSource {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getFallbackBuffer(): Internal.BufferBuilder
        getFixedBuffers(): Internal.Map<any, any>
        notify(): void
        get fixedBuffers(): Internal.Map<any, any>;
        get fallbackBuffer(): Internal.BufferBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2DoubleFunction extends Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ClientTeam extends Internal.TeamBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        notify(): void
        getColoredName(): Internal.Component
        hashCode(): number
        write(buffer: Internal.FriendlyByteBuf, now: number): void
        isAlly(profile: Internal.UUID): boolean
        getProperty<T_>(property: Internal.TeamProperty<T_>): T_
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        isFreeToJoin(): boolean
        getDisplayName(): string
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        getType(): Internal.TeamType
        setProperty<T_>(property: Internal.TeamProperty<T_>, value: T_): void
        equals(o: any): boolean
        toString(): string
        isSelf(): boolean
        getMembers(): Internal.Set<Internal.UUID>
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.ClientTeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        invalid : boolean;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get self(): boolean;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ColorSettings {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getGLMoonColor(): Internal.Vector3f
        notify(): void
        static tryParseColor(arg0: string): number
        getMoonTextureColor(): number
        getSkyLightColor(): number
        hashCode(): number
        getMoonTextureBlendStrength(): number
        equals(arg0: any): boolean
        getGLSkyLightColor(): Internal.Vector3f
        toString(): string
        getSkyLightBlendStrength(): number
        static readonly CODEC : Internal.Codec<Internal.ColorSettings>;
        get gLSkyLightColor(): Internal.Vector3f;
        get skyLightBlendStrength(): number;
        get moonTextureBlendStrength(): number;
        get skyLightColor(): number;
        get gLMoonColor(): Internal.Vector3f;
        get class(): Internal.Class<any>;
        get moonTextureColor(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ListTag extends Internal.CollectionTag<any> {
        getClass(): Internal.Class<any>
        wrapAsJavaList(): Internal.List<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): Internal.Tag
        remove(arg0: number): any
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<Internal.Tag>
        stream(): Internal.Stream<Internal.Tag>
        hashCode(): number
        get(arg0: number): Internal.Tag
        get(arg0: number): any
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<Internal.Tag>
        indexOf(arg0: any): number
        add(arg0: number, arg1: any): void
        add(arg0: number, arg1: Internal.Tag): void
        add(arg0: Internal.Tag): boolean
        subList(arg0: number, arg1: number): Internal.List<Internal.Tag>
        set(arg0: number, arg1: any): any
        set(arg0: number, arg1: Internal.Tag): Internal.Tag
        spliterator(): Internal.Spliterator<Internal.Tag>
        forEach(arg0: (arg0: Internal.Tag) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<Internal.Tag>): void
        removeIf(arg0: (arg0: Internal.Tag) => boolean): boolean
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<Internal.Tag>): boolean
        addAll(arg0: Internal.Collection<Internal.Tag>): boolean
        equals(arg0: any): boolean
        listIterator(): Internal.ListIterator<Internal.Tag>
        listIterator(arg0: number): Internal.ListIterator<Internal.Tag>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EventQueue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getCurrentEvent(): Internal.AWTEvent
        createSecondaryLoop(): Internal.SecondaryLoop
        notifyAll(): void
        peekEvent(arg0: number): Internal.AWTEvent
        peekEvent(): Internal.AWTEvent
        notify(): void
        push(arg0: Internal.EventQueue): void
        static invokeLater(arg0: Internal.Runnable): void
        static invokeAndWait(arg0: Internal.Runnable): void
        static isDispatchThread(): boolean
        postEvent(arg0: Internal.AWTEvent): void
        hashCode(): number
        equals(arg0: any): boolean
        static getMostRecentEventTime(): number
        toString(): string
        getNextEvent(): Internal.AWTEvent
        get dispatchThread(): boolean;
        get currentEvent(): Internal.AWTEvent;
        get mostRecentEventTime(): number;
        get nextEvent(): Internal.AWTEvent;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IEnchantableItem {
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
    }
    interface Function6 <T1, T2, T3, T4, T5, T6, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6): R
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function3<T4, T5, T6, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5, arg1: T6) => R>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function4<T3, T4, T5, T6, R>
        curry(): (arg0: T1) => Internal.Function5<T2, T3, T4, T5, T6, R>
    }
    abstract class ModuleReference {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        location(): Internal.Optional<Internal.URI>
        descriptor(): Internal.ModuleDescriptor
        notify(): void
        open(): Internal.ModuleReader
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface KeyListener extends Internal.EventListener {
        keyPressed(arg0: Internal.KeyEvent): void
        keyReleased(arg0: Internal.KeyEvent): void
        keyTyped(arg0: Internal.KeyEvent): void
    }
    class IntConfig extends Internal.NumberConfig<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<number>
        notifyAll(): void
        isEqual(v1: number, v2: number): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<number>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(v: number): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(arg0: any): Internal.Component
        getStringForGUI(v: number): Internal.Component
        getPath(): string
        copy(value: number): number
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: number, c: (arg0: number) => void, def: number): Internal.ConfigValue<number>
        getColor(arg0: any): Internal.Color4I
        getColor(v: number): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(callback: (arg0: number) => void, string: string): boolean
        getIcon(v: number): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<number>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<number>
        setNameKey(key: string): Internal.ConfigValue<number>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: number): boolean
        fader(v: boolean): Internal.NumberConfig<number>
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: number) => void;
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ProcessingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        superheated(): Internal.ProcessingRecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        processingTime(t: number): Internal.ProcessingRecipeJS
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        heated(): Internal.ProcessingRecipeJS
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        heatRequirement(req: string): Internal.ProcessingRecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IScheduledEventCallback {
        onCallback(arg0: Internal.ScheduledEvent): void
    }
    interface FuncSupplier {
        create(arg0: Internal.List<Internal.Unit>): Internal.Unit
    }
    class BufferLayout$Builder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        build(): Internal.BufferLayout
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        addItems(arg0: Internal.LayoutItem[]): Internal.BufferLayout$Builder
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SpecialEquality {
        specialEquals(o: any, shallow: boolean): boolean
    }
    interface UserPrincipal extends Internal.Principal {
        getName(): string
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
    }
    interface LevelAccessor extends Internal.CommonLevelAccessor, Internal.LevelTimeAccess {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    class ArcFurnaceRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DropTargetEvent extends Internal.EventObject {
        getDropTargetContext(): Internal.DropTargetContext
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Random implements Internal.RandomGenerator, Internal.Serializable {
        nextFloat(): number
        nextFloat(arg0: number): number
        nextFloat(arg0: number, arg1: number): number
        getClass(): Internal.Class<any>
        isDeprecated(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        nextInt(arg0: number): number
        nextInt(): number
        nextInt(arg0: number, arg1: number): number
        nextLong(): number
        nextLong(arg0: number, arg1: number): number
        nextLong(arg0: number): number
        notify(): void
        nextDouble(): number
        nextDouble(arg0: number): number
        nextDouble(arg0: number, arg1: number): number
        nextGaussian(): number
        nextGaussian(arg0: number, arg1: number): number
        nextBytes(arg0: number[]): void
        longs(arg0: number, arg1: number): Internal.LongStream
        longs(arg0: number): Internal.LongStream
        longs(): Internal.LongStream
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream
        nextExponential(): number
        ints(arg0: number, arg1: number): Internal.IntStream
        ints(arg0: number): Internal.IntStream
        ints(): Internal.IntStream
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream
        doubles(arg0: number, arg1: number): Internal.DoubleStream
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream
        doubles(arg0: number): Internal.DoubleStream
        doubles(): Internal.DoubleStream
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        nextBoolean(): boolean
        setSeed(arg0: number): void
        get deprecated(): boolean;
        get class(): Internal.Class<any>;
        set seed(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class PoseStack$Pose {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IsoChronology extends Internal.AbstractChronology implements Internal.Serializable {
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        date(arg0: number, arg1: number, arg2: number): Internal.LocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.LocalDate
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.TemporalAccessor): Internal.LocalDate
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<any>
        localDateTime(arg0: Internal.TemporalAccessor): Internal.LocalDateTime
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        range(arg0: Internal.ChronoField): Internal.ValueRange
        getId(): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Chronology): number
        notify(): void
        dateNow(arg0: Internal.ZoneId): Internal.LocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(arg0: Internal.Clock): Internal.LocalDate
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        dateNow(): Internal.ChronoLocalDate
        dateNow(): Internal.LocalDate
        eraOf(arg0: number): Internal.Era
        eraOf(arg0: number): Internal.IsoEra
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ZonedDateTime
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ZonedDateTime
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<any>
        hashCode(): number
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        epochSecond(arg0: Internal.Era, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): number
        period(arg0: number, arg1: number, arg2: number): Internal.Period
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        getCalendarType(): string
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.LocalDate
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        dateYearDay(arg0: number, arg1: number): Internal.LocalDate
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        resolveDate(arg0: Internal.Map<any, any>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        resolveDate(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.LocalDate
        isLeapYear(arg0: number): boolean
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        dateEpochDay(arg0: number): Internal.LocalDate
        eras(): Internal.List<Internal.Era>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        toString(): string
        static readonly INSTANCE : Internal.IsoChronology;
        get calendarType(): string;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarTextComponents {
        getSetNotification(): Internal.LunarTextComponents$Notification
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.CustomTranslationTextComponent
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        getRiseNotification(): Internal.LunarTextComponents$Notification
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents>;
        static readonly LEGACY_CODEC : Internal.Codec<Internal.LunarTextComponents>;
        get name(): Internal.CustomTranslationTextComponent;
        get riseNotification(): Internal.LunarTextComponents$Notification;
        get setNotification(): Internal.LunarTextComponents$Notification;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MovingListener extends Internal.LightListener {
        getVolume(): Internal.ImmutableBox
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        update(arg0: Internal.LightProvider): boolean
        status(): Internal.ListenerStatus
    }
    class MouseWheelEvent extends Internal.MouseEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        translatePoint(arg0: number, arg1: number): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPreciseWheelRotation(): number
        getLocationOnScreen(): Internal.Point
        notifyAll(): void
        isMetaDown(): boolean
        consume(): void
        getModifiersEx(): number
        notify(): void
        isPopupTrigger(): boolean
        isShiftDown(): boolean
        getButton(): number
        paramString(): string
        isConsumed(): boolean
        static getModifiersExText(arg0: number): string
        hashCode(): number
        isAltGraphDown(): boolean
        static getMaskForButton(arg0: number): number
        getModifiers(): number
        isAltDown(): boolean
        static getMouseModifiersText(arg0: number): string
        getPoint(): Internal.Point
        isControlDown(): boolean
        getScrollType(): number
        getID(): number
        getUnitsToScroll(): number
        getScrollAmount(): number
        getX(): number
        getY(): number
        getYOnScreen(): number
        getSource(): any
        equals(arg0: any): boolean
        getWhen(): number
        getClickCount(): number
        toString(): string
        getWheelRotation(): number
        getComponent(): java_.awt.Component
        getXOnScreen(): number
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_FIRST : 500;
        static readonly BUTTON1_MASK : 16;
        static readonly MOUSE_PRESSED : 501;
        static readonly WHEEL_BLOCK_SCROLL : 1;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON1 : 1;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly COMPONENT_SHOWN : 102;
        static readonly MOUSE_LAST : 507;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly NOBUTTON : 0;
        static readonly COMPONENT_RESIZED : 101;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly MOUSE_WHEEL : 507;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_EXITED : 505;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_CLICKED : 500;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly MOUSE_MOVED : 503;
        static readonly COMPONENT_MOVED : 100;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly BUTTON2 : 2;
        static readonly BUTTON3 : 3;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly MOUSE_RELEASED : 502;
        static readonly BUTTON3_MASK : 4;
        static readonly WHEEL_UNIT_SCROLL : 0;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly MOUSE_ENTERED : 504;
        static readonly MOUSE_DRAGGED : 506;
        get consumed(): boolean;
        get clickCount(): number;
        get yOnScreen(): number;
        get xOnScreen(): number;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get point(): Internal.Point;
        get button(): number;
        get preciseWheelRotation(): number;
        get scrollType(): number;
        get locationOnScreen(): Internal.Point;
        get metaDown(): boolean;
        get scrollAmount(): number;
        get class(): Internal.Class<any>;
        get altDown(): boolean;
        get wheelRotation(): number;
        get controlDown(): boolean;
        get altGraphDown(): boolean;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get popupTrigger(): boolean;
        get x(): number;
        get y(): number;
        get iD(): number;
        get unitsToScroll(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class KeyEvent extends Internal.InputEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getKeyText(arg0: number): string
        notifyAll(): void
        isMetaDown(): boolean
        static getExtendedKeyCodeForChar(arg0: number): number
        setKeyChar(arg0: string): void
        consume(): void
        getModifiersEx(): number
        setModifiers(arg0: number): void
        notify(): void
        isShiftDown(): boolean
        paramString(): string
        isConsumed(): boolean
        static getModifiersExText(arg0: number): string
        hashCode(): number
        isAltGraphDown(): boolean
        static getMaskForButton(arg0: number): number
        getKeyLocation(): number
        getModifiers(): number
        getKeyCode(): number
        isAltDown(): boolean
        getExtendedKeyCode(): number
        isControlDown(): boolean
        getID(): number
        isActionKey(): boolean
        static getKeyModifiersText(arg0: number): string
        getKeyChar(): string
        getSource(): any
        setKeyCode(arg0: number): void
        equals(arg0: any): boolean
        getWhen(): number
        toString(): string
        getComponent(): java_.awt.Component
        static readonly VK_UNDEFINED : 0;
        static readonly VK_QUOTEDBL : 152;
        static readonly BUTTON1_MASK : 16;
        static readonly VK_BRACERIGHT : 162;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly VK_COPY : 65485;
        static readonly VK_LEFT_PARENTHESIS : 519;
        static readonly VK_NUMPAD3 : 99;
        static readonly VK_NUMPAD4 : 100;
        static readonly VK_NUMPAD5 : 101;
        static readonly VK_NUMPAD6 : 102;
        static readonly VK_HELP : 156;
        static readonly VK_NUMPAD0 : 96;
        static readonly VK_NUMPAD1 : 97;
        static readonly VK_NUMPAD2 : 98;
        static readonly VK_RIGHT : 39;
        static readonly COMPONENT_SHOWN : 102;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly VK_AMPERSAND : 150;
        static readonly VK_ALT_GRAPH : 65406;
        static readonly VK_CANCEL : 3;
        static readonly COMPONENT_RESIZED : 101;
        static readonly VK_COLON : 513;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly VK_CIRCUMFLEX : 514;
        static readonly VK_CAPS_LOCK : 20;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly VK_ALL_CANDIDATES : 256;
        static readonly VK_LESS : 153;
        static readonly VK_PLUS : 521;
        static readonly VK_WINDOWS : 524;
        static readonly KEY_RELEASED : 402;
        static readonly VK_KANA : 21;
        static readonly VK_ASTERISK : 151;
        static readonly COMPONENT_MOVED : 100;
        static readonly VK_DOLLAR : 515;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly VK_PAUSE : 19;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly BUTTON3_MASK : 4;
        static readonly VK_FINAL : 24;
        static readonly VK_DEAD_SEMIVOICED_SOUND : 143;
        static readonly VK_PROPS : 65482;
        static readonly VK_RIGHT_PARENTHESIS : 522;
        static readonly VK_BEGIN : 65368;
        static readonly VK_DEAD_BREVE : 133;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly VK_DEAD_ABOVEDOT : 134;
        static readonly VK_CUT : 65489;
        static readonly VK_BACK_QUOTE : 192;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly VK_HOME : 36;
        static readonly VK_UNDO : 65483;
        static readonly ALT_DOWN_MASK : 512;
        static readonly VK_ESCAPE : 27;
        static readonly VK_F9 : 120;
        static readonly VK_F8 : 119;
        static readonly VK_F7 : 118;
        static readonly VK_F6 : 117;
        static readonly VK_EXCLAMATION_MARK : 517;
        static readonly VK_F5 : 116;
        static readonly VK_F4 : 115;
        static readonly VK_F3 : 114;
        static readonly VK_HALF_WIDTH : 244;
        static readonly VK_F2 : 113;
        static readonly VK_F1 : 112;
        static readonly VK_GREATER : 160;
        static readonly META_DOWN_MASK : 256;
        static readonly VK_KATAKANA : 241;
        static readonly VK_INVERTED_EXCLAMATION_MARK : 518;
        static readonly VK_UP : 38;
        static readonly VK_SLASH : 47;
        static readonly VK_CONVERT : 28;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly VK_SUBTRACT : 109;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly VK_CODE_INPUT : 258;
        static readonly VK_KP_UP : 224;
        static readonly VK_EURO_SIGN : 516;
        static readonly KEY_LAST : 402;
        static readonly VK_DIVIDE : 111;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly COMPONENT_FIRST : 100;
        static readonly KEY_TYPED : 400;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly VK_PAGE_UP : 33;
        static readonly VK_SEMICOLON : 59;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly VK_SEPARATOR : 108;
        static readonly VK_ADD : 107;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly KEY_PRESSED : 401;
        static readonly META_MASK : 4;
        static readonly VK_2 : 50;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly VK_3 : 51;
        static readonly VK_4 : 52;
        static readonly VK_5 : 53;
        static readonly VK_6 : 54;
        static readonly VK_ALPHANUMERIC : 240;
        static readonly VK_7 : 55;
        static readonly VK_8 : 56;
        static readonly VK_9 : 57;
        static readonly VK_DEAD_DOUBLEACUTE : 137;
        static readonly VK_0 : 48;
        static readonly VK_1 : 49;
        static readonly VK_DEAD_CEDILLA : 139;
        static readonly VK_B : 66;
        static readonly VK_C : 67;
        static readonly VK_D : 68;
        static readonly VK_E : 69;
        static readonly VK_F : 70;
        static readonly VK_G : 71;
        static readonly VK_H : 72;
        static readonly BUTTON2_MASK : 8;
        static readonly VK_I : 73;
        static readonly VK_OPEN_BRACKET : 91;
        static readonly VK_HIRAGANA : 242;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly VK_A : 65;
        static readonly VK_JAPANESE_KATAKANA : 259;
        static readonly VK_NUM_LOCK : 144;
        static readonly VK_AT : 512;
        static readonly VK_UNDERSCORE : 523;
        static readonly VK_KP_DOWN : 225;
        static readonly VK_BACK_SPACE : 8;
        static readonly VK_CLEAR : 12;
        static readonly VK_DELETE : 127;
        static readonly VK_DEAD_VOICED_SOUND : 142;
        static readonly VK_MULTIPLY : 106;
        static readonly VK_SPACE : 32;
        static readonly VK_FULL_WIDTH : 243;
        static readonly VK_PAGE_DOWN : 34;
        static readonly VK_END : 35;
        static readonly CHAR_UNDEFINED : "￿";
        static readonly KEY_LOCATION_LEFT : 2;
        static readonly VK_DOWN : 40;
        static readonly SHIFT_MASK : 1;
        static readonly VK_DEAD_CIRCUMFLEX : 130;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly VK_EQUALS : 61;
        static readonly VK_JAPANESE_ROMAN : 261;
        static readonly VK_PERIOD : 46;
        static readonly VK_F12 : 123;
        static readonly VK_F11 : 122;
        static readonly VK_F14 : 61441;
        static readonly VK_F13 : 61440;
        static readonly VK_COMPOSE : 65312;
        static readonly VK_DEAD_ACUTE : 129;
        static readonly VK_F10 : 121;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly VK_DEAD_DIAERESIS : 135;
        static readonly VK_PRINTSCREEN : 154;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly VK_R : 82;
        static readonly VK_DEAD_ABOVERING : 136;
        static readonly VK_S : 83;
        static readonly VK_T : 84;
        static readonly VK_U : 85;
        static readonly VK_PREVIOUS_CANDIDATE : 257;
        static readonly VK_V : 86;
        static readonly VK_W : 87;
        static readonly VK_X : 88;
        static readonly VK_Y : 89;
        static readonly VK_J : 74;
        static readonly VK_K : 75;
        static readonly VK_F19 : 61446;
        static readonly VK_L : 76;
        static readonly VK_M : 77;
        static readonly VK_N : 78;
        static readonly VK_F16 : 61443;
        static readonly VK_O : 79;
        static readonly VK_F15 : 61442;
        static readonly VK_P : 80;
        static readonly VK_F18 : 61445;
        static readonly VK_Q : 81;
        static readonly VK_F17 : 61444;
        static readonly KEY_LOCATION_NUMPAD : 4;
        static readonly VK_F23 : 61450;
        static readonly KEY_FIRST : 400;
        static readonly VK_F22 : 61449;
        static readonly KEY_LOCATION_UNKNOWN : 0;
        static readonly VK_F24 : 61451;
        static readonly VK_DEAD_TILDE : 131;
        static readonly KEY_LOCATION_RIGHT : 3;
        static readonly VK_DEAD_GRAVE : 128;
        static readonly VK_F21 : 61448;
        static readonly VK_F20 : 61447;
        static readonly VK_CONTROL : 17;
        static readonly VK_Z : 90;
        static readonly VK_QUOTE : 222;
        static readonly VK_KANA_LOCK : 262;
        static readonly VK_KP_RIGHT : 227;
        static readonly VK_NUMBER_SIGN : 520;
        static readonly VK_KP_LEFT : 226;
        static readonly VK_ENTER : 10;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly VK_DEAD_OGONEK : 140;
        static readonly VK_CONTEXT_MENU : 525;
        static readonly VK_KANJI : 25;
        static readonly VK_NONCONVERT : 29;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly VK_COMMA : 44;
        static readonly VK_DECIMAL : 110;
        static readonly VK_FIND : 65488;
        static readonly VK_DEAD_IOTA : 141;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly VK_SHIFT : 16;
        static readonly VK_MODECHANGE : 31;
        static readonly VK_BACK_SLASH : 92;
        static readonly VK_ROMAN_CHARACTERS : 245;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly VK_DEAD_MACRON : 132;
        static readonly COMPONENT_LAST : 103;
        static readonly VK_SEPARATER : 108;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly VK_MINUS : 45;
        static readonly VK_SCROLL_LOCK : 145;
        static readonly VK_PASTE : 65487;
        static readonly KEY_LOCATION_STANDARD : 1;
        static readonly VK_NUMPAD7 : 103;
        static readonly VK_AGAIN : 65481;
        static readonly VK_NUMPAD8 : 104;
        static readonly VK_NUMPAD9 : 105;
        static readonly VK_LEFT : 37;
        static readonly VK_DEAD_CARON : 138;
        static readonly VK_TAB : 9;
        static readonly VK_INPUT_METHOD_ON_OFF : 263;
        static readonly VK_CLOSE_BRACKET : 93;
        static readonly VK_INSERT : 155;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly VK_ALT : 18;
        static readonly VK_ACCEPT : 30;
        static readonly VK_JAPANESE_HIRAGANA : 260;
        static readonly VK_STOP : 65480;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly VK_META : 157;
        static readonly VK_BRACELEFT : 161;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get keyLocation(): number;
        get keyChar(): string;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get extendedKeyCode(): number;
        get altGraphDown(): boolean;
        get keyCode(): number;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get metaDown(): boolean;
        get actionKey(): boolean;
        get iD(): number;
        get class(): Internal.Class<any>;
        set keyCode(arg0: number);
        set keyChar(arg0: string);
        set source(arg0: any);
        set modifiers(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ComponentEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        paramString(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        getID(): number
        toString(): string
        getComponent(): java_.awt.Component
        notify(): void
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get component(): java_.awt.Component;
        get source(): any;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DragGestureRecognizer implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        removeDragGestureListener(arg0: Internal.DragGestureListener): void
        notifyAll(): void
        resetRecognizer(): void
        setComponent(arg0: java_.awt.Component): void
        notify(): void
        getSourceActions(): number
        getTriggerEvent(): Internal.InputEvent
        hashCode(): number
        getDragSource(): Internal.DragSource
        equals(arg0: any): boolean
        addDragGestureListener(arg0: Internal.DragGestureListener): void
        setSourceActions(arg0: number): void
        toString(): string
        getComponent(): java_.awt.Component
        get sourceActions(): number;
        get component(): java_.awt.Component;
        get triggerEvent(): Internal.InputEvent;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        set sourceActions(arg0: number);
        set component(arg0: java_.awt.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleEditableText extends Internal.AccessibleText {
        getSelectionStart(): number
        getSelectedText(): string
        replaceText(arg0: number, arg1: number, arg2: string): void
        cut(arg0: number, arg1: number): void
        getCharCount(): number
        selectText(arg0: number, arg1: number): void
        getBeforeIndex(arg0: number, arg1: number): string
        setTextContents(arg0: string): void
        paste(arg0: number): void
        setAttributes(arg0: number, arg1: number, arg2: Internal.AttributeSet): void
        getCaretPosition(): number
        delete(arg0: number, arg1: number): void
        getTextRange(arg0: number, arg1: number): string
        getIndexAtPoint(arg0: Internal.Point): number
        getCharacterAttribute(arg0: number): Internal.AttributeSet
        getAfterIndex(arg0: number, arg1: number): string
        insertTextAtIndex(arg0: number, arg1: string): void
        getSelectionEnd(): number
        getAtIndex(arg0: number, arg1: number): string
        getCharacterBounds(arg0: number): Internal.Rectangle
    }
    interface BlockGetter extends Internal.LevelHeightAccessor {
    }
    class FluidAttributes$Builder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        color(arg0: number): Internal.FluidAttributes$Builder
        translationKey(arg0: string): Internal.FluidAttributes$Builder
        density(arg0: number): Internal.FluidAttributes$Builder
        overlay(arg0: ResourceLocation): Internal.FluidAttributes$Builder
        notifyAll(): void
        sound(arg0: Internal.SoundEvent): Internal.FluidAttributes$Builder
        sound(arg0: Internal.SoundEvent, arg1: Internal.SoundEvent): Internal.FluidAttributes$Builder
        gaseous(): Internal.FluidAttributes$Builder
        notify(): void
        viscosity(arg0: number): Internal.FluidAttributes$Builder
        build(arg0: Internal.Fluid): Internal.FluidAttributes
        hashCode(): number
        equals(arg0: any): boolean
        temperature(arg0: number): Internal.FluidAttributes$Builder
        luminosity(arg0: number): Internal.FluidAttributes$Builder
        toString(): string
        rarity(arg0: Internal.Rarity): Internal.FluidAttributes$Builder
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Model {
        size(): number
        getType(): Internal.VertexType
        getReader(): Internal.VertexList
        writeInto(arg0: Internal.ByteBuffer): void
        name(): string
        vertexCount(): number
        empty(): boolean
        createEBO(): Internal.ElementBuffer
    }
    class AccessibleObject implements Internal.AnnotatedElement {
        trySetAccessible(): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isAccessible(): boolean
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        getAnnotations(): Internal.Annotation[]
        notify(): void
        getDeclaredAnnotations(): Internal.Annotation[]
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        hashCode(): number
        equals(arg0: any): boolean
        canAccess(arg0: any): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        toString(): string
        get accessible(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get annotations(): Internal.Annotation[];
        get class(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Transparency {
        getTransparency(): number
    }
    interface IForgeItem {
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T>(arg0: Internal.ItemStack, arg1: number, arg2: T, arg3: (arg0: T) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        getDamage(arg0: Internal.ItemStack): number
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
    }
    interface SlotAccess {
    }
    interface Short2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Vector3f {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setY(arg0: number): void
        set(arg0: number[]): void
        setX(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        setZ(arg0: number): void
        notify(): void
        get class(): Internal.Class<any>;
        set x(arg0: number);
        set y(arg0: number);
        set z(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Requires$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ModuleDescriptor$Requires$Modifier
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ModuleDescriptor$Requires$Modifier[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Requires$Modifier): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Requires$Modifier>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly TRANSITIVE : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly STATIC : Internal.ModuleDescriptor$Requires$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface HierarchyListener extends Internal.EventListener {
        hierarchyChanged(arg0: Internal.HierarchyEvent): void
    }
    class TextHitInfo {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOffsetHit(arg0: number): Internal.TextHitInfo
        isLeadingEdge(): boolean
        static leading(arg0: number): Internal.TextHitInfo
        notifyAll(): void
        static afterOffset(arg0: number): Internal.TextHitInfo
        notify(): void
        getInsertionIndex(): number
        static beforeOffset(arg0: number): Internal.TextHitInfo
        getOtherHit(): Internal.TextHitInfo
        static trailing(arg0: number): Internal.TextHitInfo
        hashCode(): number
        equals(arg0: any): boolean
        equals(arg0: Internal.TextHitInfo): boolean
        toString(): string
        getCharIndex(): number
        get otherHit(): Internal.TextHitInfo;
        get charIndex(): number;
        get leadingEdge(): boolean;
        get insertionIndex(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CapabilityProvider <B> implements Internal.ICapabilityProviderImpl<B> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        invalidateCaps(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean
        toString(): string
        notify(): void
        reviveCaps(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AbstractContainerMenuInvoker {
        _moveItemStackTo(arg0: Internal.ItemStack, arg1: number, arg2: number, arg3: boolean): boolean
    }
    interface Byte2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class Enchantment extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Enchantment
        setRegistryName(arg0: string): Internal.Enchantment
        setRegistryName(arg0: string, arg1: string): Internal.Enchantment
        is(arg0: net.minecraft.tags.Tag<Internal.Enchantment>): boolean
        isAllowedOnBooks(): boolean
        getTags(): Internal.Set<ResourceLocation>
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.Enchantment>
        toString(): string
        canApplyAtEnchantingTable(arg0: Internal.ItemStack): boolean
        readonly delegate : () => Internal.Enchantment;
        get registryType(): Internal.Class<Internal.Enchantment>;
        get allowedOnBooks(): boolean;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockBehaviour$Properties {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        lootFrom(arg0: () => Internal.Block): Internal.BlockBehaviour$Properties
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Properties extends Internal.Hashtable<any, any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: any): any
        loadFromXML(arg0: Internal.InputStream): void
        keys(): Internal.Enumeration<any>
        notifyAll(): void
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any
        values(): Internal.Collection<any>
        save(arg0: Internal.OutputStream, arg1: string): void
        replace(arg0: any, arg1: any, arg2: any): boolean
        replace(arg0: any, arg1: any): any
        replaceAll(arg0: (arg0: any, arg1: any) => any): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: any, arg1: any): any
        remove(arg0: any): any
        remove(arg0: any, arg1: any): boolean
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        load(arg0: Internal.Reader): void
        load(arg0: Internal.InputStream): void
        hashCode(): number
        putAll(arg0: Internal.Map<any, any>): void
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        get(arg0: any): any
        keySet(): Internal.Set<any>
        getProperty(arg0: string): string
        getProperty(arg0: string, arg1: string): string
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: any, arg1: any) => void): void
        stringPropertyNames(): Internal.Set<string>
        isEmpty(): boolean
        clear(): void
        store(arg0: Internal.OutputStream, arg1: string): void
        store(arg0: Internal.Writer, arg1: string): void
        list(arg0: Internal.PrintStream): void
        list(arg0: Internal.PrintWriter): void
        storeToXML(arg0: Internal.OutputStream, arg1: string, arg2: string): void
        storeToXML(arg0: Internal.OutputStream, arg1: string): void
        storeToXML(arg0: Internal.OutputStream, arg1: string, arg2: Internal.Charset): void
        contains(arg0: any): boolean
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        size(): number
        propertyNames(): Internal.Enumeration<any>
        setProperty(arg0: string, arg1: string): any
        elements(): Internal.Enumeration<any>
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: any, arg1: any): any
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockEntityInstancingController <T> {
        createInstance(arg0: Internal.MaterialManager, arg1: T): Internal.BlockEntityInstance<T>
        shouldSkipRender(arg0: T): boolean
    }
    interface CommandSource {
    }
    interface ReadableByteChannel extends Internal.Channel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        close(): void
    }
    interface Float2ByteFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class OptionalDouble {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isEmpty(): boolean
        isPresent(): boolean
        getAsDouble(): number
        orElse(arg0: number): number
        notify(): void
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalDouble
        orElseGet(arg0: Internal.DoubleSupplier): number
        stream(): Internal.DoubleStream
        hashCode(): number
        ifPresent(arg0: Internal.DoubleConsumer): void
        ifPresentOrElse(arg0: Internal.DoubleConsumer, arg1: Internal.Runnable): void
        static of(arg0: number): Internal.OptionalDouble
        equals(arg0: any): boolean
        toString(): string
        get asDouble(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P10 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P15 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Char2IntFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class BlastFurnaceFuelRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CompositeByteBuf extends Internal.AbstractReferenceCountedByteBuf implements Internal.Iterable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        markReaderIndex(): Internal.CompositeByteBuf
        getByte(arg0: number): number
        release(): boolean
        release(arg0: number): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.CompositeByteBuf
        writeZero(arg0: number): Internal.ByteBuf
        addComponent(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: boolean, arg1: number, arg2: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        writeFloat(arg0: number): Internal.CompositeByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.CompositeByteBuf
        resetReaderIndex(): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        addComponents(arg0: boolean, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf
        addComponents(arg0: boolean, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        addComponents(arg0: number, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf
        addComponents(arg0: number, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        addComponents(arg0: Internal.ByteBuf[]): Internal.CompositeByteBuf
        addComponents(arg0: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        iterator(): Internal.Iterator<Internal.ByteBuf>
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        toByteIndex(arg0: number): number
        order(): Internal.ByteOrder
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        writeMedium(arg0: number): Internal.CompositeByteBuf
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        resetWriterIndex(): Internal.CompositeByteBuf
        spliterator(): Internal.Spliterator<Internal.ByteBuf>
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        internalComponentAtOffset(arg0: number): Internal.ByteBuf
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number): number
        nioBufferCount(): number
        discardReadComponents(): Internal.CompositeByteBuf
        setInt(arg0: number, arg1: number): Internal.CompositeByteBuf
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        markWriterIndex(): Internal.CompositeByteBuf
        isReadable(arg0: number): boolean
        isReadable(): boolean
        writeBoolean(arg0: boolean): Internal.CompositeByteBuf
        writeBoolean(arg0: boolean): Internal.ByteBuf
        numComponents(): number
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        retain(): Internal.CompositeByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.CompositeByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        isWritable(arg0: number): boolean
        isWritable(): boolean
        notify(): void
        readChar(): string
        capacity(arg0: number): Internal.ByteBuf
        capacity(arg0: number): Internal.CompositeByteBuf
        capacity(): number
        hasMemoryAddress(): boolean
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readDouble(): number
        readUnsignedShortLE(): number
        readFloat(): number
        internalComponent(arg0: number): Internal.ByteBuf
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(arg0: number, arg1: number): Internal.ByteBuf
        copy(): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        writeInt(arg0: number): Internal.ByteBuf
        writeInt(arg0: number): Internal.CompositeByteBuf
        ensureWritable(arg0: number): Internal.CompositeByteBuf
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        readFloatLE(): number
        getDoubleLE(arg0: number): number
        hasArray(): boolean
        memoryAddress(): number
        maxFastWritableBytes(): number
        consolidate(arg0: number, arg1: number): Internal.CompositeByteBuf
        consolidate(): Internal.CompositeByteBuf
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.CompositeByteBuf
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        component(arg0: number): Internal.ByteBuf
        readLong(): number
        readShort(): number
        equals(arg0: any): boolean
        getUnsignedMedium(arg0: number): number
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.CompositeByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: number): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.CompositeByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        readBoolean(): boolean
        toString(): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        isDirect(): boolean
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setMedium(arg0: number, arg1: number): Internal.CompositeByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.CompositeByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getClass(): Internal.Class<any>
        getFloatLE(arg0: number): number
        readerIndex(arg0: number): Internal.CompositeByteBuf
        readerIndex(arg0: number): Internal.ByteBuf
        readerIndex(): number
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuf): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        setShort(arg0: number, arg1: number): Internal.CompositeByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.CompositeByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.CompositeByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        writeByte(arg0: number): Internal.CompositeByteBuf
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        nioBuffer(): Internal.ByteBuffer
        touch(arg0: any): Internal.ReferenceCounted
        touch(arg0: any): Internal.ByteBuf
        touch(arg0: any): Internal.CompositeByteBuf
        touch(): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
        touch(): Internal.CompositeByteBuf
        discardSomeReadBytes(): Internal.CompositeByteBuf
        discardSomeReadBytes(): Internal.ByteBuf
        duplicate(): Internal.ByteBuf
        writerIndex(arg0: number): Internal.CompositeByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(): number
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        getChar(arg0: number): string
        retainedDuplicate(): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.CompositeByteBuf
        removeComponent(arg0: number): Internal.CompositeByteBuf
        readMedium(): number
        componentAtOffset(arg0: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.CompositeByteBuf
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.CompositeByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        getShortLE(arg0: number): number
        alloc(): Internal.ByteBufAllocator
        removeComponents(arg0: number, arg1: number): Internal.CompositeByteBuf
        readUnsignedShort(): number
        getMedium(arg0: number): number
        addFlattenedComponents(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        setByte(arg0: number, arg1: number): Internal.CompositeByteBuf
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        notifyAll(): void
        toComponentIndex(arg0: number): number
        decompose(arg0: number, arg1: number): Internal.List<Internal.ByteBuf>
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeLong(arg0: number): Internal.CompositeByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        hashCode(): number
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readLongLE(): number
        readUnsignedMediumLE(): number
        writeDouble(arg0: number): Internal.CompositeByteBuf
        writeDouble(arg0: number): Internal.ByteBuf
        maxNumComponents(): number
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        setFloat(arg0: number, arg1: number): Internal.CompositeByteBuf
        getShort(arg0: number): number
        forEach(arg0: (arg0: Internal.ByteBuf) => void): void
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        clear(): Internal.CompositeByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.CompositeByteBuf
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        writeChar(arg0: number): Internal.CompositeByteBuf
        isContiguous(): boolean
        writeDoubleLE(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Locale$FilteringMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Locale$FilteringMode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Locale$FilteringMode[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Locale$FilteringMode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$FilteringMode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Locale$FilteringMode>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly IGNORE_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly MAP_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly AUTOSELECT_FILTERING : Internal.Locale$FilteringMode;
        static readonly REJECT_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly EXTENDED_FILTERING : Internal.Locale$FilteringMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$FilteringMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WrappedJS {
    }
    class FileChannel$MapMode {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly READ_ONLY : Internal.FileChannel$MapMode;
        static readonly READ_WRITE : Internal.FileChannel$MapMode;
        static readonly PRIVATE : Internal.FileChannel$MapMode;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ForgeAccessorRegistry {
    }
    abstract class Executable extends Internal.AccessibleObject implements Internal.Member, Internal.GenericDeclaration {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getParameterCount(): number
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        isSynthetic(): boolean
        getAnnotatedParameterTypes(): Internal.AnnotatedType[]
        getParameterTypes(): Internal.Class<any>[]
        getGenericExceptionTypes(): Internal.Type[]
        notify(): void
        getAnnotatedReceiverType(): Internal.AnnotatedType
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaringClass(): Internal.Class<any>
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        hashCode(): number
        canAccess(arg0: any): boolean
        toGenericString(): string
        getTypeParameters(): any[]
        getModifiers(): number
        trySetAccessible(): boolean
        isAccessible(): boolean
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        isVarArgs(): boolean
        getAnnotations(): Internal.Annotation[]
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[]
        getExceptionTypes(): Internal.Class<any>[]
        getGenericParameterTypes(): Internal.Type[]
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        equals(arg0: any): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getParameters(): any[]
        toString(): string
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): Internal.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): Internal.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class UUID implements Internal.Serializable, Internal.Comparable<Internal.UUID> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        compareTo(arg0: Internal.UUID): number
        compareTo(arg0: any): number
        static nameUUIDFromBytes(arg0: number[]): Internal.UUID
        getLeastSignificantBits(): number
        version(): number
        notify(): void
        node(): number
        getMostSignificantBits(): number
        hashCode(): number
        equals(arg0: any): boolean
        variant(): number
        toString(): string
        static randomUUID(): Internal.UUID
        static fromString(arg0: string): Internal.UUID
        clockSequence(): number
        timestamp(): number
        get mostSignificantBits(): number;
        get class(): Internal.Class<any>;
        get leastSignificantBits(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Symbol {
    }
    interface ClipboardOwner {
        lostOwnership(arg0: Internal.Clipboard, arg1: Internal.Transferable): void
    }
    class Locale$Category extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Locale$Category
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Locale$Category[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Locale$Category): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$Category>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Locale$Category>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DISPLAY : Internal.Locale$Category;
        static readonly FORMAT : Internal.Locale$Category;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$Category>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Watchable {
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[], arg2: any[]): Internal.WatchKey
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[]): Internal.WatchKey
    }
    class VarHandle$VarHandleDesc extends Internal.DynamicConstantDesc<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc
        bootstrapMethod(): Internal.DirectMethodHandleDesc
        constantName(): string
        notifyAll(): void
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>
        static ofArray(arg0: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): Internal.VarHandle
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        notify(): void
        static ofField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
        static ofStaticField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
        varType(): Internal.ClassDesc
        constantType(): Internal.ClassDesc
        hashCode(): number
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>
        equals(arg0: any): boolean
        bootstrapArgs(): Internal.ConstantDesc[]
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        toString(): string
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveIterator$OfInt extends Internal.PrimitiveIterator<number, java_.util.function_.IntConsumer> {
        next(): any
        next(): number
        hasNext(): boolean
        nextInt(): number
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        remove(): void
    }
    interface Multiset$Entry <E> {
        hashCode(): number
        getElement(): E
        equals(arg0: any): boolean
        toString(): string
        getCount(): number
    }
    interface LongConsumer {
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        accept(arg0: number): void
    }
    class FieldPosition {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getEndIndex(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getFieldAttribute(): Internal.Format$Field
        getField(): number
        toString(): string
        setEndIndex(arg0: number): void
        setBeginIndex(arg0: number): void
        getBeginIndex(): number
        notify(): void
        get field(): number;
        get fieldAttribute(): Internal.Format$Field;
        get endIndex(): number;
        get beginIndex(): number;
        get class(): Internal.Class<any>;
        set endIndex(arg0: number);
        set beginIndex(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WeightedReward implements Internal.Comparable<Internal.WeightedReward> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(o: Internal.WeightedReward): number
        compareTo(arg0: any): number
        notify(): void
        static chanceString(weight: number, totalWeight: number): string
        static chanceString(weight: number, totalWeight: number, empty: boolean): string
        readonly reward : Internal.Reward;
        weight : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Unit {
        getClass(): Internal.Class<any>
        sub(with_: Internal.Unit): Internal.Unit
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mod(with_: Internal.Unit): Internal.Unit
        mul(with_: Internal.Unit): Internal.Unit
        log(): Internal.Unit
        log10(): Internal.Unit
        cos(): Internal.Unit
        log1p(): Internal.Unit
        notifyAll(): void
        deg(): Internal.Unit
        lt(with_: Internal.Unit): Internal.Unit
        atan(): Internal.Unit
        notify(): void
        getAsInt(): number
        div(with_: Internal.Unit): Internal.Unit
        neg(): Internal.Unit
        not(): Internal.Unit
        shiftLeft(with_: Internal.Unit): Internal.Unit
        min(with_: Internal.Unit): Internal.Unit
        rad(): Internal.Unit
        sqrt(): Internal.Unit
        hashCode(): number
        and(with_: Internal.Unit): Internal.Unit
        get(): number
        pow(with_: Internal.Unit): Internal.Unit
        sin(): Internal.Unit
        gte(with_: Internal.Unit): Internal.Unit
        xor(with_: Internal.Unit): Internal.Unit
        neq(with_: Internal.Unit): Internal.Unit
        floor(): Internal.Unit
        lte(with_: Internal.Unit): Internal.Unit
        isFixed(): boolean
        sq(): Internal.Unit
        atan2(with_: Internal.Unit): Internal.Unit
        tan(): Internal.Unit
        add(with_: Internal.Unit): Internal.Unit
        or(with_: Internal.Unit): Internal.Unit
        max(with_: Internal.Unit): Internal.Unit
        ceil(): Internal.Unit
        toBool(): Internal.Unit
        eq(with_: Internal.Unit): Internal.Unit
        gt(with_: Internal.Unit): Internal.Unit
        shiftRight(with_: Internal.Unit): Internal.Unit
        abs(): Internal.Unit
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        append(arg0: Internal.StringBuilder): void
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class QuestObjectType extends Internal.Enum<any> implements Internal.Predicate<Internal.QuestObjectBase> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: Internal.QuestObjectBase) => boolean): (arg0: Internal.QuestObjectBase) => boolean
        test(arg0: any): boolean
        test(object: Internal.QuestObjectBase): boolean
        static valueOf(name: string): (arg0: any) => boolean
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): (arg0: any) => boolean[]
        getColor(): Internal.ChatFormatting
        compareTo(arg0: any): number
        compareTo(arg0: (arg0: any) => boolean): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<(arg0: any) => boolean>>
        notify(): void
        getDeclaringClass(): Internal.Class<(arg0: any) => boolean>
        and(arg0: (arg0: Internal.QuestObjectBase) => boolean): (arg0: Internal.QuestObjectBase) => boolean
        negate(): (arg0: Internal.QuestObjectBase) => boolean
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly TASK : (arg0: any) => boolean;
        static readonly ALL_PROGRESSING_OR_NULL : (arg0: Internal.QuestObjectBase) => boolean;
        static readonly NULL : (arg0: any) => boolean;
        readonly translationKey : string;
        static readonly NAME_MAP : Internal.NameMap<(arg0: any) => boolean>;
        static readonly REWARD : (arg0: any) => boolean;
        static readonly ALL_PROGRESSING : (arg0: Internal.QuestObjectBase) => boolean;
        static readonly CHAPTER : (arg0: any) => boolean;
        static readonly CHAPTER_GROUP : (arg0: any) => boolean;
        readonly id : string;
        static readonly FILE : (arg0: any) => boolean;
        static readonly REWARD_TABLE : (arg0: any) => boolean;
        static readonly QUEST : (arg0: any) => boolean;
        get color(): Internal.ChatFormatting;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<(arg0: any) => boolean>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Rectangle2D extends Internal.RectangularShape {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersects(arg0: Internal.Rectangle2D): boolean
        notifyAll(): void
        getFrame(): Internal.Rectangle2D
        getWidth(): number
        notify(): void
        getBounds(): Internal.Rectangle
        setFrameFromCenter(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void
        getHeight(): number
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void
        setFrame(arg0: Internal.Point2D, arg1: Internal.Dimension2D): void
        setFrame(arg0: Internal.Rectangle2D): void
        hashCode(): number
        getCenterY(): number
        getCenterX(): number
        add(arg0: Internal.Point2D): void
        add(arg0: number, arg1: number): void
        add(arg0: Internal.Rectangle2D): void
        static intersect(arg0: Internal.Rectangle2D, arg1: Internal.Rectangle2D, arg2: Internal.Rectangle2D): void
        isEmpty(): boolean
        getMaxX(): number
        getMaxY(): number
        setRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        setRect(arg0: Internal.Rectangle2D): void
        static union(arg0: Internal.Rectangle2D, arg1: Internal.Rectangle2D, arg2: Internal.Rectangle2D): void
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void
        setFrameFromDiagonal(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        getX(): number
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point2D): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersectsLine(arg0: Internal.Line2D): boolean
        getY(): number
        createUnion(arg0: Internal.Rectangle2D): Internal.Rectangle2D
        equals(arg0: any): boolean
        outcode(arg0: number, arg1: number): number
        outcode(arg0: Internal.Point2D): number
        clone(): any
        getBounds2D(): Internal.Rectangle2D
        toString(): string
        createIntersection(arg0: Internal.Rectangle2D): Internal.Rectangle2D
        getMinX(): number
        getMinY(): number
        static readonly OUT_TOP : 2;
        static readonly OUT_RIGHT : 4;
        static readonly OUT_BOTTOM : 8;
        static readonly OUT_LEFT : 1;
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        get height(): number;
        set rect(arg0: Internal.Rectangle2D);
        set frame(arg0: Internal.Rectangle2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WriteBufferWaterMark {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        high(): number
        low(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly DEFAULT : Internal.WriteBufferWaterMark;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarForecast {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getLastCheckedGameTime(): number
        toString(): string
        getForecast(): Internal.List<Internal.LunarEventInstance>
        notify(): void
        setLastCheckedGameTime(arg0: number): void
        static readonly CODEC : Internal.Codec<Internal.LunarForecast>;
        get forecast(): Internal.List<Internal.LunarEventInstance>;
        get class(): Internal.Class<any>;
        get lastCheckedGameTime(): number;
        set lastCheckedGameTime(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FileNameMap {
        getContentTypeFor(arg0: string): string
    }
    class Proxy$Type extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Proxy$Type
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Proxy$Type[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Proxy$Type): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Proxy$Type>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Proxy$Type>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SOCKS : Internal.Proxy$Type;
        static readonly HTTP : Internal.Proxy$Type;
        static readonly DIRECT : Internal.Proxy$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Proxy$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Table <R, C, V> {
        cellSet(): Internal.Set<Internal.Table$Cell<R, C, V>>
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        column(arg0: C): Internal.Map<R, V>
        containsValue(arg0: any): boolean
        put(arg0: R, arg1: C, arg2: V): V
        remove(arg0: any, arg1: any): V
        contains(arg0: any, arg1: any): boolean
        columnMap(): Internal.Map<C, Internal.Map<R, V>>
        size(): number
        containsColumn(arg0: any): boolean
        hashCode(): number
        columnKeySet(): Internal.Set<C>
        putAll(arg0: Internal.Table<R, C, V>): void
        equals(arg0: any): boolean
        get(arg0: any, arg1: any): V
        rowKeySet(): Internal.Set<R>
        rowMap(): Internal.Map<R, Internal.Map<C, V>>
        row(arg0: R): Internal.Map<C, V>
        containsRow(arg0: any): boolean
    }
    abstract class CreativeModeTab {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getLabelColor(): number
        getSearchbarWidth(): number
        setBackgroundImage(arg0: ResourceLocation): Internal.CreativeModeTab
        static getGroupCountSafe(): number
        notify(): void
        hasSearchBar(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getBackgroundImage(): ResourceLocation
        getSlotColor(): number
        getTabsImage(): ResourceLocation
        getTabPage(): number
        get tabsImage(): ResourceLocation;
        get slotColor(): number;
        get backgroundImage(): ResourceLocation;
        get tabPage(): number;
        get searchbarWidth(): number;
        get groupCountSafe(): number;
        get class(): Internal.Class<any>;
        get labelColor(): number;
        set backgroundImage(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Stat <T> extends Internal.ObjectiveCriteria {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getValue(): V
        getKey(): number
        getKey(): any
        getIntKey(): number
        hashCode(): number
        setValue(arg0: V): V
        equals(arg0: any): boolean
    }
    interface EntityTypeTest <B, T> {
    }
    class PopupMenu extends Internal.Menu {
        setName(arg0: string): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getLabel(): string
        notifyAll(): void
        getItemCount(): number
        show(arg0: java_.awt.Component, arg1: number, arg2: number): void
        getItem(arg0: number): Internal.MenuItem
        insert(arg0: string, arg1: number): void
        insert(arg0: Internal.MenuItem, arg1: number): void
        isTearOff(): boolean
        getShortcut(): Internal.MenuShortcut
        notify(): void
        remove(arg0: Internal.MenuComponent): void
        remove(arg0: number): void
        paramString(): string
        removeAll(): void
        removeActionListener(arg0: Internal.ActionListener): void
        addSeparator(): void
        hashCode(): number
        enable(): void
        enable(arg0: boolean): void
        setFont(arg0: java_.awt.Font): void
        setShortcut(arg0: Internal.MenuShortcut): void
        add(arg0: string): void
        add(arg0: Internal.MenuItem): Internal.MenuItem
        getParent(): Internal.MenuContainer
        dispatchEvent(arg0: Internal.AWTEvent): void
        deleteShortcut(): void
        addActionListener(arg0: Internal.ActionListener): void
        countItems(): number
        setActionCommand(arg0: string): void
        getAccessibleContext(): Internal.AccessibleContext
        postEvent(arg0: Internal.Event): boolean
        setEnabled(arg0: boolean): void
        addNotify(): void
        disable(): void
        equals(arg0: any): boolean
        isEnabled(): boolean
        getActionListeners(): Internal.ActionListener[]
        setLabel(arg0: string): void
        removeNotify(): void
        toString(): string
        getFont(): java_.awt.Font
        getActionCommand(): string
        insertSeparator(arg0: number): void
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get tearOff(): boolean;
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get itemCount(): number;
        get font(): java_.awt.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StageCreationEvent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.Player
        setPlayerStages(s: Internal.Stages): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        getPlayerStages(): Internal.Stages
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        set playerStages(s: Internal.Stages);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Translate <Self> {
        translateZ(arg0: number): Self
        translateAll(arg0: number): Self
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        centre(): Self
        unCentre(): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        translateBack(arg0: Vec3): Self
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        translate(arg0: number, arg1: number, arg2: number): Self
        nudge(arg0: number): Self
    }
    class SoundType implements Internal.AccessorSoundType {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        botania_getBreakSound(): Internal.SoundEvent
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface OrderedEventExecutor extends Internal.EventExecutor {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        next(): Internal.EventExecutor
        terminationFuture(): Internal.Future<any>
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>
        submit(arg0: Internal.Runnable): Internal.Future<any>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        shutdownGracefully(): Internal.Future<any>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>
        spliterator(): Internal.Spliterator<Internal.EventExecutor>
        isTerminated(): boolean
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>
        execute(arg0: Internal.Runnable): void
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        isShuttingDown(): boolean
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        newPromise<V_>(): Internal.Promise<V_>
    }
    class Products$P7 <F, T1, T2, T3, T4, T5, T6, T7> {
        t4(): Internal.App<F, T4>
        getClass(): Internal.Class<any>
        t5(): Internal.App<F, T5>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        t6(): Internal.App<F, T6>
        t7(): Internal.App<F, T7>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.App<F, R>
        notifyAll(): void
        notify(): void
        hashCode(): number
        and<T8>(arg0: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class URL implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static setURLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory): void
        getDefaultPort(): number
        openConnection(): Internal.URLConnection
        openConnection(arg0: Internal.Proxy): Internal.URLConnection
        notifyAll(): void
        toURI(): Internal.URI
        getContent(): any
        getContent(arg0: Internal.Class<any>[]): any
        getProtocol(): string
        getAuthority(): string
        getFile(): string
        openStream(): Internal.InputStream
        notify(): void
        toExternalForm(): string
        getPort(): number
        getRef(): string
        sameFile(arg0: Internal.URL): boolean
        hashCode(): number
        equals(arg0: any): boolean
        getPath(): string
        toString(): string
        getUserInfo(): string
        getQuery(): string
        getHost(): string
        get defaultPort(): number;
        get path(): string;
        get userInfo(): string;
        get protocol(): string;
        get ref(): string;
        get file(): string;
        get port(): number;
        get authority(): string;
        get query(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get content(): any;
        set uRLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TStack <Self> {
        pushPose(): Self
        popPose(): Self
    }
    interface IForgeBakedModel {
        doesHandlePerspectives(): boolean
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData
        isLayered(): boolean
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>
        useAmbientOcclusion(arg0: Internal.BlockState): boolean
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite
    }
    interface ChannelFuture extends Internal.Future<void> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        getNow(): void
        channel(): io.netty.channel.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): Internal.Future<void>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        isDone(): boolean
        sync(): Internal.ChannelFuture
        sync(): Internal.Future<void>
        isVoid(): boolean
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): Internal.Future<void>
        get(): void
        get(arg0: number, arg1: Internal.TimeUnit): void
        isCancellable(): boolean
        await(): Internal.ChannelFuture
        await(): Internal.Future<void>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
    }
    class BufferCapabilities implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isFullScreenRequired(): boolean
        notifyAll(): void
        getFrontBufferCapabilities(): Internal.ImageCapabilities
        notify(): void
        getFlipContents(): Internal.BufferCapabilities$FlipContents
        isPageFlipping(): boolean
        hashCode(): number
        getBackBufferCapabilities(): Internal.ImageCapabilities
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        isMultiBufferAvailable(): boolean
        get pageFlipping(): boolean;
        get fullScreenRequired(): boolean;
        get flipContents(): Internal.BufferCapabilities$FlipContents;
        get frontBufferCapabilities(): Internal.ImageCapabilities;
        get backBufferCapabilities(): Internal.ImageCapabilities;
        get multiBufferAvailable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ResourceBundle$Control {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getControl(arg0: Internal.List<string>): Internal.ResourceBundle$Control
        toBundleName(arg0: string, arg1: Internal.Locale): string
        notifyAll(): void
        getFormats(arg0: string): Internal.List<string>
        newBundle(arg0: string, arg1: Internal.Locale, arg2: string, arg3: Internal.ClassLoader, arg4: boolean): Internal.ResourceBundle
        getTimeToLive(arg0: string, arg1: Internal.Locale): number
        getFallbackLocale(arg0: string, arg1: Internal.Locale): Internal.Locale
        notify(): void
        getCandidateLocales(arg0: string, arg1: Internal.Locale): Internal.List<Internal.Locale>
        static getNoFallbackControl(arg0: Internal.List<string>): Internal.ResourceBundle$Control
        hashCode(): number
        equals(arg0: any): boolean
        needsReload(arg0: string, arg1: Internal.Locale, arg2: string, arg3: Internal.ClassLoader, arg4: Internal.ResourceBundle, arg5: number): boolean
        toString(): string
        toResourceName(arg0: string, arg1: string): string
        static readonly FORMAT_PROPERTIES : Internal.List<string>;
        static readonly TTL_DONT_CACHE : -1;
        static readonly FORMAT_DEFAULT : Internal.List<string>;
        static readonly TTL_NO_EXPIRATION_CONTROL : -2;
        static readonly FORMAT_CLASS : Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodHandleInfo {
        getReferenceKind(): number
        getDeclaringClass(): Internal.Class<any>
        getName(): string
        isVarArgs(): boolean
        getMethodType(): Internal.MethodType
        reflectAs<T>(arg0: Internal.Class<T>, arg1: Internal.MethodHandles$Lookup): T
        getModifiers(): number
    }
    interface ChronoZonedDateTime <D> extends Internal.Temporal, Internal.Comparable<Internal.ChronoZonedDateTime<any>> {
        minus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<D>
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<D>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        isEqual(arg0: Internal.ChronoZonedDateTime<any>): boolean
        getOffset(): Internal.ZoneOffset
        toLocalTime(): Internal.LocalTime
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: Internal.ChronoZonedDateTime<any>): number
        compareTo(arg0: any): number
        withLaterOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>
        getChronology(): Internal.Chronology
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        format(arg0: Internal.DateTimeFormatter): string
        getZone(): Internal.ZoneId
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.ChronoZonedDateTime<any>): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<D>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<D>
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoZonedDateTime<D>
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoZonedDateTime<D>
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        toLocalDate(): D
        toEpochSecond(): number
        toLocalDateTime(): Internal.ChronoLocalDateTime<D>
        equals(arg0: any): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        isAfter(arg0: Internal.ChronoZonedDateTime<any>): boolean
    }
    interface ChannelInboundInvoker {
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker
        fireChannelInactive(): Internal.ChannelInboundInvoker
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelInboundInvoker
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
        fireChannelRegistered(): Internal.ChannelInboundInvoker
    }
    class MapJS extends Internal.LinkedHashMap<any, any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>
        static nbt(map: any): Internal.CompoundTag
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: any): any
        notifyAll(): void
        computeIfAbsent(arg0: string, arg1: (arg0: string) => any): any
        values(): Internal.Collection<any>
        replace(arg0: string, arg1: any, arg2: any): boolean
        replace(arg0: string, arg1: any): any
        static isNbt(o: any): boolean
        replaceAll(arg0: (arg0: string, arg1: any) => any): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: any, arg1: any): any
        put(key: string, value: any): any
        remove(key: any): any
        remove(arg0: any, arg1: any): boolean
        compute(arg0: string, arg1: (arg0: string, arg1: any) => any): any
        toNBT(): Internal.Tag
        toNBT(): Internal.CompoundTag
        getOrNewList(id: string): Internal.ListJS
        hashCode(): number
        merge(arg0: string, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        get(arg0: any): any
        putAll(m: Internal.Map<string, any>): void
        static of(o: any): Internal.MapJS
        static json(map: any): Internal.JsonObject
        copy(): Internal.MapJS
        copy(): Internal.Copyable
        keySet(): Internal.Set<string>
        appendString(builder: Internal.StringBuilder): void
        onChanged(o: any): void
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: string, arg1: any) => void): void
        containsAll(other: Internal.MapJS): boolean
        isEmpty(): boolean
        clear(): void
        containsAny(other: Internal.MapJS): boolean
        toJson(): Internal.JsonObject
        toJson(): Internal.JsonElement
        computeIfPresent(arg0: string, arg1: (arg0: string, arg1: any) => any): any
        size(): number
        getOrNewMap(id: string): Internal.MapJS
        equals(arg0: any): boolean
        clone(): any
        getLength(): number
        toString(): string
        putIfAbsent(arg0: string, arg1: any): any
        changeListener : Internal.ChangeListener<Internal.MapJS>;
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ChapterImage implements Internal.Movable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        move(to: Internal.Chapter, _x: number, _y: number): void
        readData(nbt: Internal.CompoundTag): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getShape(): string
        getWidth(): number
        writeData(nbt: Internal.CompoundTag): void
        notify(): void
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getChapter(): Internal.Chapter
        getConfig(config: Internal.ConfigGroup): void
        drawMoved(matrixStack: Internal.PoseStack): void
        getHeight(): number
        getX(): number
        getY(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        chapter : Internal.Chapter;
        image : Internal.Icon;
        hover : Internal.List<string>;
        dev : boolean;
        corner : boolean;
        dependency : Internal.Quest;
        rotation : number;
        x : number;
        width : number;
        y : number;
        click : string;
        height : number;
        get shape(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockHitResult extends Internal.HitResult {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelProperty <T> implements Internal.Predicate<T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntryMessage extends Internal.FlowMessage {
        getText(): string
        getParameters(): any[]
        getFormattedMessage(): string
        getMessage(): org.apache.logging.log4j.message.Message
        getFormat(): string
        getThrowable(): Internal.Throwable
    }
    class ChannelOutboundBuffer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isWritable(): boolean
        notify(): void
        remove(arg0: Internal.Throwable): boolean
        remove(): boolean
        addMessage(arg0: any, arg1: number, arg2: Internal.ChannelPromise): void
        addFlush(): void
        totalPendingWriteBytes(): number
        forEachFlushedMessage(arg0: Internal.ChannelOutboundBuffer$MessageProcessor): void
        current(): any
        setUserDefinedWritability(arg0: number, arg1: boolean): void
        hashCode(): number
        nioBufferSize(): number
        recycle(): void
        bytesBeforeWritable(): number
        currentProgress(): number
        bytesBeforeUnwritable(): number
        getUserDefinedWritability(arg0: number): boolean
        isEmpty(): boolean
        removeBytes(arg0: number): void
        nioBufferCount(): number
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        nioBuffers(): Internal.ByteBuffer[]
        size(): number
        equals(arg0: any): boolean
        progress(arg0: number): void
        toString(): string
        get class(): Internal.Class<any>;
        get writable(): boolean;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleTable {
        getAccessibleRowHeader(): Internal.AccessibleTable
        getSelectedAccessibleRows(): number[]
        getAccessibleColumnHeader(): Internal.AccessibleTable
        getAccessibleColumnDescription(arg0: number): Internal.Accessible
        getAccessibleSummary(): Internal.Accessible
        setAccessibleRowDescription(arg0: number, arg1: Internal.Accessible): void
        setAccessibleColumnHeader(arg0: Internal.AccessibleTable): void
        getAccessibleRowDescription(arg0: number): Internal.Accessible
        getAccessibleAt(arg0: number, arg1: number): Internal.Accessible
        getSelectedAccessibleColumns(): number[]
        setAccessibleRowHeader(arg0: Internal.AccessibleTable): void
        getAccessibleRowExtentAt(arg0: number, arg1: number): number
        getAccessibleColumnCount(): number
        setAccessibleCaption(arg0: Internal.Accessible): void
        getAccessibleColumnExtentAt(arg0: number, arg1: number): number
        getAccessibleRowCount(): number
        isAccessibleSelected(arg0: number, arg1: number): boolean
        setAccessibleColumnDescription(arg0: number, arg1: Internal.Accessible): void
        isAccessibleColumnSelected(arg0: number): boolean
        getAccessibleCaption(): Internal.Accessible
        setAccessibleSummary(arg0: Internal.Accessible): void
        isAccessibleRowSelected(arg0: number): boolean
    }
    class OptionalDynamic <T> extends Internal.DynamicLike<any> {
        createLong(arg0: number): Internal.Dynamic<T>
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>
        getClass(): Internal.Class<any>
        getElementGeneric(arg0: T): Internal.DataResult<T>
        getElementGeneric(arg0: T, arg1: T): T
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: (arg0: K_) => Internal.Decoder<V_>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K_, V_>>>
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: Internal.Decoder<V_>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K_, V_>>>
        readMap<R_>(arg0: Internal.DataResult<R_>, arg1: Internal.Function3<R_, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R_>>): Internal.DataResult<R_>
        asListOpt<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<Internal.List<U_>>
        orElseEmptyList(): Internal.Dynamic<T>
        createShort(arg0: number): Internal.Dynamic<T>
        decode<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<com.mojang.datafixers.util.Pair<A_, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        asList<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.List<U_>
        readList<E_>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E_>): Internal.DataResult<Internal.List<E_>>
        readList<E_>(arg0: Internal.Decoder<E_>): Internal.DataResult<Internal.List<E_>>
        asString(): Internal.DataResult<string>
        asString(arg0: string): string
        asByte(arg0: number): number
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>
        read<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<A_>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        createString(arg0: string): Internal.Dynamic<T>
        getGeneric(arg0: T): Internal.DataResult<T>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        asMapOpt<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<Internal.Map<K_, V_>>
        asStream(): Internal.Stream<Internal.Dynamic<T>>
        createByte(arg0: number): Internal.Dynamic<T>
        asLong(arg0: number): number
        flatMap<U_>(arg0: (arg0: Internal.Dynamic<T>) => Internal.DataResult<U_>): Internal.DataResult<U_>
        asDouble(arg0: number): number
        asBoolean(arg0: boolean): boolean
        createDouble(arg0: number): Internal.Dynamic<T>
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        asMap<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.Map<K_, V_>
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        notifyAll(): void
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>
        asIntStream(): Internal.IntStream
        asByteBuffer(): Internal.ByteBuffer
        asFloat(arg0: number): number
        asLongStream(): Internal.LongStream
        notify(): void
        createBoolean(arg0: boolean): Internal.Dynamic<T>
        result(): Internal.Optional<Internal.Dynamic<T>>
        asInt(arg0: number): number
        into<V_>(arg0: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<V_>
        emptyList(): Internal.Dynamic<T>
        hashCode(): number
        asShort(arg0: number): number
        get(): Internal.DataResult<Internal.Dynamic<T>>
        get(arg0: string): Internal.OptionalDynamic<T>
        emptyMap(): Internal.Dynamic<T>
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>
        map<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<U_>
        orElseEmptyMap(): Internal.Dynamic<T>
        asNumber(): Internal.DataResult<Internal.Number>
        asNumber(arg0: Internal.Number): Internal.Number
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>
        createFloat(arg0: number): Internal.Dynamic<T>
        getOps(): Internal.DynamicOps<T>
        getElement(arg0: string): Internal.DataResult<T>
        getElement(arg0: string, arg1: T): T
        equals(arg0: any): boolean
        createInt(arg0: number): Internal.Dynamic<T>
        toString(): string
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemHandler extends Internal.Iterable<Internal.ItemStack> {
        iterator(): Internal.Iterator<Internal.ItemStack>
        getHeight(): number
        spliterator(): Internal.Spliterator<Internal.ItemStack>
        extractItem(arg0: number, arg1: number, arg2: boolean): Internal.ItemStack
        forEach(arg0: (arg0: Internal.ItemStack) => void): void
        getSlotLimit(arg0: number): number
        isItemValid(arg0: number, arg1: Internal.ItemStack): boolean
        getWidth(): number
        getSlots(): number
        getStackInSlot(arg0: number): Internal.ItemStack
        insertItem(arg0: number, arg1: Internal.ItemStack, arg2: boolean): Internal.ItemStack
    }
    abstract class LivingEntityEventJS extends Internal.EntityEventJS {
        cancel(): void
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        notifyAll(): void
        getEntity(): Internal.EntityJS
        notify(): void
        getLevel(): Internal.LevelJS
        post(id: string, sub: string): boolean
        post(id: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        canCancel(): boolean
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MalumSpiritFocusingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        durabilityCost(durabilityCost: number): Internal.MalumSpiritFocusingRecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(time: number): Internal.MalumSpiritFocusingRecipeJS
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2LongFunction extends Internal.Function<string, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Transform <Self> extends Internal.Translate<Self>, Internal.Rotate<Self>, Internal.Scale<Self> {
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: (arg0: any) => boolean): Self
        translateAll(arg0: number): Self
        rotateCentered(arg0: Internal.Direction, arg1: number): Self
        rotateCentered(arg0: Internal.Quaternion): Self
        scale(arg0: number, arg1: number, arg2: number): Self
        scale(arg0: number): Self
        centre(): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        translate(arg0: number, arg1: number, arg2: number): Self
        rotateZRadians(arg0: number): Self
        translateZ(arg0: number): Self
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Self
        transform(arg0: Internal.PoseStack): Self
        mulNormal(arg0: Internal.Matrix3f): Self
        mulPose(arg0: Internal.Matrix4f): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        unCentre(): Self
        multiply(arg0: Internal.Quaternion): Self
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        translateBack(arg0: Vec3): Self
        rotateToFace(arg0: Internal.Direction): Self
        rotateZ(arg0: number): Self
        nudge(arg0: number): Self
    }
    abstract class PlayerJS <E> extends Internal.LivingEntityJS implements Internal.WithAttachedData {
        getXpLevel(): number
        getLastAttackedEntity(): Internal.LivingEntityJS
        sendData(channel: string, data: Internal.CompoundTag): void
        setY(y: number): void
        setX(x: number): void
        isOnScoreboardTeam(teamID: string): boolean
        isLiving(): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        getRevengeTarget(): Internal.LivingEntityJS
        paint(arg0: Internal.CompoundTag): void
        getTags(): Internal.Set<string>
        getOffHandItem(): Internal.ItemStackJS
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        setXpLevel(l: number): void
        getHasCustomName(): boolean
        setInvisible(invisible: boolean): void
        runCommandSilent(command: string): number
        getIdleTime(): number
        getMovementSpeed(): number
        setSelectedSlot(index: number): void
        isBoss(): boolean
        getDistanceSq(x: number, y: number, z: number): number
        getDistanceSq(pos: BlockPos): number
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        addFood(f: number, m: number): void
        getHealth(): number
        setLegsArmorItem(item: string): void
        setLegsArmorItem(item: Internal.ItemStackJS): void
        setLegsArmorItem(item: object): void
        getServer(): Internal.ServerJS
        setFeetArmorItem(item: string): void
        setFeetArmorItem(item: Internal.ItemStackJS): void
        setFeetArmorItem(item: object): void
        give(item: string): void
        give(item: Internal.ItemStackJS): void
        give(item: object): void
        setMaxHealth(hp: number): void
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        isMiningBlock(): boolean
        isSpectator(): boolean
        setAbsorptionAmount(amount: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getDisplayName(): Internal.Text
        getType(): string
        getXp(): number
        addExhaustion(exhaustion: number): void
        setCustomNameAlwaysVisible(b: boolean): void
        setOffHandItem(item: string): void
        setOffHandItem(item: Internal.ItemStackJS): void
        setOffHandItem(item: object): void
        getFoodLevel(): number
        addMotion(x: number, y: number, z: number): void
        isFake(): boolean
        isInvisible(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaxHealth(): number
        isUnderWater(): boolean
        getHeldItem(hand: Hand): Internal.ItemStackJS
        getEyeHeight(): number
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS
        notify(): void
        getFallDistance(): number
        damageHeldItem(): void
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageHeldItem(hand: Hand, amount: number): void
        setAirSupply(air: number): void
        setOnFire(seconds: number): void
        removePassengers(): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        isUndead(): boolean
        isOnLadder(): boolean
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        getInventory(): Internal.InventoryJS
        boostElytraFlight(): void
        getData(): Internal.AttachedData
        getDistance(x: number, y: number, z: number): number
        getDistance(pos: BlockPos): number
        getLastDamageSource(): Internal.DamageSourceJS
        setStatusMessage(message: Internal.Component): void
        isSwimming(): boolean
        getReachDistance(): number
        getCustomName(): Internal.Text
        getStepHeight(): number
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        getLastAttackedEntityTime(): number
        isMonster(): boolean
        equals(arg0: any): boolean
        addItemCooldown(item: Internal.Item, ticks: number): void
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        isOnGround(): boolean
        toString(): string
        isSilent(): boolean
        isPassenger(e: Internal.EntityJS): boolean
        setXp(xp: number): void
        getMaxAirSupply(): number
        getClass(): Internal.Class<any>
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        getName(): Internal.Text
        setFallDistance(fallDistance: number): void
        getFeetArmorItem(): Internal.ItemStackJS
        sendInventoryUpdate(): void
        setCustomName(name: Internal.Component): void
        setMainHandItem(item: string): void
        setMainHandItem(item: Internal.ItemStackJS): void
        setMainHandItem(item: object): void
        setStepHeight(stepHeight: number): void
        tell(message: Internal.Component): void
        getTeamId(): string
        isWaterCreature(): boolean
        setNoClip(noClip: boolean): void
        setPosition(x: number, y: number, z: number): void
        setPosition(block: Internal.BlockContainerJS): void
        closeInventory(): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        setRevengeTarget(target: Internal.LivingEntityJS): void
        setMovementSpeed(speed: number): void
        isChild(): boolean
        setEquipment(slot: EquipmentSlot, item: string): void
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void
        setEquipment(slot: EquipmentSlot, item: object): void
        giveInHand(item: string): void
        giveInHand(item: Internal.ItemStackJS): void
        giveInHand(item: object): void
        getAirSupply(): number
        getLegsArmorItem(): Internal.ItemStackJS
        setFullNBT(nbt: Internal.CompoundTag): void
        getAttackingEntity(): Internal.LivingEntityJS
        isHoldingInAnyHand(ingredient: any): boolean
        isCreativeMode(): boolean
        getNoClip(): boolean
        getFullNBT(): Internal.CompoundTag
        setYaw(yaw: number): void
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageEquipment(slot: EquipmentSlot, amount: number): void
        damageEquipment(slot: EquipmentSlot): void
        isAlive(): boolean
        getYaw(): number
        getHeadArmorItem(): Internal.ItemStackJS
        setNoGravity(noGravity: boolean): void
        setMouseItem(item: string): void
        setMouseItem(item: Internal.ItemStackJS): void
        setMouseItem(item: object): void
        setHeldItem(hand: Hand, item: string): void
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void
        setHeldItem(hand: Hand, item: object): void
        isPlayer(): boolean
        getRevengeTimer(): number
        getStats(): Internal.PlayerStatsJS
        getAbsorptionAmount(): number
        isCrouching(): boolean
        notifyAll(): void
        getId(): Internal.UUID
        addXPLevels(l: number): void
        getTicksExisted(): number
        getStages(): Internal.Stages
        getOpenInventory(): Internal.AbstractContainerMenu
        setSilent(isSilent: boolean): void
        hashCode(): number
        getChestArmorItem(): Internal.ItemStackJS
        isFrame(): boolean
        heal(hp: number): void
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        setChestArmorItem(item: string): void
        setChestArmorItem(item: Internal.ItemStackJS): void
        setChestArmorItem(item: object): void
        getCustomNameAlwaysVisible(): boolean
        addXP(xp: number): void
        getMainHandItem(): Internal.ItemStackJS
        setHealth(hp: number): void
        setMotionZ(z: number): void
        setMotionY(y: number): void
        getBlock(): Internal.BlockContainerJS
        setMotionX(x: number): void
        isElytraFlying(): boolean
        isInWater(): boolean
        dismountRidingEntity(): void
        isSleeping(): boolean
        isAmbientCreature(): boolean
        getPotionEffects(): Internal.EntityPotionEffectsJS
        swingArm(hand: Hand): void
        rayTrace(): Internal.RayTraceResultJS
        rayTrace(distance: number): Internal.RayTraceResultJS
        isInvulnerable(): boolean
        setHeadArmorItem(item: string): void
        setHeadArmorItem(item: Internal.ItemStackJS): void
        setHeadArmorItem(item: object): void
        getSelectedSlot(): number
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean
        getX(): number
        getY(): number
        spawn(): void
        getZ(): number
        isPeacefulCreature(): boolean
        getMouseItem(): Internal.ItemStackJS
        setFoodLevel(foodLevel: number): void
        getMotionZ(): number
        getMotionX(): number
        getNoGravity(): boolean
        getMotionY(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get data(): Internal.AttachedData;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get feetArmorItem(): Internal.ItemStackJS;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get child(): boolean;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get airSupply(): number;
        get sleeping(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get headArmorItem(): Internal.ItemStackJS;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get health(): number;
        get inWater(): boolean;
        get chestArmorItem(): Internal.ItemStackJS;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get attackingEntity(): Internal.LivingEntityJS;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get spectator(): boolean;
        get xp(): number;
        get stages(): Internal.Stages;
        get x(): number;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: string);
        set mainHandItem(item: Internal.ItemStackJS);
        set mainHandItem(item: object);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: string);
        set legsArmorItem(item: Internal.ItemStackJS);
        set legsArmorItem(item: object);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: string);
        set headArmorItem(item: Internal.ItemStackJS);
        set headArmorItem(item: object);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: string);
        set feetArmorItem(item: Internal.ItemStackJS);
        set feetArmorItem(item: object);
        set offHandItem(item: string);
        set offHandItem(item: Internal.ItemStackJS);
        set offHandItem(item: object);
        set chestArmorItem(item: string);
        set chestArmorItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: object);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set mouseItem(item: string);
        set mouseItem(item: Internal.ItemStackJS);
        set mouseItem(item: object);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Nameable {
    }
    class RandomTickCallbackJS {
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        getLevel(): Internal.LevelJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        random : Internal.Random;
        block : Internal.BlockContainerJS;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Scriptable extends Internal.IdEnumerationIterator {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        hasInstance(arg0: Internal.Scriptable): boolean
        setParentScope(arg0: Internal.Scriptable): void
        getIds(): any[]
        getAllIds(): any[]
        delete(arg0: string): void
        delete(arg0: number): void
        put(arg0: string, arg1: Internal.Scriptable, arg2: any): void
        put(arg0: number, arg1: Internal.Scriptable, arg2: any): void
        getDefaultValue(arg0: Internal.Class<any>): any
        setPrototype(arg0: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        get(arg0: number, arg1: Internal.Scriptable): any
        get(arg0: string, arg1: Internal.Scriptable): any
        has(arg0: string, arg1: Internal.Scriptable): boolean
        has(arg0: number, arg1: Internal.Scriptable): boolean
        getClassName(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getParentScope(): Internal.Scriptable
    }
    abstract class Toolkit {
        beep(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isModalityTypeSupported(arg0: Internal.Dialog$ModalityType): boolean
        createDragGestureRecognizer<T>(arg0: Internal.Class<T>, arg1: Internal.DragSource, arg2: java_.awt.Component, arg3: number, arg4: Internal.DragGestureListener): T
        notifyAll(): void
        getScreenInsets(arg0: Internal.GraphicsConfiguration): Internal.Insets
        getMenuShortcutKeyMaskEx(): number
        addAWTEventListener(arg0: Internal.AWTEventListener, arg1: number): void
        notify(): void
        getLockingKeyState(arg0: number): boolean
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        areExtraMouseButtonsEnabled(): boolean
        getAWTEventListeners(arg0: number): Internal.AWTEventListener[]
        getAWTEventListeners(): Internal.AWTEventListener[]
        checkImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): number
        getScreenResolution(): number
        removeAWTEventListener(arg0: Internal.AWTEventListener): void
        getPrintJob(arg0: Internal.Frame, arg1: string, arg2: Internal.JobAttributes, arg3: Internal.PageAttributes): Internal.PrintJob
        getPrintJob(arg0: Internal.Frame, arg1: string, arg2: Internal.Properties): Internal.PrintJob
        hashCode(): number
        getSystemEventQueue(): Internal.EventQueue
        getBestCursorSize(arg0: number, arg1: number): Internal.Dimension
        createCustomCursor(arg0: Internal.Image, arg1: Internal.Point, arg2: string): Internal.Cursor
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        getScreenSize(): Internal.Dimension
        isFrameStateSupported(arg0: number): boolean
        isAlwaysOnTopSupported(): boolean
        getSystemClipboard(): Internal.Clipboard
        getDesktopProperty(arg0: string): any
        getFontList(): string[]
        static getProperty(arg0: string, arg1: string): string
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[]
        getPropertyChangeListeners(): Internal.PropertyChangeListener[]
        getColorModel(): Internal.ColorModel
        createImage(arg0: number[], arg1: number, arg2: number): Internal.Image
        createImage(arg0: number[]): Internal.Image
        createImage(arg0: Internal.URL): Internal.Image
        createImage(arg0: string): Internal.Image
        createImage(arg0: Internal.ImageProducer): Internal.Image
        static getDefaultToolkit(): Internal.Toolkit
        isDynamicLayoutActive(): boolean
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        getSystemSelection(): Internal.Clipboard
        sync(): void
        setLockingKeyState(arg0: number, arg1: boolean): void
        isModalExclusionTypeSupported(arg0: Internal.Dialog$ModalExclusionType): boolean
        equals(arg0: any): boolean
        prepareImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        toString(): string
        getMenuShortcutKeyMask(): number
        getMaximumCursorColors(): number
        setDynamicLayout(arg0: boolean): void
        getImage(arg0: Internal.URL): Internal.Image
        getImage(arg0: string): Internal.Image
        mapInputMethodHighlight(arg0: Internal.InputMethodHighlight): Internal.Map<Internal.TextAttribute, any>
        get dynamicLayoutActive(): boolean;
        get menuShortcutKeyMaskEx(): number;
        get aWTEventListeners(): Internal.AWTEventListener[];
        get systemClipboard(): Internal.Clipboard;
        get fontList(): string[];
        get systemEventQueue(): Internal.EventQueue;
        get screenSize(): Internal.Dimension;
        get systemSelection(): Internal.Clipboard;
        get colorModel(): Internal.ColorModel;
        get maximumCursorColors(): number;
        get screenResolution(): number;
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get class(): Internal.Class<any>;
        get alwaysOnTopSupported(): boolean;
        get defaultToolkit(): Internal.Toolkit;
        get menuShortcutKeyMask(): number;
        set dynamicLayout(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Movable {
        drawMoved(matrixStack: Internal.PoseStack): void
        move(arg0: Internal.Chapter, arg1: number, arg2: number): void
        getHeight(): number
        getX(): number
        getY(): number
        getShape(): string
        getWidth(): number
        getChapter(): Internal.Chapter
    }
    interface GameRendererAccessor {
        create$callGetFov(arg0: Internal.Camera, arg1: number, arg2: boolean): number
    }
    interface AttributeMap {
        hasAttr<T>(arg0: Internal.AttributeKey<T>): boolean
        attr<T>(arg0: Internal.AttributeKey<T>): Internal.Attribute<T>
    }
    interface Reference2CharFunction <K> extends Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        removeChar(arg0: any): string
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: K) => T_
        put(arg0: K, arg1: string): string
        put(arg0: K, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: any): string
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): string
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getChar(arg0: any): string
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => string
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IItemRenderProperties {
        getItemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer
        getBaseArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<any>): net.minecraft.client.model.Model
        getFont(arg0: Internal.ItemStack): Internal.Font
        getArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<any>): Internal.HumanoidModel<any>
        renderHelmetOverlay(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: number, arg3: number, arg4: number): void
    }
    interface IntStream$Builder extends java_.util.function_.IntConsumer {
        add(arg0: number): Internal.IntStream$Builder
        build(): Internal.IntStream
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        accept(arg0: number): void
    }
    interface EntityInstancingController <T> {
        createInstance(arg0: Internal.MaterialManager, arg1: T): Internal.EntityInstance<T>
        shouldSkipRender(arg0: T): boolean
    }
    interface Int2ObjectMap$FastEntrySet <V> extends Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>> {
        add(arg0: Internal.Int2ObjectMap$Entry<V>): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<Internal.Int2ObjectMap$Entry<V>>
        forEach(arg0: (arg0: Internal.Int2ObjectMap$Entry<V>) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        fastIterator(): Internal.ObjectIterator<Internal.Int2ObjectMap$Entry<V>>
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: Internal.Int2ObjectMap$Entry<V>) => boolean): boolean
        fastForEach(arg0: (arg0: Internal.Int2ObjectMap$Entry<V>) => void): void
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<Internal.Int2ObjectMap$Entry<V>>
        size(): number
        addAll(arg0: Internal.Collection<Internal.Int2ObjectMap$Entry<V>>): boolean
        stream(): Internal.Stream<Internal.Int2ObjectMap$Entry<V>>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<Internal.Int2ObjectMap$Entry<V>>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface Object2DoubleFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        getDouble(arg0: any): number
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        removeDouble(arg0: any): number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Long2IntFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class LocalDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDateTime<Internal.LocalDate>, Internal.Serializable {
        static ofEpochSecond(arg0: number, arg1: number, arg2: Internal.ZoneOffset): Internal.LocalDateTime
        getClass(): Internal.Class<any>
        plusHours(arg0: number): Internal.LocalDateTime
        isEqual(arg0: Internal.ChronoLocalDateTime<any>): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChronoLocalDateTime<any>): number
        getDayOfWeek(): Internal.DayOfWeek
        plusSeconds(arg0: number): Internal.LocalDateTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.LocalDateTime
        plusNanos(arg0: number): Internal.LocalDateTime
        getMonth(): Internal.Month
        withHour(arg0: number): Internal.LocalDateTime
        plusMonths(arg0: number): Internal.LocalDateTime
        plusYears(arg0: number): Internal.LocalDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.LocalDateTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.LocalDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<any>
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.LocalDateTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<any>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDateTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        getYear(): number
        toEpochSecond(arg0: Internal.ZoneOffset): number
        withDayOfMonth(arg0: number): Internal.LocalDateTime
        isAfter(arg0: Internal.ChronoLocalDateTime<any>): boolean
        withMonth(arg0: number): Internal.LocalDateTime
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalDateTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.LocalDateTime
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<any>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<any>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        minusHours(arg0: number): Internal.LocalDateTime
        notifyAll(): void
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        plusMinutes(arg0: number): Internal.LocalDateTime
        withYear(arg0: number): Internal.LocalDateTime
        notify(): void
        plusDays(arg0: number): Internal.LocalDateTime
        minusMinutes(arg0: number): Internal.LocalDateTime
        hashCode(): number
        static now(): Internal.LocalDateTime
        static now(arg0: Internal.ZoneId): Internal.LocalDateTime
        static now(arg0: Internal.Clock): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.LocalDateTime
        getHour(): number
        getChronology(): Internal.Chronology
        withMinute(arg0: number): Internal.LocalDateTime
        getMonthValue(): number
        minusYears(arg0: number): Internal.LocalDateTime
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        minusWeeks(arg0: number): Internal.LocalDateTime
        withDayOfYear(arg0: number): Internal.LocalDateTime
        static parse(arg0: Internal.CharSequence): Internal.LocalDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalDateTime
        atZone(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        atZone(arg0: Internal.ZoneId): Internal.ZonedDateTime
        toInstant(arg0: Internal.ZoneOffset): Internal.Instant
        isBefore(arg0: Internal.ChronoLocalDateTime<any>): boolean
        minusDays(arg0: number): Internal.LocalDateTime
        withNano(arg0: number): Internal.LocalDateTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDateTime<any>
        with(arg0: Internal.TemporalAdjuster): Internal.LocalDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDateTime<any>
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalDateTime
        minusMonths(arg0: number): Internal.LocalDateTime
        toLocalDate(): Internal.LocalDate
        toLocalDate(): Internal.ChronoLocalDate
        equals(arg0: any): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.LocalDateTime
        withSecond(arg0: number): Internal.LocalDateTime
        static readonly MIN : Internal.LocalDateTime;
        static readonly MAX : Internal.LocalDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get hour(): number;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get nano(): number;
        get chronology(): Internal.Chronology;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelReader extends Internal.BlockAndTintGetter, Internal.CollisionGetter, Internal.BiomeManager$NoiseBiomeSource {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    interface AbstractContainerScreenAccessor {
        setSkipNextRelease(arg0: boolean): void
        setIsQuickCrafting(arg0: boolean): void
        getQuickCraftingButton(): number
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void
        getIsQuickCrafting(): boolean
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot
    }
    interface IntFunction <R> {
        apply(arg0: number): R
    }
    class Optional <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static ofNullable<T>(arg0: T): Internal.Optional<T>
        or(arg0: () => Internal.Optional<T>): Internal.Optional<T>
        notifyAll(): void
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: T): T
        notify(): void
        orElseThrow<X>(arg0: () => X): T
        orElseThrow(): T
        static empty<T>(): Internal.Optional<T>
        flatMap<U>(arg0: (arg0: T) => Internal.Optional<U>): Internal.Optional<U>
        filter(arg0: (arg0: T) => boolean): Internal.Optional<T>
        orElseGet(arg0: () => T): T
        stream(): Internal.Stream<T>
        hashCode(): number
        ifPresent(arg0: (arg0: T) => void): void
        ifPresentOrElse(arg0: (arg0: T) => void, arg1: Internal.Runnable): void
        static of<T>(arg0: T): Internal.Optional<T>
        equals(arg0: any): boolean
        get(): T
        toString(): string
        map<U>(arg0: (arg0: T) => U): Internal.Optional<U>
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntPredicate extends Internal.Predicate<number>, java_.util.function_.IntPredicate {
        or(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        or(arg0: java_.util.function_.IntPredicate): (arg0: any) => boolean
        or(arg0: java_.util.function_.IntPredicate): java_.util.function_.IntPredicate
        or(arg0: (arg0: any) => boolean): (arg0: any) => boolean
        test(arg0: number): boolean
        test(arg0: any): boolean
        test(arg0: number): boolean
        and(arg0: java_.util.function_.IntPredicate): java_.util.function_.IntPredicate
        and(arg0: java_.util.function_.IntPredicate): (arg0: any) => boolean
        and(arg0: (arg0: any) => boolean): (arg0: any) => boolean
        and(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        negate(): java_.util.function_.IntPredicate
        negate(): (arg0: any) => boolean
        negate(): (arg0: any) => boolean
    }
    interface ChannelPipeline extends Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker, Internal.Iterable<Internal.Map$Entry<string, Internal.ChannelHandler>> {
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        disconnect(): Internal.ChannelFuture
        newProgressivePromise(): Internal.ChannelProgressivePromise
        fireChannelWritabilityChanged(): Internal.ChannelPipeline
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        channel(): io.netty.channel.Channel
        replace(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelHandler
        replace(arg0: Internal.ChannelHandler, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        replace<T_>(arg0: Internal.Class<T_>, arg1: string, arg2: Internal.ChannelHandler): T_
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelPipeline
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelPipeline
        fireChannelActive(): Internal.ChannelInboundInvoker
        removeLast(): Internal.ChannelHandler
        remove(arg0: string): Internal.ChannelHandler
        remove(arg0: Internal.ChannelHandler): Internal.ChannelPipeline
        remove<T_>(arg0: Internal.Class<T_>): T_
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        writeAndFlush(arg0: any): Internal.ChannelFuture
        addLast(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline
        addLast(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        addLast(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline
        addLast(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline
        iterator(): Internal.Iterator<Internal.Map$Entry<string, Internal.ChannelHandler>>
        addAfter(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline
        addAfter(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        flush(): Internal.ChannelPipeline
        flush(): Internal.ChannelOutboundInvoker
        removeFirst(): Internal.ChannelHandler
        get(arg0: string): Internal.ChannelHandler
        get<T_>(arg0: Internal.Class<T_>): T_
        context(arg0: Internal.ChannelHandler): Internal.ChannelHandlerContext
        context(arg0: Internal.Class<Internal.ChannelHandler>): Internal.ChannelHandlerContext
        context(arg0: string): Internal.ChannelHandlerContext
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: any): Internal.ChannelFuture
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
        firstContext(): Internal.ChannelHandlerContext
        read(): Internal.ChannelOutboundInvoker
        fireChannelInactive(): Internal.ChannelPipeline
        fireChannelInactive(): Internal.ChannelInboundInvoker
        last(): Internal.ChannelHandler
        fireChannelReadComplete(): Internal.ChannelPipeline
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        spliterator(): Internal.Spliterator<Internal.Map$Entry<string, Internal.ChannelHandler>>
        forEach(arg0: (arg0: Internal.Map$Entry<string, Internal.ChannelHandler>) => void): void
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        fireChannelRegistered(): Internal.ChannelPipeline
        fireChannelRegistered(): Internal.ChannelInboundInvoker
        fireChannelRead(arg0: any): Internal.ChannelPipeline
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker
        addBefore(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline
        addBefore(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        names(): Internal.List<string>
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        toMap(): Internal.Map<string, Internal.ChannelHandler>
        fireUserEventTriggered(arg0: any): Internal.ChannelPipeline
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker
        lastContext(): Internal.ChannelHandlerContext
        fireChannelUnregistered(): Internal.ChannelPipeline
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
        addFirst(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        addFirst(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline
        addFirst(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline
        addFirst(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline
        first(): Internal.ChannelHandler
    }
    interface ChannelOutboundInvoker {
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        disconnect(): Internal.ChannelFuture
        read(): Internal.ChannelOutboundInvoker
        newProgressivePromise(): Internal.ChannelProgressivePromise
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        writeAndFlush(arg0: any): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        newSucceededFuture(): Internal.ChannelFuture
        flush(): Internal.ChannelOutboundInvoker
        voidPromise(): Internal.ChannelPromise
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: any): Internal.ChannelFuture
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
    }
    class RenderLayer extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getLayer(arg0: Internal.RenderType): Internal.RenderLayer
        static valueOf(arg0: string): Internal.RenderLayer
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.RenderLayer[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.RenderLayer): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RenderLayer>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.RenderLayer>
        static getPrimaryLayer(arg0: Internal.RenderType): Internal.RenderLayer
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly CUTOUT : Internal.RenderLayer;
        static readonly SOLID : Internal.RenderLayer;
        static readonly TRANSPARENT : Internal.RenderLayer;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RenderLayer>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TaskType extends Internal.RegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(name: ResourceLocation): Internal.TaskType
        setGuiProvider(p: Internal.TaskType$GuiProvider): Internal.TaskType
        setDisplayName(name: Internal.Component): Internal.TaskType
        getGuiProvider(): Internal.TaskType$GuiProvider
        notify(): void
        getIcon(): Internal.Icon
        getDisplayName(): Internal.Component
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.TaskType>
        toString(): string
        getTypeForNBT(): string
        static createTask(quest: Internal.Quest, id: string): Internal.Task
        intId : number;
        readonly provider : Internal.TaskType$Provider;
        readonly id : ResourceLocation;
        get registryType(): Internal.Class<Internal.TaskType>;
        get displayName(): Internal.Component;
        get guiProvider(): Internal.TaskType$GuiProvider;
        get icon(): Internal.Icon;
        get registryName(): ResourceLocation;
        get typeForNBT(): string;
        get class(): Internal.Class<any>;
        set displayName(name: Internal.Component);
        set guiProvider(p: Internal.TaskType$GuiProvider);
        set registryName(name: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelTimeAccess extends Internal.LevelReader {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    interface CustomJavaObjectWrapper$AsList extends Internal.CustomJavaObjectWrapper {
        wrapAsJavaList(): Internal.List<any>
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
    }
    interface CustomJavaObjectWrapper {
        wrapAsJavaObject(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Class<any>): Internal.Scriptable
    }
    interface Short2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Locale implements Internal.Cloneable, Internal.Serializable {
        stripExtensions(): Internal.Locale
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static forLanguageTag(arg0: string): Internal.Locale
        getUnicodeLocaleAttributes(): Internal.Set<string>
        getCountry(): string
        notifyAll(): void
        getUnicodeLocaleKeys(): Internal.Set<string>
        notify(): void
        getISO3Country(): string
        static lookupTag(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): string
        getDisplayCountry(): string
        getDisplayCountry(arg0: Internal.Locale): string
        getISO3Language(): string
        static getISOCountries(): string[]
        static getISOCountries(arg0: Internal.Locale$IsoCountryCode): Internal.Set<string>
        hashCode(): number
        getExtensionKeys(): Internal.Set<string>
        getDisplayVariant(arg0: Internal.Locale): string
        getDisplayVariant(): string
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): Internal.List<string>
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>, arg2: Internal.Locale$FilteringMode): Internal.List<string>
        static getISOLanguages(): string[]
        toLanguageTag(): string
        static getAvailableLocales(): Internal.Locale[]
        getDisplayScript(arg0: Internal.Locale): string
        getDisplayScript(): string
        static lookup(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.Locale
        getLanguage(): string
        getExtension(arg0: string): string
        getVariant(): string
        static getDefault(): Internal.Locale
        static getDefault(arg0: Internal.Locale$Category): Internal.Locale
        static setDefault(arg0: Internal.Locale$Category, arg1: Internal.Locale): void
        static setDefault(arg0: Internal.Locale): void
        hasExtensions(): boolean
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>, arg2: Internal.Locale$FilteringMode): Internal.List<Internal.Locale>
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.List<Internal.Locale>
        getDisplayName(arg0: Internal.Locale): string
        getDisplayName(): string
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        getDisplayLanguage(arg0: Internal.Locale): string
        getDisplayLanguage(): string
        getScript(): string
        getUnicodeLocaleType(arg0: string): string
        static readonly PRC : Internal.Locale;
        static readonly CANADA : Internal.Locale;
        static readonly ENGLISH : Internal.Locale;
        static readonly ROOT : Internal.Locale;
        static readonly TAIWAN : Internal.Locale;
        static readonly CHINA : Internal.Locale;
        static readonly ITALY : Internal.Locale;
        static readonly CHINESE : Internal.Locale;
        static readonly KOREA : Internal.Locale;
        static readonly FRENCH : Internal.Locale;
        static readonly FRANCE : Internal.Locale;
        static readonly TRADITIONAL_CHINESE : Internal.Locale;
        static readonly CANADA_FRENCH : Internal.Locale;
        static readonly GERMANY : Internal.Locale;
        static readonly ITALIAN : Internal.Locale;
        static readonly PRIVATE_USE_EXTENSION : "x";
        static readonly UK : Internal.Locale;
        static readonly JAPAN : Internal.Locale;
        static readonly JAPANESE : Internal.Locale;
        static readonly UNICODE_LOCALE_EXTENSION : "u";
        static readonly SIMPLIFIED_CHINESE : Internal.Locale;
        static readonly GERMAN : Internal.Locale;
        static readonly US : Internal.Locale;
        static readonly KOREAN : Internal.Locale;
        get unicodeLocaleKeys(): Internal.Set<string>;
        get country(): string;
        get displayName(): string;
        get iSOLanguages(): string[];
        get displayVariant(): string;
        get language(): string;
        get displayLanguage(): string;
        get script(): string;
        get iSO3Country(): string;
        get availableLocales(): Internal.Locale[];
        get iSOCountries(): string[];
        get unicodeLocaleAttributes(): Internal.Set<string>;
        get default(): Internal.Locale;
        get displayCountry(): string;
        get variant(): string;
        get extensionKeys(): Internal.Set<string>;
        get displayScript(): string;
        get class(): Internal.Class<any>;
        get iSO3Language(): string;
        set default(arg0: Internal.Locale);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecordCodecBuilder$Instance <O> implements Internal.Applicative<Internal.RecordCodecBuilder$Mu<O>, any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        deprecated<A_>(arg0: A_, arg1: number): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>
        notify(): void
        point<A_>(arg0: A_, arg1: Internal.Lifecycle): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>
        point<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>
        hashCode(): number
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>): Internal.Products$P11<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>): Internal.Products$P10<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.Products$P9<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T16_>): Internal.Products$P16<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>): Internal.Products$P15<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>): Internal.Products$P14<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>): Internal.Products$P13<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>): Internal.Products$P12<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>
        group<T1_, T2_, T3_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.Products$P3<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_>
        group<T1_, T2_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>): Internal.Products$P2<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_>
        group<T1_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>): Internal.Products$P1<Internal.RecordCodecBuilder$Mu<O>, T1_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.Products$P8<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.Products$P7<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_>
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.Products$P6<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_>
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.Products$P5<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_>
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.Products$P4<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_>
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap2<A_, B_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift2<A_, B_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift1<A_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_) => R_>): (arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        ap<A_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_) => R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>
        stable<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>
        equals(arg0: any): boolean
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>, arg16: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T16_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        toString(): string
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ConstProperties {
        defineConst(arg0: string, arg1: Internal.Scriptable): void
        isConst(arg0: string): boolean
        putConst(arg0: string, arg1: Internal.Scriptable, arg2: any): void
    }
    class Rotation extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Rotation
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Rotation[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Rotation): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Rotation>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Rotation>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly COUNTERCLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_180 : Internal.Rotation;
        static readonly NONE : Internal.Rotation;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Rotation>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P8 <F, T1, T2, T3, T4, T5, T6, T7, T8> {
        t4(): Internal.App<F, T4>
        getClass(): Internal.Class<any>
        t5(): Internal.App<F, T5>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        t6(): Internal.App<F, T6>
        t7(): Internal.App<F, T7>
        t8(): Internal.App<F, T8>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>): Internal.App<F, R>
        notifyAll(): void
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MessageSizeEstimator {
        newHandle(): Internal.MessageSizeEstimator$Handle
    }
    class AccessibleRole extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toDisplayString(arg0: Internal.Locale): string
        toDisplayString(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly DATE_EDITOR : Internal.AccessibleRole;
        static readonly PARAGRAPH : Internal.AccessibleRole;
        static readonly TEXT : Internal.AccessibleRole;
        static readonly ALERT : Internal.AccessibleRole;
        static readonly FONT_CHOOSER : Internal.AccessibleRole;
        static readonly GROUP_BOX : Internal.AccessibleRole;
        static readonly ROOT_PANE : Internal.AccessibleRole;
        static readonly TABLE : Internal.AccessibleRole;
        static readonly COMBO_BOX : Internal.AccessibleRole;
        static readonly SLIDER : Internal.AccessibleRole;
        static readonly PROGRESS_MONITOR : Internal.AccessibleRole;
        static readonly HYPERLINK : Internal.AccessibleRole;
        static readonly LABEL : Internal.AccessibleRole;
        static readonly PROGRESS_BAR : Internal.AccessibleRole;
        static readonly DESKTOP_ICON : Internal.AccessibleRole;
        static readonly SEPARATOR : Internal.AccessibleRole;
        static readonly MENU_ITEM : Internal.AccessibleRole;
        static readonly SCROLL_PANE : Internal.AccessibleRole;
        static readonly AWT_COMPONENT : Internal.AccessibleRole;
        static readonly MENU_BAR : Internal.AccessibleRole;
        static readonly PUSH_BUTTON : Internal.AccessibleRole;
        static readonly PAGE_TAB : Internal.AccessibleRole;
        static readonly CHECK_BOX : Internal.AccessibleRole;
        static readonly TREE : Internal.AccessibleRole;
        static readonly PASSWORD_TEXT : Internal.AccessibleRole;
        static readonly LIST : Internal.AccessibleRole;
        static readonly HTML_CONTAINER : Internal.AccessibleRole;
        static readonly OPTION_PANE : Internal.AccessibleRole;
        static readonly DESKTOP_PANE : Internal.AccessibleRole;
        static readonly HEADER : Internal.AccessibleRole;
        static readonly FRAME : Internal.AccessibleRole;
        static readonly TOOL_TIP : Internal.AccessibleRole;
        static readonly ROW_HEADER : Internal.AccessibleRole;
        static readonly SPIN_BOX : Internal.AccessibleRole;
        static readonly CANVAS : Internal.AccessibleRole;
        static readonly TOOL_BAR : Internal.AccessibleRole;
        static readonly INTERNAL_FRAME : Internal.AccessibleRole;
        static readonly LAYERED_PANE : Internal.AccessibleRole;
        static readonly PAGE_TAB_LIST : Internal.AccessibleRole;
        static readonly COLUMN_HEADER : Internal.AccessibleRole;
        static readonly ICON : Internal.AccessibleRole;
        static readonly COLOR_CHOOSER : Internal.AccessibleRole;
        static readonly VIEWPORT : Internal.AccessibleRole;
        static readonly PANEL : Internal.AccessibleRole;
        static readonly DIRECTORY_PANE : Internal.AccessibleRole;
        static readonly STATUS_BAR : Internal.AccessibleRole;
        static readonly DIALOG : Internal.AccessibleRole;
        static readonly SPLIT_PANE : Internal.AccessibleRole;
        static readonly GLASS_PANE : Internal.AccessibleRole;
        static readonly SWING_COMPONENT : Internal.AccessibleRole;
        static readonly FOOTER : Internal.AccessibleRole;
        static readonly EDITBAR : Internal.AccessibleRole;
        static readonly FILLER : Internal.AccessibleRole;
        static readonly WINDOW : Internal.AccessibleRole;
        static readonly FILE_CHOOSER : Internal.AccessibleRole;
        static readonly POPUP_MENU : Internal.AccessibleRole;
        static readonly SCROLL_BAR : Internal.AccessibleRole;
        static readonly LIST_ITEM : Internal.AccessibleRole;
        static readonly RADIO_BUTTON : Internal.AccessibleRole;
        static readonly MENU : Internal.AccessibleRole;
        static readonly UNKNOWN : Internal.AccessibleRole;
        static readonly RULER : Internal.AccessibleRole;
        static readonly TOGGLE_BUTTON : Internal.AccessibleRole;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Gson {
        getAdapter<T>(arg0: Internal.TypeToken<T>): Internal.TypeAdapter<T>
        getAdapter<T>(arg0: Internal.Class<T>): Internal.TypeAdapter<T>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        excluder(): Internal.Excluder
        notifyAll(): void
        newBuilder(): Internal.GsonBuilder
        notify(): void
        newJsonReader(arg0: Internal.Reader): Internal.JsonReader
        serializeNulls(): boolean
        fieldNamingStrategy(): Internal.FieldNamingStrategy
        toJson(arg0: any, arg1: Internal.Appendable): void
        toJson(arg0: any): string
        toJson(arg0: any, arg1: Internal.Type, arg2: Internal.Appendable): void
        toJson(arg0: any, arg1: Internal.Type, arg2: Internal.JsonWriter): void
        toJson(arg0: Internal.JsonElement): string
        toJson(arg0: Internal.JsonElement, arg1: Internal.JsonWriter): void
        toJson(arg0: any, arg1: Internal.Type): string
        toJson(arg0: Internal.JsonElement, arg1: Internal.Appendable): void
        newJsonWriter(arg0: Internal.Writer): Internal.JsonWriter
        hashCode(): number
        equals(arg0: any): boolean
        toJsonTree(arg0: any, arg1: Internal.Type): Internal.JsonElement
        toJsonTree(arg0: any): Internal.JsonElement
        fromJson<T>(arg0: Internal.Reader, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: string, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: Internal.JsonReader, arg1: Internal.Type): T
        fromJson<T>(arg0: string, arg1: Internal.Type): T
        fromJson<T>(arg0: Internal.JsonElement, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: Internal.JsonElement, arg1: Internal.Type): T
        fromJson<T>(arg0: Internal.Reader, arg1: Internal.Type): T
        toString(): string
        getDelegateAdapter<T>(arg0: Internal.TypeAdapterFactory, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>
        htmlSafe(): boolean
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Constant <T> extends Internal.Comparable<T> {
        name(): string
        compareTo(arg0: T): number
        id(): number
    }
    abstract class DynamicConstantDesc <T> implements Internal.ConstantDesc {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc
        bootstrapMethod(): Internal.DirectMethodHandleDesc
        constantName(): string
        notifyAll(): void
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): T
        notify(): void
        constantType(): Internal.ClassDesc
        hashCode(): number
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>
        equals(arg0: any): boolean
        bootstrapArgs(): Internal.ConstantDesc[]
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>
        toString(): string
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AnnotatedType extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getType(): Internal.Type
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getAnnotatedOwnerType(): Internal.AnnotatedType
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
    }
    class ContextFactory {
        enterContext(): Internal.Context
        enterContext(cx: Internal.Context): Internal.Context
        getClass(): Internal.Class<any>
        isSealed(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        seal(): void
        getApplicationClassLoader(): Internal.ClassLoader
        removeListener(listener: Internal.ContextFactory$Listener): void
        notify(): void
        call<T>(action: Internal.ContextAction<T>): T
        hashCode(): number
        equals(arg0: any): boolean
        static getGlobal(): Internal.ContextFactory
        toString(): string
        addListener(listener: Internal.ContextFactory$Listener): void
        get sealed(): boolean;
        get applicationClassLoader(): Internal.ClassLoader;
        get global(): Internal.ContextFactory;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FluidTagInput implements Internal.Predicate<Internal.FluidStack> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: Internal.FluidStack) => boolean): (arg0: Internal.FluidStack) => boolean
        static read(arg0: Internal.FriendlyByteBuf): (arg0: any) => boolean
        test(arg0: any): boolean
        test(arg0: Internal.FluidStack): boolean
        getRandomizedExampleStack(arg0: number): Internal.FluidStack
        notifyAll(): void
        extractFrom(arg0: Internal.IFluidHandler, arg1: Internal.IFluidHandler$FluidAction): boolean
        notify(): void
        getMatchingFluidStacks(): Internal.List<Internal.FluidStack>
        serialize(): Internal.JsonElement
        and(arg0: (arg0: Internal.FluidStack) => boolean): (arg0: Internal.FluidStack) => boolean
        negate(): (arg0: Internal.FluidStack) => boolean
        hashCode(): number
        equals(arg0: any): boolean
        testIgnoringAmount(arg0: Internal.FluidStack): boolean
        toString(): string
        withAmount(arg0: number): (arg0: any) => boolean
        write(arg0: Internal.FriendlyByteBuf): void
        getAmount(): number
        static deserialize(arg0: Internal.JsonElement): (arg0: any) => boolean
        get amount(): number;
        get matchingFluidStacks(): Internal.List<Internal.FluidStack>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PoseStack implements Internal.TransformStack {
        rotate(arg0: Internal.Direction, arg1: number): Internal.TransformStack
        rotate(arg0: number, arg1: (arg0: any) => boolean): Internal.TransformStack
        getClass(): Internal.Class<any>
        translateAll(arg0: number): Internal.TransformStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        scale(arg0: number, arg1: number, arg2: number): any
        scale(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        scale(arg0: number): Internal.TransformStack
        notify(): void
        translate(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        translate(arg0: number, arg1: number, arg2: number): any
        translate(arg0: Internal.Vector3f): Internal.TransformStack
        translate(arg0: Vec3): Internal.TransformStack
        translate(arg0: Vec3i): Internal.TransformStack
        translateZ(arg0: number): Internal.TransformStack
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Internal.TransformStack
        transform(arg0: Internal.PoseStack): Internal.TransformStack
        mulNormal(arg0: Internal.Matrix3f): Internal.TransformStack
        pushPose(): any
        pushPose(): Internal.TransformStack
        translateY(arg0: number): Internal.TransformStack
        hashCode(): number
        translateX(arg0: number): Internal.TransformStack
        multiply(arg0: Internal.Quaternion): Internal.TransformStack
        multiply(arg0: Internal.Quaternion): any
        multiply(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack
        rotateX(arg0: number): Internal.TransformStack
        rotateY(arg0: number): Internal.TransformStack
        translateBack(arg0: Vec3i): Internal.TransformStack
        translateBack(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        translateBack(arg0: Vec3): Internal.TransformStack
        rotateToFace(arg0: Internal.Direction): Internal.TransformStack
        rotateZ(arg0: number): Internal.TransformStack
        nudge(arg0: number): Internal.TransformStack
        rotateCentered(arg0: Internal.Direction, arg1: number): Internal.TransformStack
        rotateCentered(arg0: Internal.Quaternion): Internal.TransformStack
        centre(): Internal.TransformStack
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack
        rotateZRadians(arg0: number): Internal.TransformStack
        mulPose(arg0: Internal.Matrix4f): Internal.TransformStack
        rotateYRadians(arg0: number): Internal.TransformStack
        rotateXRadians(arg0: number): Internal.TransformStack
        popPose(): any
        popPose(): Internal.TransformStack
        equals(arg0: any): boolean
        unCentre(): Internal.TransformStack
        toString(): string
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CompressorHolder implements Internal.Compressable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ScheduledFuture <V> extends Internal.Future<V>, java_.util.concurrent.ScheduledFuture<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        getDelay(arg0: Internal.TimeUnit): number
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(): Internal.Future<V>
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        compareTo(arg0: Internal.Delayed): number
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        isDone(): boolean
        sync(): Internal.Future<V>
        syncUninterruptibly(): Internal.Future<V>
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isCancellable(): boolean
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        await(): Internal.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
    }
    interface LongCollection extends Internal.Collection<number>, Internal.LongIterable {
        longIterator(): Internal.LongIterator
        remove(arg0: any): boolean
        removeAll(arg0: Internal.LongCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.LongIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toArray(arg0: number[]): number[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        longStream(): Internal.LongStream
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        longSpliterator(): Internal.LongSpliterator
        toLongArray(arg0: number[]): number[]
        toLongArray(): number[]
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.LongSpliterator
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: Internal.LongConsumer): void
        forEach(arg0: (arg0: any) => void): void
        containsAll(arg0: Internal.LongCollection): boolean
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: java_.util.function_.LongPredicate): boolean
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        longParallelStream(): Internal.LongStream
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.LongCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        retainAll(arg0: Internal.LongCollection): boolean
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface BlockEntityRenderDispatcherAccessor {
        flywheel$getRenderers(): Internal.Map<Internal.BlockEntityType<any>, Internal.BlockEntityRenderer<any>>
    }
    class JsonArray extends Internal.JsonElement implements Internal.Iterable<Internal.JsonElement> {
        getAsFloat(): number
        getClass(): Internal.Class<any>
        getAsByte(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAsBigDecimal(): Internal.BigDecimal
        notifyAll(): void
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        notify(): void
        remove(arg0: Internal.JsonElement): boolean
        remove(arg0: number): Internal.JsonElement
        getAsInt(): number
        isJsonPrimitive(): boolean
        iterator(): Internal.Iterator<Internal.JsonElement>
        getAsLong(): number
        isJsonObject(): boolean
        hashCode(): number
        get(arg0: number): Internal.JsonElement
        add(arg0: string): void
        add(arg0: string): void
        add(arg0: Internal.Number): void
        add(arg0: boolean): void
        add(arg0: Internal.JsonElement): void
        getAsBigInteger(): Internal.BigInteger
        getAsJsonObject(): Internal.JsonObject
        set(arg0: number, arg1: Internal.JsonElement): Internal.JsonElement
        getAsJsonNull(): Internal.JsonNull
        spliterator(): Internal.Spliterator<Internal.JsonElement>
        forEach(arg0: (arg0: Internal.JsonElement) => void): void
        isJsonNull(): boolean
        isEmpty(): boolean
        getAsDouble(): number
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonArray
        contains(arg0: Internal.JsonElement): boolean
        getAsJsonArray(): Internal.JsonArray
        size(): number
        addAll(arg0: Internal.JsonArray): void
        getAsJsonPrimitive(): Internal.JsonPrimitive
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        getAsShort(): number
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get empty(): boolean;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableMultiset <E> extends Internal.ImmutableMultisetGwtSerializationDependencies<any> implements Internal.Multiset<E> {
        getClass(): Internal.Class<any>
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: any, arg1: number): number
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        stream(): Internal.Stream<E>
        elementSet(): Internal.Set<any>
        elementSet(): Internal.ImmutableSet<E>
        hashCode(): number
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableMultiset<E_>
        static of<E_>(arg0: E_): Internal.ImmutableMultiset<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableMultiset<E_>
        static of<E_>(): Internal.ImmutableMultiset<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableMultiset<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableMultiset<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableMultiset<E_>
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        static builder<E_>(): Internal.ImmutableMultiset$Builder<E_>
        parallelStream(): Internal.Stream<E>
        setCount(arg0: E, arg1: number): number
        setCount(arg0: E, arg1: number, arg2: number): boolean
        add(arg0: E, arg1: number): number
        add(arg0: E): boolean
        static toImmutableMultiset<E_>(): Internal.Collector<E_, any, Internal.ImmutableMultiset<E_>>
        static toImmutableMultiset<T_, E_>(arg0: (arg0: T_) => E_, arg1: Internal.ToIntFunction<T_>): Internal.Collector<T_, any, Internal.ImmutableMultiset<E_>>
        spliterator(): Internal.Spliterator<E>
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ImmutableSet<Internal.Multiset$Entry<E>>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        count(arg0: any): number
        isEmpty(): boolean
        clear(): void
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableMultiset<E_>
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableMultiset<E_>
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableMultiset<E_>
        removeIf(arg0: (arg0: E) => boolean): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DecimalStyle {
        getPositiveSign(): string
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDecimalSeparator(): string
        notifyAll(): void
        getNegativeSign(): string
        notify(): void
        static ofDefaultLocale(): Internal.DecimalStyle
        getZeroDigit(): string
        withPositiveSign(arg0: string): Internal.DecimalStyle
        hashCode(): number
        static of(arg0: Internal.Locale): Internal.DecimalStyle
        equals(arg0: any): boolean
        withDecimalSeparator(arg0: string): Internal.DecimalStyle
        toString(): string
        withNegativeSign(arg0: string): Internal.DecimalStyle
        static getAvailableLocales(): Internal.Set<Internal.Locale>
        withZeroDigit(arg0: string): Internal.DecimalStyle
        static readonly STANDARD : Internal.DecimalStyle;
        get negativeSign(): string;
        get decimalSeparator(): string;
        get zeroDigit(): string;
        get positiveSign(): string;
        get class(): Internal.Class<any>;
        get availableLocales(): Internal.Set<Internal.Locale>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LayoutManager {
        preferredLayoutSize(arg0: java_.awt.Container): Internal.Dimension
        removeLayoutComponent(arg0: java_.awt.Component): void
        minimumLayoutSize(arg0: java_.awt.Container): Internal.Dimension
        layoutContainer(arg0: java_.awt.Container): void
        addLayoutComponent(arg0: string, arg1: java_.awt.Component): void
    }
    interface SharedSuggestionProvider {
    }
    interface IntCollection extends Internal.Collection<number>, Internal.IntIterable {
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        remove(arg0: any): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(): number[]
        toIntArray(arg0: number[]): number[]
        toArray(arg0: number[]): number[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        add(arg0: number): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: (arg0: any) => void): void
        containsAll(arg0: Internal.IntCollection): boolean
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: java_.util.function_.IntPredicate): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        retainAll(arg0: Internal.IntCollection): boolean
        retainAll(arg0: Internal.Collection<any>): boolean
        intParallelStream(): Internal.IntStream
    }
    abstract class LevelJS implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void
        getTime(): number
        notifyAll(): void
        getSide(): Internal.ScriptType
        getGameRules(): Internal.GameRulesJS
        notify(): void
        setRainStrength(strength: number): void
        hashCode(): number
        getDimension(): string
        isDaytime(): boolean
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        getMinecraftLevel(): net.minecraft.world.level.Level
        getServer(): Internal.ServerJS
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS
        getBlock(pos: BlockPos): Internal.BlockContainerJS
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS
        isOverworld(): boolean
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS
        getEntity(e: Internal.Entity): Internal.EntityJS
        createEntity(id: ResourceLocation): Internal.EntityJS
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void
        getLocalTime(): number
        equals(arg0: any): boolean
        isThundering(): boolean
        getEntities(): Internal.EntityArrayList
        toString(): string
        isRaining(): boolean
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ValueRange implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getMaximum(): number
        getSmallestMaximum(): number
        notify(): void
        isIntValue(): boolean
        getLargestMinimum(): number
        isValidValue(arg0: number): boolean
        hashCode(): number
        static of(arg0: number, arg1: number): Internal.ValueRange
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ValueRange
        static of(arg0: number, arg1: number, arg2: number): Internal.ValueRange
        equals(arg0: any): boolean
        getMinimum(): number
        checkValidValue(arg0: number, arg1: Internal.TemporalField): number
        checkValidIntValue(arg0: number, arg1: Internal.TemporalField): number
        toString(): string
        isFixed(): boolean
        isValidIntValue(arg0: number): boolean
        get largestMinimum(): number;
        get smallestMaximum(): number;
        get intValue(): boolean;
        get maximum(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get minimum(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DataOutput {
        writeChar(arg0: number): void
        writeInt(arg0: number): void
        writeByte(arg0: number): void
        writeLong(arg0: number): void
        writeBytes(arg0: string): void
        writeUTF(arg0: string): void
        writeShort(arg0: number): void
        writeChars(arg0: string): void
        writeFloat(arg0: number): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number[]): void
        write(arg0: number): void
        writeBoolean(arg0: boolean): void
        writeDouble(arg0: number): void
    }
    class Point extends Internal.Point2D implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        move(arg0: number, arg1: number): void
        getLocation(): Internal.Point
        distance(arg0: Internal.Point2D): number
        distance(arg0: number, arg1: number): number
        static distance(arg0: number, arg1: number, arg2: number, arg3: number): number
        notifyAll(): void
        static distanceSq(arg0: number, arg1: number, arg2: number, arg3: number): number
        distanceSq(arg0: Internal.Point2D): number
        distanceSq(arg0: number, arg1: number): number
        notify(): void
        translate(arg0: number, arg1: number): void
        getX(): number
        getY(): number
        setLocation(arg0: number, arg1: number): void
        setLocation(arg0: Internal.Point): void
        setLocation(arg0: number, arg1: number): void
        setLocation(arg0: Internal.Point2D): void
        hashCode(): number
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        x : number;
        y : number;
        get location(): Internal.Point;
        get class(): Internal.Class<any>;
        set location(arg0: Internal.Point);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BaseFunction extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable
        getAllIds(): any[]
        put(name: string, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        getArity(): number
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        hasPrototypeMap(): boolean
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getFunctionName(): string
        getExternalArrayLength(): any
        getAttributes(key: Internal.Symbol): number
        getAttributes(name: string): number
        getAttributes(index: number): number
        setImmunePrototypeProperty(value: any): void
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: any): any
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getClassName(): string
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        notifyAll(): void
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        hashCode(): number
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        activatePrototypeMap(maxPrototypeId: number): void
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        getLength(): number
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockEntityPredicateDataCheck {
        checkData(arg0: Internal.CompoundTag): boolean
    }
    interface EffectInstanceAccess {
        getEffect(): Internal.MobEffect
    }
    class Quaternion {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Kind1 <F, Mu> extends Internal.App<Mu, F> {
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>
    }
    class RegistryEntry <T> implements Internal.IForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<T>
        getRegistryName(): ResourceLocation
        toString(): string
        setRegistryName(name: ResourceLocation): T
        notify(): void
        get registryType(): Internal.Class<T>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(name: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NonNullList <E> extends Internal.AbstractList<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): E
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        get(arg0: number): E
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Dimension2D implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getHeight(): number
        setSize(arg0: Internal.Dimension2D): void
        setSize(arg0: number, arg1: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        getWidth(): number
        notify(): void
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        set size(arg0: Internal.Dimension2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Decoder$Simple <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
    }
    abstract class JsonElement {
        getAsFloat(): number
        getClass(): Internal.Class<any>
        getAsByte(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAsBigDecimal(): Internal.BigDecimal
        notifyAll(): void
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        notify(): void
        getAsInt(): number
        isJsonPrimitive(): boolean
        getAsLong(): number
        hashCode(): number
        isJsonObject(): boolean
        getAsBigInteger(): Internal.BigInteger
        getAsJsonObject(): Internal.JsonObject
        getAsJsonNull(): Internal.JsonNull
        isJsonNull(): boolean
        getAsDouble(): number
        deepCopy(): Internal.JsonElement
        getAsJsonArray(): Internal.JsonArray
        getAsJsonPrimitive(): Internal.JsonPrimitive
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        getAsShort(): number
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Iterable <T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
    }
    class ArrayList <E> extends Internal.AbstractList<any> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: any): boolean
        remove(arg0: number): E
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        get(arg0: number): E
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        add(arg0: E): boolean
        add(arg0: number, arg1: E): void
        subList(arg0: number, arg1: number): Internal.List<E>
        trimToSize(): void
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        clone(): any
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        toString(): string
        ensureCapacity(arg0: number): void
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FastMapStateHolder <S> {
        getNeighborTable(): Internal.Table<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>, S>
        getStateIndex(): number
        setNeighborTable(arg0: Internal.Table<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>, S>): void
        setStateIndex(arg0: number): void
        setStateMap(arg0: Internal.FastMap<S>): void
        getVanillaPropertyMap(): Internal.ImmutableMap<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>>
        getStateMap(): Internal.FastMap<S>
        replacePropertyMap(arg0: Internal.ImmutableMap<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>>): void
    }
    interface Wrapper {
        unwrap(): any
    }
    interface TemporalAmount {
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        get(arg0: Internal.TemporalUnit): number
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
    }
    class EventObject implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TeamPropertyType$FromNet <Y> {
        apply(arg0: ResourceLocation, arg1: Internal.FriendlyByteBuf): Internal.TeamProperty<Y>
    }
    class ItemRenderer implements Internal.ResourceManagerReloadListener, Internal.AccessorItemRenderer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        callRenderQuadList(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.List<any>, arg3: Internal.ItemStack, arg4: number, arg5: number): void
        notifyAll(): void
        equals(arg0: any): boolean
        getBlockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer
        handler$bfl000$renderQuads(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.List<any>, arg3: Internal.ItemStack, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void
        toString(): string
        getItemColors(): Internal.ItemColors
        notify(): void
        get itemColors(): Internal.ItemColors;
        get blockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorRecipeManager {
        botania_getAll<C, T>(arg0: Internal.RecipeType<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>
    }
    class DrawBuffer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasVertices(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        reset(): void
        toString(): string
        begin(arg0: number): Internal.DirectVertexConsumer
        inject(arg0: Internal.BufferBuilderExtension): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CharsetEncoder {
        encode(arg0: Internal.CharBuffer, arg1: Internal.ByteBuffer, arg2: boolean): Internal.CoderResult
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer
        getClass(): Internal.Class<any>
        charset(): Internal.Charset
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder
        notifyAll(): void
        maxBytesPerChar(): number
        isLegalReplacement(arg0: number[]): boolean
        notify(): void
        unmappableCharacterAction(): Internal.CodingErrorAction
        malformedInputAction(): Internal.CodingErrorAction
        flush(arg0: Internal.ByteBuffer): Internal.CoderResult
        hashCode(): number
        equals(arg0: any): boolean
        canEncode(arg0: Internal.CharSequence): boolean
        canEncode(arg0: string): boolean
        averageBytesPerChar(): number
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder
        reset(): Internal.CharsetEncoder
        toString(): string
        replacement(): number[]
        replaceWith(arg0: number[]): Internal.CharsetEncoder
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AccessibleContext {
        getClass(): Internal.Class<any>
        getAccessibleStateSet(): Internal.AccessibleStateSet
        getAccessibleRelationSet(): Internal.AccessibleRelationSet
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        setAccessibleName(arg0: string): void
        getAccessibleValue(): Internal.AccessibleValue
        notify(): void
        getAccessibleText(): Internal.AccessibleText
        getAccessibleTable(): Internal.AccessibleTable
        getAccessibleDescription(): string
        getAccessibleEditableText(): Internal.AccessibleEditableText
        hashCode(): number
        setAccessibleDescription(arg0: string): void
        getAccessibleParent(): Internal.Accessible
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        getAccessibleChildrenCount(): number
        firePropertyChange(arg0: string, arg1: any, arg2: any): void
        getAccessibleName(): string
        getAccessibleIndexInParent(): number
        setAccessibleParent(arg0: Internal.Accessible): void
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        getAccessibleAction(): Internal.AccessibleAction
        getAccessibleIcon(): any[]
        getAccessibleChild(arg0: number): Internal.Accessible
        equals(arg0: any): boolean
        getAccessibleSelection(): Internal.AccessibleSelection
        getAccessibleRole(): Internal.AccessibleRole
        toString(): string
        getLocale(): Internal.Locale
        getAccessibleComponent(): Internal.AccessibleComponent
        static readonly ACCESSIBLE_COMPONENT_BOUNDS_CHANGED : "accessibleComponentBoundsChanged";
        static readonly ACCESSIBLE_INVALIDATE_CHILDREN : "accessibleInvalidateChildren";
        static readonly ACCESSIBLE_VISIBLE_DATA_PROPERTY : "AccessibleVisibleData";
        static readonly ACCESSIBLE_TABLE_ROW_HEADER_CHANGED : "accessibleTableRowHeaderChanged";
        static readonly ACCESSIBLE_SELECTION_PROPERTY : "AccessibleSelection";
        static readonly ACCESSIBLE_NAME_PROPERTY : "AccessibleName";
        static readonly ACCESSIBLE_HYPERTEXT_OFFSET : "AccessibleHypertextOffset";
        static readonly ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED : "accessibleTextAttributesChanged";
        static readonly ACCESSIBLE_TABLE_SUMMARY_CHANGED : "accessibleTableSummaryChanged";
        static readonly ACCESSIBLE_CHILD_PROPERTY : "AccessibleChild";
        static readonly ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY : "AccessibleActiveDescendant";
        static readonly ACCESSIBLE_DESCRIPTION_PROPERTY : "AccessibleDescription";
        static readonly ACCESSIBLE_TABLE_ROW_DESCRIPTION_CHANGED : "accessibleTableRowDescriptionChanged";
        static readonly ACCESSIBLE_CARET_PROPERTY : "AccessibleCaret";
        static readonly ACCESSIBLE_ACTION_PROPERTY : "accessibleActionProperty";
        static readonly ACCESSIBLE_VALUE_PROPERTY : "AccessibleValue";
        static readonly ACCESSIBLE_TABLE_MODEL_CHANGED : "accessibleTableModelChanged";
        static readonly ACCESSIBLE_TABLE_COLUMN_DESCRIPTION_CHANGED : "accessibleTableColumnDescriptionChanged";
        static readonly ACCESSIBLE_STATE_PROPERTY : "AccessibleState";
        static readonly ACCESSIBLE_TABLE_COLUMN_HEADER_CHANGED : "accessibleTableColumnHeaderChanged";
        static readonly ACCESSIBLE_TEXT_PROPERTY : "AccessibleText";
        static readonly ACCESSIBLE_TABLE_CAPTION_CHANGED : "accessibleTableCaptionChanged";
        get accessibleChildrenCount(): number;
        get accessibleTable(): Internal.AccessibleTable;
        get locale(): Internal.Locale;
        get accessibleSelection(): Internal.AccessibleSelection;
        get accessibleRole(): Internal.AccessibleRole;
        get accessibleDescription(): string;
        get accessibleParent(): Internal.Accessible;
        get accessibleAction(): Internal.AccessibleAction;
        get accessibleIcon(): any[];
        get accessibleValue(): Internal.AccessibleValue;
        get accessibleStateSet(): Internal.AccessibleStateSet;
        get accessibleIndexInParent(): number;
        get accessibleComponent(): Internal.AccessibleComponent;
        get accessibleEditableText(): Internal.AccessibleEditableText;
        get accessibleName(): string;
        get class(): Internal.Class<any>;
        get accessibleText(): Internal.AccessibleText;
        get accessibleRelationSet(): Internal.AccessibleRelationSet;
        set accessibleDescription(arg0: string);
        set accessibleParent(arg0: Internal.Accessible);
        set accessibleName(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StageChangeEvent {
        getStage(): string
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.Player
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        getPlayerStages(): Internal.Stages
        get stage(): string;
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleLayer {
        getClass(): Internal.Class<any>
        static defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller
        defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        configuration(): Internal.Configuration
        notifyAll(): void
        static defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller
        defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer
        notify(): void
        modules(): Internal.Set<Internal.Module>
        defineModules(arg0: Internal.Configuration, arg1: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer
        static defineModules(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer$Controller
        static empty(): Internal.ModuleLayer
        findModule(arg0: string): Internal.Optional<Internal.Module>
        findLoader(arg0: string): Internal.ClassLoader
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static boot(): Internal.ModuleLayer
        parents(): Internal.List<Internal.ModuleLayer>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChronoLocalDate extends Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDate> {
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        toEpochDay(): number
        isEqual(arg0: Internal.ChronoLocalDate): boolean
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChronoLocalDate): number
        lengthOfYear(): number
        lengthOfMonth(): number
        getEra(): Internal.Era
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        getChronology(): Internal.Chronology
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        format(arg0: Internal.DateTimeFormatter): string
        isLeapYear(): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        isBefore(arg0: Internal.ChronoLocalDate): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        getLong(arg0: Internal.TemporalField): number
        atTime(arg0: Internal.LocalTime): Internal.ChronoLocalDateTime<any>
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        equals(arg0: any): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        until(arg0: Internal.ChronoLocalDate): Internal.ChronoPeriod
        toString(): string
        isAfter(arg0: Internal.ChronoLocalDate): boolean
    }
    class ModuleDescriptor$Exports implements Internal.Comparable<Internal.ModuleDescriptor$Exports> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isQualified(): boolean
        toString(): string
        source(): string
        compareTo(arg0: Internal.ModuleDescriptor$Exports): number
        compareTo(arg0: any): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>
        targets(): Internal.Set<string>
        notify(): void
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ContainerEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getContainer(): java_.awt.Container
        notifyAll(): void
        getChild(): java_.awt.Component
        getID(): number
        notify(): void
        paramString(): string
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        toString(): string
        getComponent(): java_.awt.Component
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly CONTAINER_FIRST : 300;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly COMPONENT_ADDED : 300;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_REMOVED : 301;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly CONTAINER_LAST : 301;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get container(): java_.awt.Container;
        get component(): java_.awt.Component;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get child(): java_.awt.Component;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface InstantSource {
        withZone(arg0: Internal.ZoneId): Internal.Clock
        millis(): number
        instant(): Internal.Instant
    }
    interface IdFunctionCall {
        execIdCall(arg0: Internal.IdFunctionObject, arg1: Internal.Context, arg2: Internal.Scriptable, arg3: Internal.Scriptable, arg4: any[]): any
    }
    class PageAttributes$ColorType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly MONOCHROME : Internal.PageAttributes$ColorType;
        static readonly COLOR : Internal.PageAttributes$ColorType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function8 <T1, T2, T3, T4, T5, T6, T7, T8, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function3<T6, T7, T8, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7, arg1: T8) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function5<T4, T5, T6, T7, T8, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function4<T5, T6, T7, T8, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function6<T3, T4, T5, T6, T7, T8, R>
        curry(): (arg0: T1) => Internal.Function7<T2, T3, T4, T5, T6, T7, T8, R>
    }
    class ItemBuilder extends Internal.BuilderBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        maxStackSize(v: number): Internal.ItemBuilder
        translationKey(key: string): Internal.BuilderBase
        color(index: number, c: number): Internal.ItemBuilder
        getBuilderType(): string
        displayName(name: string): Internal.BuilderBase
        newID(pre: string, post: string): ResourceLocation
        notifyAll(): void
        maxDamage(v: number): Internal.ItemBuilder
        tooltip(text: Internal.Component): Internal.ItemBuilder
        type(t: Internal.ItemType): Internal.ItemBuilder
        containerItem(id: string): Internal.ItemBuilder
        notify(): void
        subtypes(fn: (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>): Internal.ItemBuilder
        tier(t: string): Internal.ItemBuilder
        hashCode(): number
        getAttackSpeed(): number
        burnTime(v: number): Internal.ItemBuilder
        tag(tag: ResourceLocation): Internal.BuilderBase
        parentModel(m: string): Internal.ItemBuilder
        group(g: string): Internal.ItemBuilder
        attackDamage(f: number): Internal.ItemBuilder
        texture(tex: string): Internal.ItemBuilder
        food(b: (arg0: Internal.FoodBuilder) => void): Internal.ItemBuilder
        getMiningSpeed(): number
        miningSpeed(f: number): Internal.ItemBuilder
        unstackable(): Internal.ItemBuilder
        getAttackDamage(): number
        equals(arg0: any): boolean
        attackSpeed(f: number): Internal.ItemBuilder
        toString(): string
        glow(v: boolean): Internal.ItemBuilder
        rarity(v: Rarity): Internal.ItemBuilder
        createItemProperties(): Internal.Item$Properties
        toolTier : Internal.Tier;
        foodBuilder : Internal.FoodBuilder;
        defaultTags : Internal.Set<ResourceLocation>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Internal.Map<string, Internal.ArmorMaterial>;
        readonly id : ResourceLocation;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Internal.Map<string, Internal.Tier>;
        attackDamageBaseline : number;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContainerAccess {
        getRemoteSlots(): Internal.NonNullList<Internal.ItemStack>
        getLastSlots(): Internal.NonNullList<Internal.ItemStack>
    }
    interface Instancer <D> {
        notifyRemoval(): void
        createInstance(): D
        createInstances(arg0: D[]): void
        notifyDirty(): void
        stealInstance(arg0: D): void
    }
    class SimpleMapCodec <K, V> extends Internal.MapCodec<any> implements Internal.BaseMapCodec<K, V> {
        encode(arg0: any, arg1: Internal.DynamicOps<any>, arg2: Internal.RecordBuilder<any>): Internal.RecordBuilder<any>
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setPartial(arg0: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        notifyAll(): void
        deprecated(arg0: number): Internal.MapCodec<Internal.Map<K, V>>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<Internal.Map<K, V>>
        notify(): void
        flatXmap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.MapCodec<S_>
        hashCode(): number
        comap<B_>(arg0: (arg0: B_) => Internal.Map<K, V>): Internal.MapEncoder<B_>
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>, arg2: () => string): Internal.MapCodec<A_>
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>): Internal.MapCodec<A_>
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>
        xmap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.MapCodec<S_>
        map<B_>(arg0: (arg0: Internal.Map<K, V>) => B_): Internal.MapDecoder<B_>
        dependent<E_>(arg0: Internal.MapCodec<E_>, arg1: (arg0: Internal.Map<K, V>) => com.mojang.datafixers.util.Pair<E_, Internal.MapCodec<E_>>, arg2: (arg0: Internal.Map<K, V>, arg1: E_) => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<Internal.Map<K, V>>): Internal.MapEncoder<B_>
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>
        keyCodec(): Internal.Codec<K>
        decoder(): Internal.Decoder<Internal.Map<K, V>>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<any>
        encoder(): Internal.Encoder<Internal.Map<K, V>>
        orElse(arg0: (arg0: string) => void, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        orElse(arg0: (arg0: any) => any, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        orElse(arg0: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        forGetter<O_>(arg0: (arg0: O_) => Internal.Map<K, V>): Internal.RecordCodecBuilder<O_, Internal.Map<K, V>>
        ap<E_>(arg0: Internal.MapDecoder<(arg0: Internal.Map<K, V>) => E_>): Internal.MapDecoder<E_>
        flatMap<B_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<B_>): Internal.MapDecoder<B_>
        codec(): Internal.Codec<Internal.Map<K, V>>
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>
        static unit<A_>(arg0: () => A_): Internal.MapCodec<A_>
        elementCodec(): Internal.Codec<V>
        orElseGet(arg0: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        orElseGet(arg0: (arg0: any) => any, arg1: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        orElseGet(arg0: (arg0: string) => void, arg1: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>
        stable(): Internal.MapCodec<Internal.Map<K, V>>
        equals(arg0: any): boolean
        mapResult(arg0: Internal.MapCodec$ResultFunction<Internal.Map<K, V>>): Internal.MapCodec<Internal.Map<K, V>>
        toString(): string
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
        get class(): Internal.Class<any>;
        set partial(arg0: () => Internal.Map<K, V>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ImageProducer {
        isConsumer(arg0: Internal.ImageConsumer): boolean
        addConsumer(arg0: Internal.ImageConsumer): void
        requestTopDownLeftRightResend(arg0: Internal.ImageConsumer): void
        removeConsumer(arg0: Internal.ImageConsumer): void
        startProduction(arg0: Internal.ImageConsumer): void
    }
    interface Era extends Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        get(arg0: Internal.TemporalField): number
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
    }
    interface ProcessorHandle <Msg> extends Internal.AutoCloseable {
        close(): void
    }
    interface Spliterator <T> {
        trySplit(): Internal.Spliterator<T>
        tryAdvance(arg0: (arg0: T) => void): boolean
        characteristics(): number
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: T) => void): void
    }
    class PlayerStatsJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.PlayerJS<any>
        getPlayTime(): number
        getWalkDistance(): number
        getDamageAbsorbed(): number
        getCrouchDistance(): number
        notifyAll(): void
        getItemsPickedUp(item: Internal.Item): number
        getDamageDealt_absorbed(): number
        getFishCaught(): number
        getDeaths(): number
        notify(): void
        getSwimDistance(): number
        getItemsCrafted(item: Internal.Item): number
        getBlocksMined(block: Internal.Block): number
        getDamageDealt_resisted(): number
        getPlayerKills(): number
        hashCode(): number
        get(id: ResourceLocation): number
        getTimeSinceDeath(): number
        getDamageBlocked_by_shield(): number
        getKilled(entity: Internal.EntityType<any>): number
        getTimeCrouchTime(): number
        getDamageTaken(): number
        add(id: ResourceLocation, value: number): void
        getItemsDropped(item: Internal.Item): number
        set(id: ResourceLocation, value: number): void
        getJumps(): number
        getDamageResisted(): number
        getAnimalsBred(): number
        getItemsBroken(item: Internal.Item): number
        getMobKills(): number
        equals(arg0: any): boolean
        getSprintDistance(): number
        getTimeSinceRest(): number
        getKilledBy(entity: Internal.EntityType<any>): number
        toString(): string
        getDamageDealt(): number
        getItemsUsed(item: Internal.Item): number
        get playerKills(): number;
        get animalsBred(): number;
        get walkDistance(): number;
        get damageDealt_resisted(): number;
        get crouchDistance(): number;
        get damageAbsorbed(): number;
        get damageResisted(): number;
        get jumps(): number;
        get damageDealt_absorbed(): number;
        get timeSinceDeath(): number;
        get timeCrouchTime(): number;
        get damageBlocked_by_shield(): number;
        get fishCaught(): number;
        get mobKills(): number;
        get sprintDistance(): number;
        get timeSinceRest(): number;
        get swimDistance(): number;
        get playTime(): number;
        get class(): Internal.Class<any>;
        get deaths(): number;
        get damageDealt(): number;
        get player(): Internal.PlayerJS<any>;
        get damageTaken(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MenuContainer {
        getFont(): java_.awt.Font
        remove(arg0: Internal.MenuComponent): void
        postEvent(arg0: Internal.Event): boolean
    }
    interface Reference2ReferenceFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        get(arg0: any): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): V
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class JsonToken extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.JsonToken
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.JsonToken[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.JsonToken): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.JsonToken>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.JsonToken>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly NUMBER : Internal.JsonToken;
        static readonly NULL : Internal.JsonToken;
        static readonly END_DOCUMENT : Internal.JsonToken;
        static readonly BEGIN_OBJECT : Internal.JsonToken;
        static readonly END_ARRAY : Internal.JsonToken;
        static readonly STRING : Internal.JsonToken;
        static readonly END_OBJECT : Internal.JsonToken;
        static readonly BEGIN_ARRAY : Internal.JsonToken;
        static readonly BOOLEAN : Internal.JsonToken;
        static readonly NAME : Internal.JsonToken;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.JsonToken>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2LongFunction <K> extends Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        removeLong(arg0: any): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getLong(arg0: any): number
        applyAsLong(arg0: K): number
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Int2IntMap extends Internal.Int2IntFunction, Internal.Map<number, number> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: any, arg1: any): any
        replace(arg0: number, arg1: number): number
        replace(arg0: any, arg1: any, arg2: any): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        containsValue(arg0: any): boolean
        containsValue(arg0: number): boolean
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number
        mergeInt(arg0: number, arg1: number, arg2: java_.util.function_.IntBinaryOperator): number
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>
        entrySet(): Internal.Set<any>
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number
        values(): Internal.IntCollection
        values(): Internal.Collection<any>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number
        replaceAll(arg0: (arg0: number, arg1: number) => number): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        remove(arg0: any): any
        remove(arg0: any): number
        remove(arg0: number, arg1: number): boolean
        remove(arg0: any, arg1: any): boolean
        remove(arg0: number): number
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        hashCode(): number
        putAll(arg0: Internal.Map<number, number>): void
        get(arg0: any): any
        get(arg0: any): number
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.IntSet
        keySet(): Internal.Set<any>
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        forEach(arg0: (arg0: number, arg1: number) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: any, arg1: any): any
    }
    class ResolverStyle extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ResolverStyle
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ResolverStyle[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ResolverStyle): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ResolverStyle>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ResolverStyle>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly STRICT : Internal.ResolverStyle;
        static readonly LENIENT : Internal.ResolverStyle;
        static readonly SMART : Internal.ResolverStyle;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ResolverStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractIntCollection extends Internal.AbstractCollection<any> implements Internal.IntCollection {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        notify(): void
        remove(arg0: any): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.IntCollection): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.IntPredicate): boolean
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        toString(): string
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.IntCollection): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Material {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Reader implements Internal.Readable, Internal.Closeable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        read(arg0: string[]): number
        read(arg0: string[], arg1: number, arg2: number): number
        read(arg0: Internal.CharBuffer): number
        read(): number
        markSupported(): boolean
        notifyAll(): void
        skip(arg0: number): number
        transferTo(arg0: Internal.Writer): number
        notify(): void
        static nullReader(): Internal.Reader
        hashCode(): number
        ready(): boolean
        equals(arg0: any): boolean
        reset(): void
        toString(): string
        close(): void
        mark(arg0: number): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TooltipList {
        add(component: Internal.Component): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        blankLine(): void
        string(text: string): void
        notifyAll(): void
        styledString(text: string, color: Internal.ChatFormatting): void
        styledString(text: string, style: Internal.Style): void
        notify(): void
        translate(key: string, objects: any[]): void
        hashCode(): number
        styledTranslate(key: string, style: Internal.Style, objects: any[]): void
        equals(arg0: any): boolean
        reset(): void
        toString(): string
        shouldRender(): boolean
        render(mStack: Internal.PoseStack, mouseX: number, mouseY: number, screenWidth: number, screenHeight: number, font: Internal.Font): void
        backgroundColor : number;
        yOffset : number;
        zOffsetItemTooltip : number;
        xOffset : number;
        zOffset : number;
        borderColorStart : number;
        borderColorEnd : number;
        maxWidth : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Flushable {
        flush(): void
    }
    interface DoubleToIntFunction {
        applyAsInt(arg0: number): number
    }
    interface DoubleStream extends Internal.BaseStream<number, Internal.DoubleStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.DoubleStream
        takeWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream
        distinct(): Internal.DoubleStream
        findFirst(): Internal.OptionalDouble
        sum(): number
        skip(arg0: number): Internal.DoubleStream
        allMatch(arg0: Internal.DoublePredicate): boolean
        mapToObj<U_>(arg0: Internal.DoubleFunction<U_>): Internal.Stream<U_>
        mapMulti(arg0: Internal.DoubleStream$DoubleMapMultiConsumer): Internal.DoubleStream
        iterator(): Internal.PrimitiveIterator$OfDouble
        iterator(): Internal.Iterator<any>
        min(): Internal.OptionalDouble
        mapToLong(arg0: Internal.DoubleToLongFunction): Internal.LongStream
        parallel(): Internal.DoubleStream
        parallel(): Internal.BaseStream<any, any>
        noneMatch(arg0: Internal.DoublePredicate): boolean
        findAny(): Internal.OptionalDouble
        isParallel(): boolean
        limit(arg0: number): Internal.DoubleStream
        toArray(): number[]
        forEachOrdered(arg0: Internal.DoubleConsumer): void
        close(): void
        anyMatch(arg0: Internal.DoublePredicate): boolean
        map(arg0: Internal.DoubleUnaryOperator): Internal.DoubleStream
        unordered(): Internal.DoubleStream
        reduce(arg0: number, arg1: Internal.DoubleBinaryOperator): number
        reduce(arg0: Internal.DoubleBinaryOperator): Internal.OptionalDouble
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.Spliterator$OfDouble
        max(): Internal.OptionalDouble
        forEach(arg0: Internal.DoubleConsumer): void
        count(): number
        dropWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream
        peek(arg0: Internal.DoubleConsumer): Internal.DoubleStream
        flatMap(arg0: Internal.DoubleFunction<Internal.DoubleStream>): Internal.DoubleStream
        filter(arg0: Internal.DoublePredicate): Internal.DoubleStream
        onClose(arg0: Internal.Runnable): Internal.DoubleStream
        sorted(): Internal.DoubleStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.DoubleSummaryStatistics
        mapToInt(arg0: Internal.DoubleToIntFunction): Internal.IntStream
        collect<R_>(arg0: () => R_, arg1: Internal.ObjDoubleConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_
    }
    interface Reference2IntFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        removeInt(arg0: any): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getInt(arg0: any): number
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class PlayerEventJS extends Internal.LivingEntityEventJS {
        cancel(): void
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        addGameStage(stage: string): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        getPlayer(): Internal.PlayerJS<any>
        notifyAll(): void
        getEntity(): Internal.EntityJS
        notify(): void
        getLevel(): Internal.LevelJS
        getMinecraftPlayer(): Internal.Player
        post(id: string, sub: string): boolean
        post(id: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hasGameStage(stage: string): boolean
        hashCode(): number
        equals(arg0: any): boolean
        removeGameStage(stage: string): void
        toString(): string
        canCancel(): boolean
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ArmedModel {
    }
    class BigDecimal extends Internal.Number implements Internal.Comparable<Internal.BigDecimal> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        longValueExact(): number
        movePointLeft(arg0: number): Internal.BigDecimal
        notifyAll(): void
        precision(): number
        byteValueExact(): number
        toBigInteger(): Internal.BigInteger
        scale(): number
        toPlainString(): string
        compareTo(arg0: Internal.BigDecimal): number
        compareTo(arg0: any): number
        shortValueExact(): number
        notify(): void
        longValue(): number
        min(arg0: Internal.BigDecimal): Internal.BigDecimal
        unscaledValue(): Internal.BigInteger
        sqrt(arg0: Internal.MathContext): Internal.BigDecimal
        hashCode(): number
        scaleByPowerOfTen(arg0: number): Internal.BigDecimal
        pow(arg0: number): Internal.BigDecimal
        pow(arg0: number, arg1: Internal.MathContext): Internal.BigDecimal
        shortValue(): number
        divide(arg0: Internal.BigDecimal, arg1: number): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: Internal.RoundingMode): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: number): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: Internal.RoundingMode): Internal.BigDecimal
        multiply(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        multiply(arg0: Internal.BigDecimal): Internal.BigDecimal
        signum(): number
        add(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        add(arg0: Internal.BigDecimal): Internal.BigDecimal
        toBigIntegerExact(): Internal.BigInteger
        toEngineeringString(): string
        max(arg0: Internal.BigDecimal): Internal.BigDecimal
        static valueOf(arg0: number, arg1: number): Internal.BigDecimal
        static valueOf(arg0: number): Internal.BigDecimal
        static valueOf(arg0: number): Internal.BigDecimal
        intValue(): number
        setScale(arg0: number, arg1: Internal.RoundingMode): Internal.BigDecimal
        setScale(arg0: number): Internal.BigDecimal
        setScale(arg0: number, arg1: number): Internal.BigDecimal
        subtract(arg0: Internal.BigDecimal): Internal.BigDecimal
        subtract(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        floatValue(): number
        doubleValue(): number
        divideToIntegralValue(arg0: Internal.BigDecimal): Internal.BigDecimal
        divideToIntegralValue(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        plus(): Internal.BigDecimal
        plus(arg0: Internal.MathContext): Internal.BigDecimal
        abs(): Internal.BigDecimal
        abs(arg0: Internal.MathContext): Internal.BigDecimal
        round(arg0: Internal.MathContext): Internal.BigDecimal
        divideAndRemainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal[]
        divideAndRemainder(arg0: Internal.BigDecimal): Internal.BigDecimal[]
        negate(): Internal.BigDecimal
        negate(arg0: Internal.MathContext): Internal.BigDecimal
        movePointRight(arg0: number): Internal.BigDecimal
        equals(arg0: any): boolean
        ulp(): Internal.BigDecimal
        toString(): string
        stripTrailingZeros(): Internal.BigDecimal
        remainder(arg0: Internal.BigDecimal): Internal.BigDecimal
        remainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        intValueExact(): number
        byteValue(): number
        static readonly ZERO : Internal.BigDecimal;
        static readonly ROUND_DOWN : 1;
        static readonly ROUND_UNNECESSARY : 7;
        static readonly ROUND_CEILING : 2;
        static readonly ROUND_HALF_DOWN : 5;
        static readonly ROUND_HALF_UP : 4;
        static readonly ONE : Internal.BigDecimal;
        static readonly ROUND_UP : 0;
        static readonly ROUND_FLOOR : 3;
        static readonly ROUND_HALF_EVEN : 6;
        static readonly TEN : Internal.BigDecimal;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RenderingHints implements Internal.Map<any, any>, Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: any): any
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any
        notifyAll(): void
        values(): Internal.Collection<any>
        replace(arg0: any, arg1: any): any
        replace(arg0: any, arg1: any, arg2: any): boolean
        replaceAll(arg0: (arg0: any, arg1: any) => any): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: any, arg1: any): any
        remove(arg0: any): any
        remove(arg0: any, arg1: any): boolean
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        hashCode(): number
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        putAll(arg0: Internal.Map<any, any>): void
        get(arg0: any): any
        keySet(): Internal.Set<any>
        add(arg0: Internal.RenderingHints): void
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>
        forEach(arg0: (arg0: any, arg1: any) => void): void
        containsKey(arg0: any): boolean
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        size(): number
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: any, arg1: any): any
        static readonly VALUE_TEXT_ANTIALIAS_LCD_VRGB : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_VBGR : any;
        static readonly KEY_FRACTIONALMETRICS : Internal.RenderingHints$Key;
        static readonly VALUE_RESOLUTION_VARIANT_SIZE_FIT : any;
        static readonly VALUE_TEXT_ANTIALIAS_DEFAULT : any;
        static readonly VALUE_TEXT_ANTIALIAS_OFF : any;
        static readonly VALUE_ANTIALIAS_OFF : any;
        static readonly VALUE_INTERPOLATION_BICUBIC : any;
        static readonly VALUE_COLOR_RENDER_QUALITY : any;
        static readonly VALUE_COLOR_RENDER_DEFAULT : any;
        static readonly VALUE_STROKE_DEFAULT : any;
        static readonly VALUE_RENDER_DEFAULT : any;
        static readonly VALUE_RENDER_QUALITY : any;
        static readonly KEY_ALPHA_INTERPOLATION : Internal.RenderingHints$Key;
        static readonly KEY_DITHERING : Internal.RenderingHints$Key;
        static readonly VALUE_FRACTIONALMETRICS_OFF : any;
        static readonly VALUE_ANTIALIAS_DEFAULT : any;
        static readonly VALUE_ALPHA_INTERPOLATION_SPEED : any;
        static readonly KEY_TEXT_ANTIALIASING : Internal.RenderingHints$Key;
        static readonly VALUE_TEXT_ANTIALIAS_GASP : any;
        static readonly KEY_TEXT_LCD_CONTRAST : Internal.RenderingHints$Key;
        static readonly VALUE_RENDER_SPEED : any;
        static readonly VALUE_FRACTIONALMETRICS_ON : any;
        static readonly VALUE_RESOLUTION_VARIANT_DEFAULT : any;
        static readonly KEY_ANTIALIASING : Internal.RenderingHints$Key;
        static readonly VALUE_DITHER_ENABLE : any;
        static readonly KEY_STROKE_CONTROL : Internal.RenderingHints$Key;
        static readonly VALUE_STROKE_PURE : any;
        static readonly KEY_RENDERING : Internal.RenderingHints$Key;
        static readonly VALUE_DITHER_DEFAULT : any;
        static readonly KEY_RESOLUTION_VARIANT : Internal.RenderingHints$Key;
        static readonly VALUE_INTERPOLATION_BILINEAR : any;
        static readonly VALUE_ALPHA_INTERPOLATION_QUALITY : any;
        static readonly VALUE_RESOLUTION_VARIANT_BASE : any;
        static readonly KEY_COLOR_RENDERING : Internal.RenderingHints$Key;
        static readonly VALUE_RESOLUTION_VARIANT_DPI_FIT : any;
        static readonly VALUE_ANTIALIAS_ON : any;
        static readonly VALUE_STROKE_NORMALIZE : any;
        static readonly VALUE_FRACTIONALMETRICS_DEFAULT : any;
        static readonly VALUE_INTERPOLATION_NEAREST_NEIGHBOR : any;
        static readonly VALUE_DITHER_DISABLE : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_HRGB : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_HBGR : any;
        static readonly KEY_INTERPOLATION : Internal.RenderingHints$Key;
        static readonly VALUE_ALPHA_INTERPOLATION_DEFAULT : any;
        static readonly VALUE_TEXT_ANTIALIAS_ON : any;
        static readonly VALUE_COLOR_RENDER_SPEED : any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICapabilityProvider {
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
    }
    interface Iterator <E> {
        next(): E
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    class Method extends Internal.Executable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getParameterCount(): number
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getGenericReturnType(): Internal.Type
        notifyAll(): void
        isSynthetic(): boolean
        getAnnotatedParameterTypes(): Internal.AnnotatedType[]
        getParameterTypes(): Internal.Class<any>[]
        invoke(arg0: any, arg1: any[]): any
        isBridge(): boolean
        getGenericExceptionTypes(): Internal.Type[]
        notify(): void
        getAnnotatedReceiverType(): Internal.AnnotatedType
        getDefaultValue(): any
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaringClass(): Internal.Class<any>
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        hashCode(): number
        canAccess(arg0: any): boolean
        toGenericString(): string
        getTypeParameters(): any[]
        getModifiers(): number
        trySetAccessible(): boolean
        isAccessible(): boolean
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        isVarArgs(): boolean
        getAnnotations(): Internal.Annotation[]
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[]
        getExceptionTypes(): Internal.Class<any>[]
        isDefault(): boolean
        getGenericParameterTypes(): Internal.Type[]
        getReturnType(): Internal.Class<any>
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        equals(arg0: any): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getParameters(): any[]
        toString(): string
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get defaultValue(): any;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get default(): boolean;
        get exceptionTypes(): Internal.Class<any>[];
        get genericReturnType(): Internal.Type;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): Internal.Type[];
        get class(): Internal.Class<any>;
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        get declaredAnnotations(): Internal.Annotation[];
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): Internal.Type[];
        get name(): string;
        get bridge(): boolean;
        get parameterAnnotations(): Internal.Annotation[][];
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get returnType(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MouseButton {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isRight(): boolean
        isLeft(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get(i: number): Internal.MouseButton
        toString(): string
        getId(): number
        isMiddle(): boolean
        notify(): void
        static readonly LEFT : Internal.MouseButton;
        static readonly NEXT : Internal.MouseButton;
        static readonly RIGHT : Internal.MouseButton;
        static readonly BACK : Internal.MouseButton;
        readonly id : number;
        static readonly MIDDLE : Internal.MouseButton;
        get middle(): boolean;
        get left(): boolean;
        get right(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P4 <F, T1, T2, T3, T4> {
        t4(): Internal.App<F, T4>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function4<T1, T2, T3, T4, R>): Internal.App<F, R>
        hashCode(): number
        and<T5, T6, T7>(arg0: Internal.Products$P3<F, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T5>(arg0: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T5, T6>(arg0: Internal.Products$P2<F, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        and<T5, T6, T7, T8>(arg0: Internal.Products$P4<F, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        notify(): void
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Logger {
        getName(): string
        log(level: Internal.Level, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        log(level: Internal.Level, messageSupplier: Internal.MessageSupplier): void
        log(level: Internal.Level, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        log(level: Internal.Level, message: org.apache.logging.log4j.message.Message): void
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        log(level: Internal.Level, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        log(level: Internal.Level, message: string, params: any[]): void
        log(level: Internal.Level, message: string): void
        log(level: Internal.Level, message: any, throwable: Internal.Throwable): void
        log(level: Internal.Level, message: any): void
        log(level: Internal.Level, message: Internal.CharSequence): void
        log(level: Internal.Level, marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, message: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.CharSequence): void
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        log(level: Internal.Level, marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, params: any[]): void
        log(level: Internal.Level, marker: Internal.Marker, message: string): void
        log(level: Internal.Level, message: string, p0: any, p1: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        log(level: Internal.Level, message: string, p0: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        log(level: Internal.Level, message: Internal.CharSequence, throwable: Internal.Throwable): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any): void
        log(level: Internal.Level, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        log(level: Internal.Level, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        log(level: Internal.Level, message: string, throwable: Internal.Throwable): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        logMessage(level: Internal.Level, marker: Internal.Marker, fqcn: string, location: Internal.StackTraceElement, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        atWarn(): Internal.LogBuilder
        atInfo(): Internal.LogBuilder
        isWarnEnabled(): boolean
        isWarnEnabled(marker: Internal.Marker): boolean
        error(message: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        error(message: string, p0: any): void
        error(message: string, p0: any, p1: any): void
        error(message: string, p0: any, p1: any, p2: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any): void
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        error(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        error(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        error(message: string, throwable: Internal.Throwable): void
        error(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        error(message: string, params: any[]): void
        error(message: string): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        error(message: any, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any): void
        error(marker: Internal.Marker, message: string, p0: any): void
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        error(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        error(marker: Internal.Marker, message: string, params: any[]): void
        error(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        error(marker: Internal.Marker, message: string): void
        error(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: any): void
        error(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: Internal.CharSequence): void
        error(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        error(messageSupplier: Internal.MessageSupplier): void
        error(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        error(message: Internal.CharSequence): void
        error(message: Internal.CharSequence, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        error(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        error(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        error(message: org.apache.logging.log4j.message.Message): void
        printf(level: Internal.Level, marker: Internal.Marker, format: string, params: any[]): void
        printf(level: Internal.Level, format: string, params: any[]): void
        fatal(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        fatal(message: string, throwable: Internal.Throwable): void
        fatal(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        fatal(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: string, p0: any): void
        fatal(message: any, throwable: Internal.Throwable): void
        fatal(message: string): void
        fatal(message: string, params: any[]): void
        fatal(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        fatal(message: string, p0: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        fatal(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        fatal(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        fatal(message: org.apache.logging.log4j.message.Message): void
        fatal(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: any): void
        fatal(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: string): void
        fatal(marker: Internal.Marker, message: string, params: any[]): void
        fatal(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        fatal(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: Internal.CharSequence): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        fatal(message: any): void
        fatal(messageSupplier: Internal.MessageSupplier): void
        fatal(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        fatal(message: Internal.CharSequence): void
        fatal(message: Internal.CharSequence, throwable: Internal.Throwable): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        fatal(message: string, p0: any, p1: any): void
        fatal(message: string, p0: any, p1: any, p2: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any): void
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        throwing<T>(throwable: T): T
        throwing<T>(level: Internal.Level, throwable: T): T
        atTrace(): Internal.LogBuilder
        trace(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        trace(message: org.apache.logging.log4j.message.Message): void
        trace(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        trace(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        trace(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        trace(message: any): void
        trace(message: Internal.CharSequence, throwable: Internal.Throwable): void
        trace(message: Internal.CharSequence): void
        trace(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        trace(messageSupplier: Internal.MessageSupplier): void
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        trace(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        trace(marker: Internal.Marker, message: string, params: any[]): void
        trace(marker: Internal.Marker, message: string): void
        trace(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: any): void
        trace(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: Internal.CharSequence): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        trace(message: string, p0: any): void
        trace(message: string, p0: any, p1: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any): void
        trace(message: string, p0: any, p1: any, p2: any): void
        trace(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        trace(message: string, throwable: Internal.Throwable): void
        trace(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        trace(message: string, params: any[]): void
        trace(message: string): void
        trace(message: any, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        trace(marker: Internal.Marker, message: string, p0: any, p1: any): void
        trace(marker: Internal.Marker, message: string, p0: any): void
        trace(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        isInfoEnabled(marker: Internal.Marker): boolean
        isInfoEnabled(): boolean
        traceEntry(paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): Internal.EntryMessage
        traceEntry(): Internal.EntryMessage
        traceEntry(format: string, params: any[]): Internal.EntryMessage
        traceEntry(message: org.apache.logging.log4j.message.Message): Internal.EntryMessage
        traceEntry(format: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): Internal.EntryMessage
        isErrorEnabled(marker: Internal.Marker): boolean
        isErrorEnabled(): boolean
        isTraceEnabled(): boolean
        isTraceEnabled(marker: Internal.Marker): boolean
        atLevel(level: Internal.Level): Internal.LogBuilder
        info(marker: Internal.Marker, message: string, p0: any): void
        info(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        info(message: string, throwable: Internal.Throwable): void
        info(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any): void
        info(message: any): void
        info(message: Internal.CharSequence, throwable: Internal.Throwable): void
        info(message: Internal.CharSequence): void
        info(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        info(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        info(message: string, params: any[]): void
        info(message: string): void
        info(message: any, throwable: Internal.Throwable): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any): void
        info(message: string, p0: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        info(message: string, p0: any, p1: any): void
        info(message: string, p0: any, p1: any, p2: any): void
        info(marker: Internal.Marker, message: Internal.CharSequence): void
        info(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: any): void
        info(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: string): void
        info(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        info(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        info(message: org.apache.logging.log4j.message.Message): void
        info(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        info(messageSupplier: Internal.MessageSupplier): void
        info(marker: Internal.Marker, message: string, params: any[]): void
        info(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        info(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        always(): Internal.LogBuilder
        getMessageFactory<MF>(): MF
        catching(level: Internal.Level, throwable: Internal.Throwable): void
        catching(throwable: Internal.Throwable): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any): void
        debug(message: string, p0: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        debug(messageSupplier: Internal.MessageSupplier): void
        debug(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        debug(message: string, p0: any, p1: any): void
        debug(message: string, p0: any, p1: any, p2: any): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any): void
        debug(message: Internal.CharSequence, throwable: Internal.Throwable): void
        debug(message: Internal.CharSequence): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        debug(message: any): void
        debug(message: any, throwable: Internal.Throwable): void
        debug(message: string): void
        debug(marker: Internal.Marker, message: string, p0: any): void
        debug(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        debug(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        debug(message: string, throwable: Internal.Throwable): void
        debug(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        debug(message: string, params: any[]): void
        debug(marker: Internal.Marker, message: Internal.CharSequence): void
        debug(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: any): void
        debug(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string): void
        debug(marker: Internal.Marker, message: string, params: any[]): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        debug(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        debug(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        debug(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        debug(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        debug(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        debug(message: org.apache.logging.log4j.message.Message): void
        debug(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        atError(): Internal.LogBuilder
        atFatal(): Internal.LogBuilder
        traceExit(message: Internal.EntryMessage): void
        traceExit<R>(format: string, result: R): R
        traceExit<R>(result: R): R
        traceExit(): void
        traceExit<R>(message: org.apache.logging.log4j.message.Message, result: R): R
        traceExit<R>(message: Internal.EntryMessage, result: R): R
        isFatalEnabled(): boolean
        isFatalEnabled(marker: Internal.Marker): boolean
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        warn(message: string, p0: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void
        warn(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        warn(message: string, p0: any, p1: any): void
        warn(message: string, p0: any, p1: any, p2: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void
        warn(marker: Internal.Marker, message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        warn(marker: Internal.Marker, message: string, params: any[]): void
        warn(marker: Internal.Marker, message: string): void
        warn(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        warn(marker: Internal.Marker, messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        warn(message: org.apache.logging.log4j.message.Message): void
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        warn(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        warn(marker: Internal.Marker, message: Internal.CharSequence): void
        warn(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: any): void
        warn(message: string, throwable: Internal.Throwable): void
        warn(message: string, paramSuppliers: org.apache.logging.log4j.util.Supplier<any>[]): void
        warn(message: string, params: any[]): void
        warn(message: string): void
        warn(messageSupplier: org.apache.logging.log4j.util.Supplier<any>): void
        warn(messageSupplier: org.apache.logging.log4j.util.Supplier<any>, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: string, p0: any): void
        warn(message: Internal.CharSequence): void
        warn(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        warn(messageSupplier: Internal.MessageSupplier): void
        warn(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        warn(message: Internal.CharSequence, throwable: Internal.Throwable): void
        warn(message: any): void
        warn(message: any, throwable: Internal.Throwable): void
        entry(params: any[]): void
        entry(): void
        exit<R>(result: R): R
        exit(): void
        getLevel(): Internal.Level
        isEnabled(level: Internal.Level): boolean
        isEnabled(level: Internal.Level, marker: Internal.Marker): boolean
        isDebugEnabled(): boolean
        isDebugEnabled(marker: Internal.Marker): boolean
        atDebug(): Internal.LogBuilder
    }
    class UnitStorage {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addFunc(name: string, func: Internal.FuncSupplier): void
        notifyAll(): void
        addOp(name: string, op: Internal.OpSupplier): void
        setVariable(key: string, unit: Internal.Unit): void
        getVariableVersion(): number
        parse(string: string): Internal.Unit
        getVariable(key: string): Internal.Unit
        notify(): void
        clearVariables(): void
        addConstant(name: string, val: number): void
        hashCode(): number
        createFunc(name: string, args: Internal.List<Internal.Unit>): Internal.Unit
        equals(arg0: any): boolean
        getConstant(name: string): Internal.ConstantUnit
        toString(): string
        addFunc2(name: string, func: Internal.FuncSupplier$Func2): void
        addFunc1(name: string, func: Internal.FuncSupplier$Func1): void
        createOp(name: string, unit: Internal.Unit, with_: Internal.Unit): Internal.Unit
        get variableVersion(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemLike {
    }
    interface EntityKJS extends Internal.AsKJS {
        getPersistentDataKJS(): Internal.CompoundTag
        asKJS(): any
    }
    interface Channel extends Internal.Closeable {
        isOpen(): boolean
        close(): void
    }
    interface TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number
        query<R>(arg0: Internal.TemporalQuery<R>): R
        get(arg0: Internal.TemporalField): number
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
    }
    interface LivingEntityAccessor {
    }
    abstract class WritableRegistry <T> extends Internal.Registry<any> {
        getClass(): Internal.Class<any>
        iterator(): Internal.Iterator<T>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        hashCode(): number
        keys<U_>(arg0: Internal.DynamicOps<U_>): Internal.Stream<U_>
        notifyAll(): void
        equals(arg0: any): boolean
        static invokeRegisterSimple_$md$204703$1(arg0: Internal.ResourceKey<any>, arg1: () => any)): Internal.Registry<any>
        static callRegisterDefaulted_$md$204703$0(arg0: Internal.ResourceKey<any>, arg1: string, arg2: () => any)): Internal.DefaultedRegistry<any>
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecvByteBufAllocator {
        newHandle(): Internal.RecvByteBufAllocator$Handle
    }
    interface Byte2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class BlockBehaviour$BlockStateBase extends Internal.StateHolder<any, any> implements Internal.BlockStateKJS, Internal.BlockStateLightInfoAccess {
        getNeighborTable(): Internal.Table<any, any, any>
        getStateIndex(): number
        handler$zma000$cacheStateTail(ci: Internal.CallbackInfo): void
        getClass(): Internal.Class<any>
        setDestroySpeedKJS(arg0: number): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setLightEmissionKJS(arg0: number): void
        redirect$zlm000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any
        setNeighborTable(table: Internal.Table<any, any, any>): void
        notifyAll(): void
        setStateMap(newValue: Internal.FastMap<any>): void
        getLightInfo(): Internal.BlockStateLightInfo
        getStateMap(): Internal.FastMap<any>
        setRequiresToolKJS(arg0: boolean): void
        notify(): void
        setMaterialKJS(arg0: Internal.Material): void
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void
        handler$zpj000$onBlockCollision(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity, arg3: Internal.CallbackInfo): void
        hashCode(): number
        handler$zma000$cacheStateHead(ci: Internal.CallbackInfo): void
        equals(arg0: any): boolean
        setStateIndex(newValue: number): void
        toString(): string
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get lightInfo(): Internal.BlockStateLightInfo;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set materialKJS(arg0: Internal.Material);
        set requiresToolKJS(arg0: boolean);
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        set destroySpeedKJS(arg0: number);
        set lightEmissionKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecipeManager extends Internal.SimpleJsonResourceReloadListener implements Internal.AccessorRecipeManager, Internal.RecipeManagerKJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        customRecipesKJS(jsonMap: Internal.Map<ResourceLocation, Internal.JsonObject>): void
        notifyAll(): void
        setByNameKJS(arg0: Internal.Map<any, any>): void
        notify(): void
        setRecipesKJS(arg0: Internal.Map<any, any>): void
        getByNameKJS(): Internal.Map<any, any>
        hashCode(): number
        equals(arg0: any): boolean
        botania_getAll(arg0: Internal.RecipeType<any>): Internal.Map<any, any>
        toString(): string
        handler$zoo000$reloadRecipes_HammerLib(arg0: Internal.Map<any, any>, arg1: Internal.ResourceManager, arg2: Internal.ProfilerFiller, arg3: Internal.CallbackInfo): void
        getGson(): Internal.Gson
        getRecipesKJS(): Internal.Map<any, any>
        get recipesKJS(): Internal.Map<any, any>;
        get byNameKJS(): Internal.Map<any, any>;
        get gson(): Internal.Gson;
        get class(): Internal.Class<any>;
        set recipesKJS(arg0: Internal.Map<any, any>);
        set byNameKJS(arg0: Internal.Map<any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DateTimeFormatter {
        withLocale(arg0: Internal.Locale): Internal.DateTimeFormatter
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        parseBest(arg0: Internal.CharSequence, arg1: Internal.TemporalQuery<any>[]): Internal.TemporalAccessor
        static ofLocalizedDateTime(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        static ofLocalizedDateTime(arg0: Internal.FormatStyle, arg1: Internal.FormatStyle): Internal.DateTimeFormatter
        notifyAll(): void
        getResolverFields(): Internal.Set<Internal.TemporalField>
        static ofPattern(arg0: string): Internal.DateTimeFormatter
        static ofPattern(arg0: string, arg1: Internal.Locale): Internal.DateTimeFormatter
        notify(): void
        static ofLocalizedDate(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        formatTo(arg0: Internal.TemporalAccessor, arg1: Internal.Appendable): void
        static parsedLeapSecond(): Internal.TemporalQuery<boolean>
        hashCode(): number
        getChronology(): Internal.Chronology
        withChronology(arg0: Internal.Chronology): Internal.DateTimeFormatter
        withDecimalStyle(arg0: Internal.DecimalStyle): Internal.DateTimeFormatter
        localizedBy(arg0: Internal.Locale): Internal.DateTimeFormatter
        withZone(arg0: Internal.ZoneId): Internal.DateTimeFormatter
        static parsedExcessDays(): Internal.TemporalQuery<Internal.Period>
        withResolverStyle(arg0: Internal.ResolverStyle): Internal.DateTimeFormatter
        getResolverStyle(): Internal.ResolverStyle
        format(arg0: Internal.TemporalAccessor): string
        getZone(): Internal.ZoneId
        parse<T>(arg0: Internal.CharSequence, arg1: Internal.TemporalQuery<T>): T
        parse(arg0: Internal.CharSequence): Internal.TemporalAccessor
        parse(arg0: Internal.CharSequence, arg1: Internal.ParsePosition): Internal.TemporalAccessor
        getDecimalStyle(): Internal.DecimalStyle
        toFormat(arg0: Internal.TemporalQuery<any>): Internal.Format
        toFormat(): Internal.Format
        static ofLocalizedTime(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        equals(arg0: any): boolean
        toString(): string
        withResolverFields(arg0: Internal.TemporalField[]): Internal.DateTimeFormatter
        withResolverFields(arg0: Internal.Set<Internal.TemporalField>): Internal.DateTimeFormatter
        getLocale(): Internal.Locale
        parseUnresolved(arg0: Internal.CharSequence, arg1: Internal.ParsePosition): Internal.TemporalAccessor
        static readonly ISO_OFFSET_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE_TIME : Internal.DateTimeFormatter;
        static readonly RFC_1123_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_INSTANT : Internal.DateTimeFormatter;
        static readonly ISO_ZONED_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE : Internal.DateTimeFormatter;
        static readonly ISO_ORDINAL_DATE : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE : Internal.DateTimeFormatter;
        static readonly BASIC_ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_WEEK_DATE : Internal.DateTimeFormatter;
        get resolverFields(): Internal.Set<Internal.TemporalField>;
        get zone(): Internal.ZoneId;
        get decimalStyle(): Internal.DecimalStyle;
        get resolverStyle(): Internal.ResolverStyle;
        get chronology(): Internal.Chronology;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PlayerTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer, message: string): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.ServerPlayer
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getOwner(): Internal.UUID
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        notify(): void
        getColoredName(): Internal.Component
        serializeNBT(): Internal.SNBTCompoundTag
        hashCode(): number
        hasTeam(): boolean
        info(source: Internal.CommandSourceStack): number
        settings(source: Internal.CommandSourceStack, key: Internal.TeamProperty<any>, value: string): number
        updatePresence(): void
        isAlly(profile: Internal.UUID): boolean
        getProperty<T_>(property: Internal.TeamProperty<T_>): T_
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        sendMessage(from: Internal.UUID, text: Internal.Component): void
        deserializeNBT(tag: Internal.CompoundTag): void
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        getOnlineRanked(rank: Internal.TeamRank): Internal.List<Internal.ServerPlayer>
        denyInvite(source: Internal.CommandSourceStack): number
        isFreeToJoin(): boolean
        createParty(player: Internal.ServerPlayer, name: string, description: string, color: number, invited: Internal.Set<Internal.GameProfile>): void
        getDisplayName(): string
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        getType(): Internal.TeamType
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>
        setProperty<T_>(property: Internal.TeamProperty<T_>, value: T_): void
        equals(o: any): boolean
        toString(): string
        getMembers(): Internal.Set<Internal.UUID>
        actualTeam : Internal.Team;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        playerName : string;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        online : boolean;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        get player(): Internal.ServerPlayer;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PageAttributes$OrientationRequestedType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly LANDSCAPE : Internal.PageAttributes$OrientationRequestedType;
        static readonly PORTRAIT : Internal.PageAttributes$OrientationRequestedType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EventExecutor extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        next(): Internal.EventExecutor
        terminationFuture(): Internal.Future<any>
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>
        submit(arg0: Internal.Runnable): Internal.Future<any>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        shutdownGracefully(): Internal.Future<any>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>
        spliterator(): Internal.Spliterator<Internal.EventExecutor>
        isTerminated(): boolean
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>
        execute(arg0: Internal.Runnable): void
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        isShuttingDown(): boolean
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        newPromise<V_>(): Internal.Promise<V_>
    }
    abstract class EffectRenderer {
        renderInventoryEffect(arg0: Internal.MobEffectInstance, arg1: Internal.EffectRenderingInventoryScreen<any>, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number): void
        getClass(): Internal.Class<any>
        shouldRenderHUD(arg0: Internal.MobEffectInstance): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        shouldRenderInvText(arg0: Internal.MobEffectInstance): boolean
        shouldRender(arg0: Internal.MobEffectInstance): boolean
        notify(): void
        renderHUDEffect(arg0: Internal.MobEffectInstance, arg1: Internal.GuiComponent, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number, arg6: number): void
        static readonly DUMMY : Internal.EffectRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RayTraceResultJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        readonly fromEntity : Internal.EntityJS;
        readonly distance : number;
        hitX : number;
        hitY : number;
        hitZ : number;
        facing : Internal.Direction;
        block : Internal.BlockContainerJS;
        readonly type : string;
        entity : Internal.EntityJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FunctionContainer {
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        furnaceSmelt(): Internal.FunctionContainer
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
    }
    interface RecipeManagerKJS {
        customRecipesKJS(jsonMap: Internal.Map<ResourceLocation, Internal.JsonObject>): void
        getByNameKJS(): Internal.Map<ResourceLocation, Internal.Recipe<any>>
        setByNameKJS(arg0: Internal.Map<ResourceLocation, Internal.Recipe<any>>): void
        setRecipesKJS(arg0: Internal.Map<Internal.RecipeType<any>, Internal.Map<ResourceLocation, Internal.Recipe<any>>>): void
        getRecipesKJS(): Internal.Map<Internal.RecipeType<any>, Internal.Map<ResourceLocation, Internal.Recipe<any>>>
    }
    interface MapLike <T> {
        entries(): Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>
        get(arg0: T): T
        get(arg0: string): T
    }
    interface MatchResult {
        groupCount(): number
        start(arg0: number): number
        start(): number
        end(arg0: number): number
        end(): number
        group(): string
        group(arg0: number): string
    }
    interface IdEnumerationIterator {
        enumerationIteratorNext(arg0: Internal.Context, arg1: (arg0: any) => void): boolean
        enumerationIteratorHasNext(arg0: Internal.Context, arg1: (arg0: any) => void): boolean
    }
    abstract class DiscreteVoxelShape implements Internal.DiscreteVSAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getZSize(): number
        toString(): string
        getYSize(): number
        getXSize(): number
        notify(): void
        get zSize(): number;
        get ySize(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectListIterator <K> extends Internal.ObjectBidirectionalIterator<K>, Internal.ListIterator<K> {
        next(): K
        add(arg0: K): void
        set(arg0: K): void
        previous(): K
        previous(): K
        hasPrevious(): boolean
        hasPrevious(): boolean
        back(arg0: number): number
        hasNext(): boolean
        skip(arg0: number): number
        nextIndex(): number
        forEachRemaining(arg0: (arg0: K) => void): void
        previousIndex(): number
        remove(): void
    }
    class LunarContext$LunarTimeSettings {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDayLength(): number
        getMinDaysBetweenLunarEvents(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getYearLength(): number
        notify(): void
        static readonly CODEC : Internal.Codec<Internal.LunarContext$LunarTimeSettings>;
        static readonly DEFAULT : Internal.LunarContext$LunarTimeSettings;
        get dayLength(): number;
        get yearLength(): number;
        get minDaysBetweenLunarEvents(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockAccessor {
        getMaterial(): Internal.Material
    }
    class CursorType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static set(type: Internal.CursorType): void
        static valueOf(name: string): Internal.CursorType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.CursorType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.CursorType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.CursorType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.CursorType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly VRESIZE : Internal.CursorType;
        static readonly ARROW : Internal.CursorType;
        static readonly CROSSHAIR : Internal.CursorType;
        static readonly IBEAM : Internal.CursorType;
        static readonly HRESIZE : Internal.CursorType;
        static readonly HAND : Internal.CursorType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.CursorType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Pair <L, R> implements Internal.Map$Entry<L, R>, Internal.Comparable<Internal.Pair<L, R>>, Internal.Serializable {
        getClass(): Internal.Class<any>
        getKey(): L
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        compareTo(arg0: Internal.Pair<L, R>): number
        compareTo(arg0: any): number
        notify(): void
        getValue(): R
        getRight(): R
        hashCode(): number
        setValue(arg0: R): R
        static of<L_, R_>(arg0: Internal.Map$Entry<L_, R_>): Internal.Pair<L_, R_>
        static of<L_, R_>(arg0: L_, arg1: R_): Internal.Pair<L_, R_>
        equals(arg0: any): boolean
        toString(): string
        toString(arg0: string): string
        static emptyArray<L_, R_>(): Internal.Pair<L_, R_>[]
        getLeft(): L
        static readonly EMPTY_ARRAY : Internal.Pair<any, any>[];
        get left(): L;
        get right(): R;
        get class(): Internal.Class<any>;
        get value(): R;
        get key(): L;
        set value(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DragSourceDropEvent extends Internal.DragSourceEvent {
        getDropSuccess(): boolean
        getDropAction(): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        notifyAll(): void
        notify(): void
        getX(): number
        getY(): number
        hashCode(): number
        getSource(): any
        getDragSourceContext(): Internal.DragSourceContext
        equals(arg0: any): boolean
        toString(): string
        get dropSuccess(): boolean;
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Line2D implements Internal.Shape, Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static relativeCCW(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        relativeCCW(arg0: Internal.Point2D): number
        relativeCCW(arg0: number, arg1: number): number
        intersects(arg0: Internal.Rectangle2D): boolean
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        notifyAll(): void
        static ptLineDistSq(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        ptLineDistSq(arg0: Internal.Point2D): number
        ptLineDistSq(arg0: number, arg1: number): number
        notify(): void
        ptLineDist(arg0: number, arg1: number): number
        ptLineDist(arg0: Internal.Point2D): number
        static ptLineDist(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        getBounds(): Internal.Rectangle
        getY2(): number
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        getY1(): number
        hashCode(): number
        getP2(): Internal.Point2D
        static linesIntersect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): boolean
        getX2(): number
        getP1(): Internal.Point2D
        ptSegDistSq(arg0: number, arg1: number): number
        static ptSegDistSq(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        ptSegDistSq(arg0: Internal.Point2D): number
        contains(arg0: Internal.Point2D): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        contains(arg0: number, arg1: number): boolean
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersectsLine(arg0: Internal.Line2D): boolean
        ptSegDist(arg0: Internal.Point2D): number
        ptSegDist(arg0: number, arg1: number): number
        static ptSegDist(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        getX1(): number
        equals(arg0: any): boolean
        getBounds2D(): Internal.Rectangle2D
        clone(): any
        toString(): string
        setLine(arg0: number, arg1: number, arg2: number, arg3: number): void
        setLine(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        setLine(arg0: Internal.Line2D): void
        get p1(): Internal.Point2D;
        get p2(): Internal.Point2D;
        get bounds(): Internal.Rectangle;
        get y1(): number;
        get y2(): number;
        get x1(): number;
        get x2(): number;
        get bounds2D(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        set line(arg0: Internal.Line2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface URLStreamHandlerFactory {
        createURLStreamHandler(arg0: string): Internal.URLStreamHandler
    }
    class IdFunctionObject extends Internal.BaseFunction {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable
        getAllIds(): any[]
        put(name: string, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        getArity(): number
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        hasPrototypeMap(): boolean
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getFunctionName(): string
        getExternalArrayLength(): any
        getAttributes(key: Internal.Symbol): number
        getAttributes(name: string): number
        getAttributes(index: number): number
        setImmunePrototypeProperty(value: any): void
        hasInstance(instance: Internal.Scriptable): boolean
        hasTag(tag: any): boolean
        getAssociatedValue(key: any): any
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getClassName(): string
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addAsProperty(target: Internal.Scriptable): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        notifyAll(): void
        methodId(): number
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        unknown(): Internal.RuntimeException
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        markAsConstructor(prototypeProperty: Internal.Scriptable): void
        exportAsScopeProperty(): void
        hashCode(): number
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        initFunction(name: string, scope: Internal.Scriptable): void
        activatePrototypeMap(maxPrototypeId: number): void
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        getTag(): any
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        getLength(): number
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get tag(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AttributedCharacterIterator$Attribute implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Chapter extends Internal.QuestObject {
        getClass(): Internal.Class<any>
        getIndex(): number
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        hasGroup(): boolean
        getPath(): string
        clearCachedData(): void
        editedFromGUI(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        getChildren(): Internal.Collection<Internal.QuestObject>
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getAltTitle(): Internal.Component
        getAltTitle(): Internal.MutableComponent
        deleteSelf(): void
        cacheProgress(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getDefaultQuestShape(): string
        notify(): void
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getQuestFile(): Internal.QuestFile
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getFilename(): string
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        disableToast : boolean;
        readonly images : Internal.List<Internal.ChapterImage>;
        readonly quests : Internal.List<Internal.Quest>;
        alwaysInvisible : boolean;
        icon : Internal.ItemStack;
        title : string;
        defaultQuestShape : string;
        readonly file : Internal.QuestFile;
        filename : string;
        readonly subtitle : Internal.List<string>;
        invalid : boolean;
        defaultHideDependencyLines : boolean;
        static sendNotifications : Internal.Tristate;
        id : number;
        group : Internal.ChapterGroup;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.MutableComponent;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MethodType implements Internal.Constable, Internal.TypeDescriptor$OfMethod<Internal.Class<any>, Internal.MethodType>, Internal.Serializable {
        getClass(): Internal.Class<any>
        toMethodDescriptorString(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodType
        changeReturnType(arg0: Internal.Class<any>): Internal.MethodType
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        notifyAll(): void
        static fromMethodDescriptorString(arg0: string, arg1: Internal.ClassLoader): Internal.MethodType
        lastParameterType(): Internal.Class<any>
        describeConstable(): Internal.Optional<Internal.MethodTypeDesc>
        notify(): void
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        changeParameterType(arg0: number, arg1: Internal.Class<any>): Internal.MethodType
        unwrap(): Internal.MethodType
        hasWrappers(): boolean
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>[]): Internal.MethodType
        static methodType(arg0: Internal.Class<any>, arg1: Internal.MethodType): Internal.MethodType
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>, arg2: Internal.Class<any>[]): Internal.MethodType
        static methodType(arg0: Internal.Class<any>, arg1: Internal.List<Internal.Class<any>>): Internal.MethodType
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>): Internal.MethodType
        static methodType(arg0: Internal.Class<any>): Internal.MethodType
        parameterArray(): Internal.Class<any>[]
        parameterArray(): Internal.TypeDescriptor$OfField[]
        hashCode(): number
        appendParameterTypes(arg0: Internal.List<Internal.Class<any>>): Internal.MethodType
        appendParameterTypes(arg0: Internal.Class<any>[]): Internal.MethodType
        parameterType(arg0: number): Internal.Class<any>
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>
        erase(): Internal.MethodType
        parameterCount(): number
        descriptorString(): string
        insertParameterTypes(arg0: number, arg1: Internal.List<Internal.Class<any>>): Internal.MethodType
        insertParameterTypes(arg0: number, arg1: Internal.Class<any>[]): Internal.MethodType
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>
        generic(): Internal.MethodType
        hasPrimitives(): boolean
        equals(arg0: any): boolean
        parameterList(): Internal.List<Internal.Class<any>>
        toString(): string
        static genericMethodType(arg0: number, arg1: boolean): Internal.MethodType
        static genericMethodType(arg0: number): Internal.MethodType
        wrap(): Internal.MethodType
        returnType(): Internal.Class<any>
        returnType(): Internal.TypeDescriptor$OfField<any>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LambDynamicLight {
        getDynamicLightY(): number
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        resetDynamicLight(): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        getLuminance(): number
        isDynamicLightEnabled(): boolean
        dynamicLightTick(): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
    }
    class URI implements Internal.Comparable<Internal.URI>, Internal.Serializable {
        getClass(): Internal.Class<any>
        toASCIIString(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        resolve(arg0: string): Internal.URI
        resolve(arg0: Internal.URI): Internal.URI
        isOpaque(): boolean
        notifyAll(): void
        compareTo(arg0: Internal.URI): number
        compareTo(arg0: any): number
        notify(): void
        getRawAuthority(): string
        hashCode(): number
        normalize(): Internal.URI
        getPath(): string
        static create(arg0: string): Internal.URI
        relativize(arg0: Internal.URI): Internal.URI
        getQuery(): string
        getHost(): string
        toURL(): Internal.URL
        getScheme(): string
        getAuthority(): string
        getRawFragment(): string
        getRawUserInfo(): string
        parseServerAuthority(): Internal.URI
        getRawSchemeSpecificPart(): string
        getRawQuery(): string
        getPort(): number
        equals(arg0: any): boolean
        isAbsolute(): boolean
        toString(): string
        getFragment(): string
        getRawPath(): string
        getUserInfo(): string
        getSchemeSpecificPart(): string
        get rawFragment(): string;
        get userInfo(): string;
        get opaque(): boolean;
        get scheme(): string;
        get query(): string;
        get schemeSpecificPart(): string;
        get rawUserInfo(): string;
        get path(): string;
        get fragment(): string;
        get rawPath(): string;
        get rawSchemeSpecificPart(): string;
        get port(): number;
        get rawAuthority(): string;
        get absolute(): boolean;
        get authority(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get rawQuery(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DragGestureEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        getSourceAsDragGestureRecognizer(): Internal.DragGestureRecognizer
        iterator(): Internal.Iterator<Internal.InputEvent>
        getDragAction(): number
        getTriggerEvent(): Internal.InputEvent
        getDragOrigin(): Internal.Point
        hashCode(): number
        getSource(): any
        getDragSource(): Internal.DragSource
        equals(arg0: any): boolean
        toArray(arg0: any[]): any[]
        toArray(): any[]
        startDrag(arg0: Internal.Cursor, arg1: Internal.Transferable): void
        startDrag(arg0: Internal.Cursor, arg1: Internal.Transferable, arg2: Internal.DragSourceListener): void
        startDrag(arg0: Internal.Cursor, arg1: Internal.Image, arg2: Internal.Point, arg3: Internal.Transferable, arg4: Internal.DragSourceListener): void
        toString(): string
        getComponent(): java_.awt.Component
        get component(): java_.awt.Component;
        get sourceAsDragGestureRecognizer(): Internal.DragGestureRecognizer;
        get triggerEvent(): Internal.InputEvent;
        get dragAction(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        get dragOrigin(): Internal.Point;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InteractionResult extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.InteractionResult
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.InteractionResult[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.InteractionResult): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.InteractionResult>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.InteractionResult>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SUCCESS : Internal.InteractionResult;
        static readonly PASS : Internal.InteractionResult;
        static readonly CONSUME_PARTIAL : Internal.InteractionResult;
        static readonly CONSUME : Internal.InteractionResult;
        static readonly FAIL : Internal.InteractionResult;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.InteractionResult>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CompletableFuture <T> implements java_.util.concurrent.Future<T>, Internal.CompletionStage<T> {
        cancel(arg0: boolean): boolean
        getClass(): Internal.Class<any>
        obtrudeValue(arg0: T): void
        exceptionallyAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>
        exceptionallyAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletableFuture<T>
        static failedStage<U_>(arg0: Internal.Throwable): Internal.CompletionStage<U_>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>
        obtrudeException(arg0: Internal.Throwable): void
        thenAcceptBoth(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>
        thenAcceptBoth<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void): Internal.CompletableFuture<void>
        join(): T
        exceptionallyCompose(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>
        isCompletedExceptionally(): boolean
        applyToEither<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_): Internal.CompletableFuture<U_>
        applyToEither(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any): Internal.CompletionStage<any>
        completeAsync(arg0: () => T): Internal.CompletableFuture<T>
        completeAsync(arg0: () => T, arg1: Internal.Executor): Internal.CompletableFuture<T>
        thenApply<U_>(arg0: (arg0: T) => U_): Internal.CompletableFuture<U_>
        thenApply(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<any>
        thenRun(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        orTimeout(arg0: number, arg1: Internal.TimeUnit): Internal.CompletableFuture<T>
        getNow(arg0: T): T
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>
        exceptionally(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        handle<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_): Internal.CompletableFuture<U_>
        handle(arg0: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>
        thenCompose(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        thenCompose<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>): Internal.CompletableFuture<U_>
        static failedFuture<U_>(arg0: Internal.Throwable): Internal.CompletableFuture<U_>
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any, arg2: Internal.Executor): Internal.CompletionStage<any>
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_, arg2: Internal.Executor): Internal.CompletableFuture<V_>
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_): Internal.CompletableFuture<V_>
        static completedFuture<U_>(arg0: U_): Internal.CompletableFuture<U_>
        getNumberOfDependents(): number
        whenCompleteAsync(arg0: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletableFuture<T>
        whenCompleteAsync(arg0: (arg0: any, arg1: any) => void, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenApplyAsync<U_>(arg0: (arg0: T) => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>
        thenApplyAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenApplyAsync<U_>(arg0: (arg0: T) => U_): Internal.CompletableFuture<U_>
        thenApplyAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: (arg0: any) => void): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletableFuture<void>
        thenAcceptAsync(arg0: (arg0: any) => void, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletableFuture<void>
        toCompletableFuture(): Internal.CompletableFuture<T>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        static runAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        static runAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<any>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>
        static allOf(arg0: Internal.CompletableFuture<any>[]): Internal.CompletableFuture<void>
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any, arg2: Internal.Executor): Internal.CompletionStage<any>
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_, arg2: Internal.Executor): Internal.CompletableFuture<U_>
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any): Internal.CompletionStage<any>
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_): Internal.CompletableFuture<U_>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void, arg2: Internal.Executor): Internal.CompletionStage<any>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void): Internal.CompletionStage<any>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>
        newIncompleteFuture<U_>(): Internal.CompletableFuture<U_>
        hashCode(): number
        get(): T
        get(arg0: number, arg1: Internal.TimeUnit): T
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>
        acceptEither(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void): Internal.CompletionStage<any>
        copy(): Internal.CompletableFuture<T>
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        thenComposeAsync<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>, arg1: Internal.Executor): Internal.CompletableFuture<U_>
        thenComposeAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenComposeAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        thenComposeAsync<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>): Internal.CompletableFuture<U_>
        thenAccept(arg0: (arg0: T) => void): Internal.CompletableFuture<void>
        thenAccept(arg0: (arg0: any) => void): Internal.CompletionStage<any>
        isCancelled(): boolean
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        static anyOf(arg0: Internal.CompletableFuture<any>[]): Internal.CompletableFuture<any>
        defaultExecutor(): Internal.Executor
        completeOnTimeout(arg0: T, arg1: number, arg2: Internal.TimeUnit): Internal.CompletableFuture<T>
        handleAsync(arg0: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>
        handleAsync<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_): Internal.CompletableFuture<U_>
        handleAsync<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>
        handleAsync(arg0: (arg0: any, arg1: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>
        static supplyAsync<U_>(arg0: () => U_): Internal.CompletableFuture<U_>
        static supplyAsync<U_>(arg0: () => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>
        completeExceptionally(arg0: Internal.Throwable): boolean
        isDone(): boolean
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>
        whenComplete(arg0: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void, arg2: Internal.Executor): Internal.CompletionStage<any>
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void): Internal.CompletableFuture<void>
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit): Internal.Executor
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit, arg2: Internal.Executor): Internal.Executor
        exceptionallyComposeAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletableFuture<T>
        exceptionallyComposeAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>
        thenCombine<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_): Internal.CompletableFuture<V_>
        thenCombine(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>
        equals(arg0: any): boolean
        toString(): string
        minimalCompletionStage(): Internal.CompletionStage<T>
        complete(arg0: T): boolean
        static completedStage<U_>(arg0: U_): Internal.CompletionStage<U_>
        get numberOfDependents(): number;
        get cancelled(): boolean;
        get completedExceptionally(): boolean;
        get class(): Internal.Class<any>;
        get done(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MobSpawnSettings implements Internal.MobSpawnInfoAccess {
        getSpawners(): Internal.Map<any, any>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getEntityTypes(): Internal.Set<Internal.EntityType<any>>
        hashCode(): number
        static create_$md$204703$0(arg0: number, arg1: Internal.Map<any, any>, arg2: Internal.Map<any, any>): Internal.MobSpawnSettings
        notifyAll(): void
        equals(arg0: any): boolean
        getMobSpawnCosts(): Internal.Map<any, any>
        toString(): string
        notify(): void
        getSpawnerTypes(): Internal.Set<Internal.MobCategory>
        get mobSpawnCosts(): Internal.Map<any, any>;
        get spawnerTypes(): Internal.Set<Internal.MobCategory>;
        get entityTypes(): Internal.Set<Internal.EntityType<any>>;
        get spawners(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NBTSerializable {
        toNBT(): Internal.Tag
    }
    interface BaseStream <T, S> extends Internal.AutoCloseable {
        unordered(): S
        onClose(arg0: Internal.Runnable): S
        iterator(): Internal.Iterator<T>
        parallel(): S
        spliterator(): Internal.Spliterator<T>
        sequential(): S
        isParallel(): boolean
        close(): void
    }
    interface ModelState extends Internal.IForgeModelState {
        getPartTransformation(arg0: any): Internal.Transformation
    }
    abstract class InputStream implements Internal.Closeable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        read(arg0: number[], arg1: number, arg2: number): number
        read(arg0: number[]): number
        read(): number
        markSupported(): boolean
        notifyAll(): void
        available(): number
        static nullInputStream(): Internal.InputStream
        skip(arg0: number): number
        transferTo(arg0: Internal.OutputStream): number
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        readAllBytes(): number[]
        reset(): void
        readNBytes(arg0: number): number[]
        readNBytes(arg0: number[], arg1: number, arg2: number): number
        toString(): string
        close(): void
        skipNBytes(arg0: number): void
        mark(arg0: number): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ItemFoodEatenEventJS extends Internal.PlayerEventJS {
        cancel(): void
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        addGameStage(stage: string): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        getPlayer(): Internal.PlayerJS<any>
        notifyAll(): void
        getItem(): Internal.ItemStackJS
        getEntity(): Internal.EntityJS
        notify(): void
        getLevel(): Internal.LevelJS
        getMinecraftPlayer(): Internal.Player
        post(id: string, sub: string): boolean
        post(id: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hasGameStage(stage: string): boolean
        hashCode(): number
        equals(arg0: any): boolean
        removeGameStage(stage: string): void
        toString(): string
        canCancel(): boolean
        get server(): Internal.ServerJS;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ExplosionJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        strength(f: number): Internal.ExplosionJS
        hashCode(): number
        explode(): void
        exploder(entity: Internal.EntityJS): Internal.ExplosionJS
        damagesTerrain(b: boolean): Internal.ExplosionJS
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        causesFire(b: boolean): Internal.ExplosionJS
        destroysTerrain(b: boolean): Internal.ExplosionJS
        notify(): void
        explosionMode : Internal.Explosion$BlockInteraction;
        readonly x : number;
        readonly y : number;
        readonly z : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LivingEntityJS extends Internal.EntityJS {
        getLastAttackedEntity(): Internal.LivingEntityJS
        setY(y: number): void
        setX(x: number): void
        isOnScoreboardTeam(teamID: string): boolean
        isLiving(): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        getRevengeTarget(): Internal.LivingEntityJS
        getTags(): Internal.Set<string>
        getOffHandItem(): Internal.ItemStackJS
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        getHasCustomName(): boolean
        setInvisible(invisible: boolean): void
        runCommandSilent(command: string): number
        getIdleTime(): number
        getMovementSpeed(): number
        isBoss(): boolean
        getDistanceSq(x: number, y: number, z: number): number
        getDistanceSq(pos: BlockPos): number
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        getHealth(): number
        setLegsArmorItem(item: string): void
        setLegsArmorItem(item: Internal.ItemStackJS): void
        setLegsArmorItem(item: object): void
        getServer(): Internal.ServerJS
        setFeetArmorItem(item: string): void
        setFeetArmorItem(item: Internal.ItemStackJS): void
        setFeetArmorItem(item: object): void
        setMaxHealth(hp: number): void
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        setAbsorptionAmount(amount: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getDisplayName(): Internal.Text
        getType(): string
        setCustomNameAlwaysVisible(b: boolean): void
        setOffHandItem(item: string): void
        setOffHandItem(item: Internal.ItemStackJS): void
        setOffHandItem(item: object): void
        addMotion(x: number, y: number, z: number): void
        isInvisible(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaxHealth(): number
        isUnderWater(): boolean
        getHeldItem(hand: Hand): Internal.ItemStackJS
        getEyeHeight(): number
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS
        notify(): void
        getFallDistance(): number
        damageHeldItem(): void
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageHeldItem(hand: Hand, amount: number): void
        setOnFire(seconds: number): void
        removePassengers(): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        isUndead(): boolean
        isOnLadder(): boolean
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        getDistance(x: number, y: number, z: number): number
        getDistance(pos: BlockPos): number
        setStatusMessage(message: Internal.Component): void
        getLastDamageSource(): Internal.DamageSourceJS
        isSwimming(): boolean
        getReachDistance(): number
        getCustomName(): Internal.Text
        getStepHeight(): number
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        getLastAttackedEntityTime(): number
        isMonster(): boolean
        equals(arg0: any): boolean
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        toString(): string
        isOnGround(): boolean
        isSilent(): boolean
        isPassenger(e: Internal.EntityJS): boolean
        getClass(): Internal.Class<any>
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        getName(): Internal.Text
        setFallDistance(fallDistance: number): void
        getFeetArmorItem(): Internal.ItemStackJS
        setCustomName(name: Internal.Component): void
        setMainHandItem(item: string): void
        setMainHandItem(item: Internal.ItemStackJS): void
        setMainHandItem(item: object): void
        setStepHeight(stepHeight: number): void
        tell(message: Internal.Component): void
        getTeamId(): string
        isWaterCreature(): boolean
        setNoClip(noClip: boolean): void
        setPosition(x: number, y: number, z: number): void
        setPosition(block: Internal.BlockContainerJS): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        setRevengeTarget(target: Internal.LivingEntityJS): void
        setMovementSpeed(speed: number): void
        isChild(): boolean
        setEquipment(slot: EquipmentSlot, item: string): void
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void
        setEquipment(slot: EquipmentSlot, item: object): void
        getLegsArmorItem(): Internal.ItemStackJS
        setFullNBT(nbt: Internal.CompoundTag): void
        getAttackingEntity(): Internal.LivingEntityJS
        isHoldingInAnyHand(ingredient: any): boolean
        getNoClip(): boolean
        getFullNBT(): Internal.CompoundTag
        setYaw(yaw: number): void
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageEquipment(slot: EquipmentSlot, amount: number): void
        damageEquipment(slot: EquipmentSlot): void
        isAlive(): boolean
        getYaw(): number
        getHeadArmorItem(): Internal.ItemStackJS
        setNoGravity(noGravity: boolean): void
        setHeldItem(hand: Hand, item: string): void
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void
        setHeldItem(hand: Hand, item: object): void
        isPlayer(): boolean
        getRevengeTimer(): number
        getAbsorptionAmount(): number
        isCrouching(): boolean
        notifyAll(): void
        getId(): Internal.UUID
        getTicksExisted(): number
        setSilent(isSilent: boolean): void
        hashCode(): number
        getChestArmorItem(): Internal.ItemStackJS
        isFrame(): boolean
        heal(hp: number): void
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        setChestArmorItem(item: string): void
        setChestArmorItem(item: Internal.ItemStackJS): void
        setChestArmorItem(item: object): void
        getCustomNameAlwaysVisible(): boolean
        getMainHandItem(): Internal.ItemStackJS
        setHealth(hp: number): void
        setMotionZ(z: number): void
        setMotionY(y: number): void
        getBlock(): Internal.BlockContainerJS
        setMotionX(x: number): void
        isElytraFlying(): boolean
        isInWater(): boolean
        dismountRidingEntity(): void
        isSleeping(): boolean
        isAmbientCreature(): boolean
        getPotionEffects(): Internal.EntityPotionEffectsJS
        swingArm(hand: Hand): void
        rayTrace(): Internal.RayTraceResultJS
        rayTrace(distance: number): Internal.RayTraceResultJS
        isInvulnerable(): boolean
        setHeadArmorItem(item: string): void
        setHeadArmorItem(item: Internal.ItemStackJS): void
        setHeadArmorItem(item: object): void
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean
        getX(): number
        spawn(): void
        getY(): number
        getZ(): number
        isPeacefulCreature(): boolean
        getMotionZ(): number
        getMotionX(): number
        getNoGravity(): boolean
        getMotionY(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get feetArmorItem(): Internal.ItemStackJS;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get child(): boolean;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get elytraFlying(): boolean;
        get sleeping(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get headArmorItem(): Internal.ItemStackJS;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get health(): number;
        get inWater(): boolean;
        get chestArmorItem(): Internal.ItemStackJS;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get attackingEntity(): Internal.LivingEntityJS;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: string);
        set mainHandItem(item: Internal.ItemStackJS);
        set mainHandItem(item: object);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: string);
        set legsArmorItem(item: Internal.ItemStackJS);
        set legsArmorItem(item: object);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: string);
        set headArmorItem(item: Internal.ItemStackJS);
        set headArmorItem(item: object);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: string);
        set feetArmorItem(item: Internal.ItemStackJS);
        set feetArmorItem(item: object);
        set offHandItem(item: string);
        set offHandItem(item: Internal.ItemStackJS);
        set offHandItem(item: object);
        set chestArmorItem(item: string);
        set chestArmorItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: object);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Quest extends Internal.QuestObject implements Internal.Movable {
        getClass(): Internal.Class<any>
        hasDependency(object: Internal.QuestObject): boolean
        isProgressionIgnored(): boolean
        getMutableTitle(): Internal.MutableComponent
        getSubtitle(): Internal.Component
        moved(nx: number, ny: number, nc: number): void
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        isCompletedRaw(data: Internal.TeamData): boolean
        getTitle(): Internal.Component
        verifyDependencies(autofix: boolean): boolean
        getPath(): string
        clearCachedData(): void
        static parseCodeString(id: string): number
        editedFromGUI(): void
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        onCompleted(data: Internal.QuestProgressEventData<any>): void
        static getID(object: Internal.QuestObjectBase): number
        isVisible(data: Internal.TeamData): boolean
        onEditButtonClicked(gui: Internal.Runnable): void
        getChildren(): Internal.Collection<Internal.QuestObject>
        onStarted(data: Internal.QuestProgressEventData<any>): void
        getAltTitle(): Internal.Component
        deleteSelf(): void
        cacheProgress(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getShape(): string
        getWidth(): number
        getDescription(): Internal.Component[]
        notify(): void
        getChapter(): Internal.Chapter
        getHeight(): number
        getRelativeProgressFromChildren(data: Internal.TeamData): number
        static getRelativeProgressFromChildren(progressSum: number, count: number): number
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData, player: Internal.UUID): boolean
        getParentID(): number
        getProgressColor(data: Internal.TeamData): Internal.Color4I
        getProgressColor(data: Internal.TeamData, dim: boolean): Internal.Color4I
        move(to: Internal.Chapter, x: number, y: number): void
        refreshJEI(): number
        getDependants(): Internal.List<Internal.QuestObject>
        getQuestChapter(): Internal.Chapter
        removeInvalidDependencies(): void
        getQuestFile(): Internal.QuestFile
        getHideDependencyLines(): boolean
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        drawMoved(matrixStack: Internal.PoseStack): void
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getX(): number
        getY(): number
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        disableToast : boolean;
        chapter : Internal.Chapter;
        dependencyRequirement : Internal.DependencyRequirement;
        disableJEI : Internal.Tristate;
        minRequiredDependencies : number;
        icon : Internal.ItemStack;
        readonly description : Internal.List<string>;
        title : string;
        guidePage : string;
        hideDependencyLines : Internal.Tristate;
        id : number;
        readonly tasks : Internal.List<Internal.Task>;
        shape : string;
        optional : boolean;
        minWidth : number;
        readonly dependencies : Internal.List<Internal.QuestObject>;
        hideTextUntilComplete : Internal.Tristate;
        hide : Internal.Tristate;
        size : number;
        subtitle : string;
        x : number;
        invalid : boolean;
        y : number;
        static sendNotifications : Internal.Tristate;
        readonly rewards : Internal.List<Internal.Reward>;
        get progressionIgnored(): boolean;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get dependants(): Internal.List<Internal.QuestObject>;
        get width(): number;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get height(): number;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Matrix3f implements Internal.MatrixWrite {
        multiplyBackward(arg0: Internal.Matrix3f): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        flywheel$writeUnsafe(arg0: number): void
        toString(): string
        flywheel$write(arg0: Internal.VecBuffer): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GridAlignedBB implements Internal.ImmutableBox {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setMinY(arg0: number): Internal.GridAlignedBB
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        intersects(arg0: Internal.ImmutableBox): boolean
        setMinX(arg0: number): Internal.GridAlignedBB
        notifyAll(): void
        setMinZ(arg0: number): Internal.GridAlignedBB
        forEachContained(arg0: Internal.CoordinateConsumer): void
        nextPowerOf2(): void
        fixMinMax(): void
        notify(): void
        translate(arg0: number, arg1: number, arg2: number): void
        translate(arg0: Vec3i): void
        empty(): boolean
        setMin(arg0: Vec3i): Internal.GridAlignedBB
        setMin(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB
        mirrorAbout(arg0: (arg0: any) => boolean): void
        hashCode(): number
        static ofRadius(arg0: number): Internal.GridAlignedBB
        static from(arg0: BlockPos): Internal.GridAlignedBB
        static from(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB
        static from(arg0: number, arg1: number): Internal.GridAlignedBB
        static from(arg0: Internal.SectionPos): Internal.GridAlignedBB
        static from(arg0: Internal.AABB): Internal.GridAlignedBB
        copy(): Internal.GridAlignedBB
        intersectAssign(arg0: Internal.ImmutableBox): void
        setMax(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB
        setMax(arg0: Vec3i): Internal.GridAlignedBB
        hasPowerOf2Sides(): boolean
        grow(arg0: number): void
        grow(arg0: number, arg1: number, arg2: number): void
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB
        nextPowerOf2Centered(): void
        getMaxX(): number
        getMaxY(): number
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox
        static containingAll(arg0: Internal.Collection<BlockPos>): Internal.ImmutableBox
        getMaxZ(): number
        volume(): number
        sizeX(): number
        contains(arg0: Internal.ImmutableBox): boolean
        contains(arg0: number, arg1: number, arg2: number): boolean
        isContainedBy(arg0: Internal.GridAlignedBB): boolean
        unionAssign(arg0: Internal.AABB): void
        unionAssign(arg0: Internal.ImmutableBox): void
        setMaxZ(arg0: number): Internal.GridAlignedBB
        equals(arg0: any): boolean
        toAABB(): Internal.AABB
        toString(): string
        setMaxY(arg0: number): Internal.GridAlignedBB
        setMaxX(arg0: number): Internal.GridAlignedBB
        getMinZ(): number
        sizeY(): number
        getMinX(): number
        sizeZ(): number
        getMinY(): number
        sameAs(arg0: Internal.ImmutableBox): boolean
        sameAs(arg0: Internal.AABB): boolean
        assign(arg0: Internal.AABB): void
        assign(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB
        assign(arg0: Internal.ImmutableBox): void
        get minY(): number;
        get maxZ(): number;
        get minX(): number;
        get maxY(): number;
        get maxX(): number;
        get minZ(): number;
        get class(): Internal.Class<any>;
        set min(arg0: Vec3i);
        set minY(arg0: number);
        set maxZ(arg0: number);
        set max(arg0: Vec3i);
        set minX(arg0: number);
        set maxY(arg0: number);
        set maxX(arg0: number);
        set minZ(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptFileInfo {
        getPackMode(): string
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getProperty(s: string, def: string): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getPriority(): number
        toString(): string
        isIgnored(): boolean
        preload(source: Internal.ScriptSource): Internal.Throwable
        notify(): void
        readonly file : string;
        readonly location : string;
        readonly id : ResourceLocation;
        readonly pack : Internal.ScriptPackInfo;
        get ignored(): boolean;
        get packMode(): string;
        get priority(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Scoreboard {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SortedMap <K, V> extends Internal.Map<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        lastKey(): K
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        subMap(arg0: K, arg1: K): Internal.SortedMap<K, V>
        isEmpty(): boolean
        clear(): void
        comparator(): Internal.Comparator<K>
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        firstKey(): K
        equals(arg0: any): boolean
        headMap(arg0: K): Internal.SortedMap<K, V>
        putIfAbsent(arg0: K, arg1: V): V
        tailMap(arg0: K): Internal.SortedMap<K, V>
    }
    class ChatFormatting extends Internal.Enum<any> implements Internal.Color {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRgbKJS(): number
        static valueOf(arg0: string): Internal.ChatFormatting
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ChatFormatting[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChatFormatting): number
        getSerializeKJS(): string
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChatFormatting>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ChatFormatting>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        getHexKJS(): string
        createTextColorKJS(): Internal.TextColor
        getArgbKJS(): number
        toString(): string
        getFireworkColorKJS(): number
        specialEquals(o: any, shallow: boolean): boolean
        ordinal(): number
        static readonly ITALIC : Internal.ChatFormatting;
        static readonly GOLD : Internal.ChatFormatting;
        static readonly GRAY : Internal.ChatFormatting;
        static readonly AQUA : Internal.ChatFormatting;
        static readonly WHITE : Internal.ChatFormatting;
        static readonly BLUE : Internal.ChatFormatting;
        static readonly OBFUSCATED : Internal.ChatFormatting;
        static readonly DARK_AQUA : Internal.ChatFormatting;
        static readonly RESET : Internal.ChatFormatting;
        static readonly DARK_BLUE : Internal.ChatFormatting;
        static readonly GREEN : Internal.ChatFormatting;
        static readonly UNDERLINE : Internal.ChatFormatting;
        static readonly RED : Internal.ChatFormatting;
        static readonly DARK_PURPLE : Internal.ChatFormatting;
        static readonly STRIKETHROUGH : Internal.ChatFormatting;
        static readonly DARK_RED : Internal.ChatFormatting;
        static readonly LIGHT_PURPLE : Internal.ChatFormatting;
        static readonly BLACK : Internal.ChatFormatting;
        static readonly BOLD : Internal.ChatFormatting;
        static readonly DARK_GREEN : Internal.ChatFormatting;
        static readonly YELLOW : Internal.ChatFormatting;
        static readonly DARK_GRAY : Internal.ChatFormatting;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChatFormatting>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GlNumericType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.GlNumericType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.GlNumericType[]
        static byName(arg0: string): Internal.GlNumericType
        compareTo(arg0: any): number
        compareTo(arg0: Internal.GlNumericType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.GlNumericType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.GlNumericType>
        getGlEnum(): number
        hashCode(): number
        equals(arg0: any): boolean
        castAndBuffer(arg0: Internal.ByteBuffer, arg1: number): void
        name(): string
        toString(): string
        getTypeName(): string
        getByteWidth(): number
        ordinal(): number
        static readonly UBYTE : Internal.GlNumericType;
        static readonly FLOAT : Internal.GlNumericType;
        static readonly BYTE : Internal.GlNumericType;
        static readonly USHORT : Internal.GlNumericType;
        static readonly UINT : Internal.GlNumericType;
        static readonly INT : Internal.GlNumericType;
        static readonly SHORT : Internal.GlNumericType;
        get glEnum(): number;
        get byteWidth(): number;
        get typeName(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.GlNumericType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FieldNamingStrategy {
        translateName(arg0: Internal.Field): string
    }
    class BlockPathTypes extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.BlockPathTypes
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.BlockPathTypes[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.BlockPathTypes): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.BlockPathTypes>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.BlockPathTypes>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        getDanger(): Internal.BlockPathTypes
        static readonly DAMAGE_CACTUS : Internal.BlockPathTypes;
        static readonly LAVA : Internal.BlockPathTypes;
        static readonly LEAVES : Internal.BlockPathTypes;
        static readonly BLOCKED : Internal.BlockPathTypes;
        static readonly WALKABLE : Internal.BlockPathTypes;
        static readonly DANGER_CACTUS : Internal.BlockPathTypes;
        static readonly TRAPDOOR : Internal.BlockPathTypes;
        static readonly BREACH : Internal.BlockPathTypes;
        static readonly POWDER_SNOW : Internal.BlockPathTypes;
        static readonly DOOR_WOOD_CLOSED : Internal.BlockPathTypes;
        static readonly DANGER_FIRE : Internal.BlockPathTypes;
        static readonly DAMAGE_FIRE : Internal.BlockPathTypes;
        static readonly WATER : Internal.BlockPathTypes;
        static readonly WATER_BORDER : Internal.BlockPathTypes;
        static readonly WALKABLE_DOOR : Internal.BlockPathTypes;
        static readonly DOOR_IRON_CLOSED : Internal.BlockPathTypes;
        static readonly FENCE : Internal.BlockPathTypes;
        static readonly OPEN : Internal.BlockPathTypes;
        static readonly RAIL : Internal.BlockPathTypes;
        static readonly DAMAGE_OTHER : Internal.BlockPathTypes;
        static readonly DOOR_OPEN : Internal.BlockPathTypes;
        static readonly UNPASSABLE_RAIL : Internal.BlockPathTypes;
        static readonly COCOA : Internal.BlockPathTypes;
        static readonly DANGER_OTHER : Internal.BlockPathTypes;
        static readonly STICKY_HONEY : Internal.BlockPathTypes;
        get danger(): Internal.BlockPathTypes;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.BlockPathTypes>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClickType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ClickType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ClickType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ClickType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ClickType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly QUICK_MOVE : Internal.ClickType;
        static readonly SWAP : Internal.ClickType;
        static readonly PICKUP_ALL : Internal.ClickType;
        static readonly THROW : Internal.ClickType;
        static readonly QUICK_CRAFT : Internal.ClickType;
        static readonly PICKUP : Internal.ClickType;
        static readonly CLONE : Internal.ClickType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PermissionCollection implements Internal.Serializable {
        add(arg0: Internal.Permission): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        elementsAsStream(): Internal.Stream<Internal.Permission>
        isReadOnly(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        elements(): Internal.Enumeration<Internal.Permission>
        toString(): string
        implies(arg0: Internal.Permission): boolean
        notify(): void
        setReadOnly(): void
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Dynamic <T> extends Internal.DynamicLike<any> {
        createLong(arg0: number): Internal.Dynamic<T>
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>
        getClass(): Internal.Class<any>
        getElementGeneric(arg0: T): Internal.DataResult<T>
        getElementGeneric(arg0: T, arg1: T): T
        updateMapValues(arg0: (arg0: com.mojang.datafixers.util.Pair<Internal.Dynamic<any>, Internal.Dynamic<any>>) => com.mojang.datafixers.util.Pair<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: (arg0: K_) => Internal.Decoder<V_>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K_, V_>>>
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: Internal.Decoder<V_>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K_, V_>>>
        readMap<R_>(arg0: Internal.DataResult<R_>, arg1: Internal.Function3<R_, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R_>>): Internal.DataResult<R_>
        asListOpt<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<Internal.List<U_>>
        createShort(arg0: number): Internal.Dynamic<T>
        static convert<S_, T_>(arg0: Internal.DynamicOps<S_>, arg1: Internal.DynamicOps<T_>, arg2: S_): T_
        convert<R_>(arg0: Internal.DynamicOps<R_>): Internal.Dynamic<R_>
        decode<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<com.mojang.datafixers.util.Pair<A_, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        asList<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.List<U_>
        getMapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>
        cast<U_>(arg0: Internal.DynamicOps<U_>): U_
        readList<E_>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E_>): Internal.DataResult<Internal.List<E_>>
        readList<E_>(arg0: Internal.Decoder<E_>): Internal.DataResult<Internal.List<E_>>
        merge(arg0: Internal.Dynamic<any>, arg1: Internal.Dynamic<any>): Internal.OptionalDynamic<T>
        merge(arg0: Internal.Dynamic<any>): Internal.OptionalDynamic<T>
        asString(): Internal.DataResult<string>
        asString(arg0: string): string
        asByte(arg0: number): number
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>
        read<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<A_>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        createString(arg0: string): Internal.Dynamic<T>
        getGeneric(arg0: T): Internal.DataResult<T>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        asMapOpt<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<Internal.Map<K_, V_>>
        asStream(): Internal.Stream<Internal.Dynamic<T>>
        createByte(arg0: number): Internal.Dynamic<T>
        asLong(arg0: number): number
        asDouble(arg0: number): number
        asBoolean(arg0: boolean): boolean
        updateGeneric(arg0: T, arg1: (arg0: T) => T): Internal.Dynamic<T>
        createDouble(arg0: number): Internal.Dynamic<T>
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        asMap<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.Map<K_, V_>
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        notifyAll(): void
        update(arg0: string, arg1: (arg0: Internal.Dynamic<any>) => Internal.Dynamic<any>): Internal.Dynamic<T>
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>
        asIntStream(): Internal.IntStream
        asByteBuffer(): Internal.ByteBuffer
        asFloat(arg0: number): number
        asLongStream(): Internal.LongStream
        notify(): void
        createBoolean(arg0: boolean): Internal.Dynamic<T>
        remove(arg0: string): Internal.Dynamic<T>
        asInt(arg0: number): number
        into<V_>(arg0: (arg0: Internal.Dynamic<T>) => V_): V_
        emptyList(): Internal.Dynamic<T>
        asShort(arg0: number): number
        hashCode(): number
        get(arg0: string): Internal.OptionalDynamic<T>
        emptyMap(): Internal.Dynamic<T>
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>
        map(arg0: (arg0: T) => T): Internal.Dynamic<T>
        set(arg0: string, arg1: Internal.Dynamic<any>): Internal.Dynamic<T>
        asNumber(): Internal.DataResult<Internal.Number>
        asNumber(arg0: Internal.Number): Internal.Number
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>
        castTyped<U_>(arg0: Internal.DynamicOps<U_>): Internal.Dynamic<U_>
        createFloat(arg0: number): Internal.Dynamic<T>
        getValue(): T
        getOps(): Internal.DynamicOps<T>
        getElement(arg0: string): Internal.DataResult<T>
        getElement(arg0: string, arg1: T): T
        equals(arg0: any): boolean
        createInt(arg0: number): Internal.Dynamic<T>
        toString(): string
        get ops(): Internal.DynamicOps<T>;
        get mapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        get class(): Internal.Class<any>;
        get value(): T;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InputMethodHighlight {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getState(): number
        getStyle(): Internal.Map<Internal.TextAttribute, any>
        hashCode(): number
        getVariation(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isSelected(): boolean
        toString(): string
        notify(): void
        static readonly UNSELECTED_CONVERTED_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly SELECTED_CONVERTED_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly RAW_TEXT : 0;
        static readonly CONVERTED_TEXT : 1;
        static readonly UNSELECTED_RAW_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly SELECTED_RAW_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        get style(): Internal.Map<Internal.TextAttribute, any>;
        get state(): number;
        get class(): Internal.Class<any>;
        get variation(): number;
        get selected(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Table$Cell <R, C, V> {
        getValue(): V
        getColumnKey(): C
        hashCode(): number
        equals(arg0: any): boolean
        getRowKey(): R
    }
    abstract class SimpleJsonResourceReloadListener extends Internal.SimplePreparableReloadListener<any> implements Internal.JsonReloadListenerAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        getGson(): Internal.Gson
        get gson(): Internal.Gson;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractList <E> extends Internal.AbstractCollection<any> implements Internal.List<E> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): E
        remove(arg0: any): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        get(arg0: number): E
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelRegistryEvent extends net.minecraftforge.eventbus.api.Event implements Internal.IModBusEvent {
        setCanceled(arg0: boolean): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCanceled(): boolean
        setResult(arg0: Internal.Event$Result): void
        notifyAll(): void
        hasResult(): boolean
        notify(): void
        getListenerList(): Internal.ListenerList
        hashCode(): number
        equals(arg0: any): boolean
        getResult(): Internal.Event$Result
        toString(): string
        isCancelable(): boolean
        getPhase(): Internal.EventPriority
        setPhase(arg0: Internal.EventPriority): void
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ZoneOffset extends Internal.ZoneId implements Internal.TemporalAccessor, Internal.TemporalAdjuster, Internal.Comparable<Internal.ZoneOffset>, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        normalized(): Internal.ZoneId
        notifyAll(): void
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        getId(): string
        compareTo(arg0: Internal.ZoneOffset): number
        compareTo(arg0: any): number
        notify(): void
        static systemDefault(): Internal.ZoneId
        static getAvailableZoneIds(): Internal.Set<string>
        hashCode(): number
        static of(arg0: string): Internal.ZoneOffset
        static of(arg0: string): Internal.ZoneId
        static of(arg0: string, arg1: Internal.Map<string, string>): Internal.ZoneId
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.ZoneOffset
        static from(arg0: Internal.TemporalAccessor): Internal.ZoneId
        getRules(): Internal.ZoneRules
        getTotalSeconds(): number
        static ofHoursMinutes(arg0: number, arg1: number): Internal.ZoneOffset
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        isSupported(arg0: Internal.TemporalField): boolean
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset): Internal.ZoneId
        getLong(arg0: Internal.TemporalField): number
        static ofHours(arg0: number): Internal.ZoneOffset
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        toString(): string
        static ofHoursMinutesSeconds(arg0: number, arg1: number, arg2: number): Internal.ZoneOffset
        static ofTotalSeconds(arg0: number): Internal.ZoneOffset
        static readonly MIN : Internal.ZoneOffset;
        static readonly UTC : Internal.ZoneOffset;
        static readonly MAX : Internal.ZoneOffset;
        static readonly SHORT_IDS : Internal.Map<string, string>;
        get availableZoneIds(): Internal.Set<string>;
        get totalSeconds(): number;
        get rules(): Internal.ZoneRules;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectInput extends Internal.DataInput, Internal.AutoCloseable {
        read(arg0: number[], arg1: number, arg2: number): number
        read(arg0: number[]): number
        read(): number
        available(): number
        skip(arg0: number): number
        readLine(): string
        readChar(): string
        skipBytes(arg0: number): number
        readObject(): any
        readLong(): number
        readUTF(): string
        readShort(): number
        readDouble(): number
        readFully(arg0: number[], arg1: number, arg2: number): void
        readFully(arg0: number[]): void
        readFloat(): number
        readBoolean(): boolean
        readByte(): number
        readInt(): number
        readUnsignedByte(): number
        close(): void
        readUnsignedShort(): number
    }
    interface LevelSimulatedRW extends Internal.LevelSimulatedReader, Internal.LevelWriter {
    }
    class StackTraceElement implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMethodName(): string
        notifyAll(): void
        getModuleName(): string
        notify(): void
        getModuleVersion(): string
        getLineNumber(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getClassName(): string
        getClassLoaderName(): string
        getFileName(): string
        isNativeMethod(): boolean
        get fileName(): string;
        get moduleVersion(): string;
        get moduleName(): string;
        get nativeMethod(): boolean;
        get methodName(): string;
        get className(): string;
        get lineNumber(): number;
        get class(): Internal.Class<any>;
        get classLoaderName(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BotaniaRunicAltarRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        mana(t: number): Internal.BotaniaRunicAltarRecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Context$ClassShutterSetter {
        setClassShutter(arg0: Internal.ClassShutter): void
        getClassShutter(): Internal.ClassShutter
    }
    class LogicalSide extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isServer(): boolean
        static valueOf(arg0: string): Internal.LogicalSide
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.LogicalSide[]
        isClient(): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LogicalSide): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LogicalSide>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.LogicalSide>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SERVER : Internal.LogicalSide;
        static readonly CLIENT : Internal.LogicalSide;
        get server(): boolean;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LogicalSide>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessibleSelection {
        selectAllAccessibleSelection(): void
        getAccessibleSelectionCount(): number
        clearAccessibleSelection(): void
        removeAccessibleSelection(arg0: number): void
        isAccessibleChildSelected(arg0: number): boolean
        getAccessibleSelection(arg0: number): Internal.Accessible
        addAccessibleSelection(arg0: number): void
    }
    interface Rotate <Self> {
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: (arg0: any) => boolean): Self
        rotateZRadians(arg0: number): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        multiply(arg0: Internal.Quaternion): Self
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        rotateToFace(arg0: Internal.Direction): Self
        rotateZ(arg0: number): Self
    }
    class JsonPrimitive extends Internal.JsonElement {
        getAsFloat(): number
        getClass(): Internal.Class<any>
        getAsByte(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAsBigDecimal(): Internal.BigDecimal
        notifyAll(): void
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        notify(): void
        getAsInt(): number
        isJsonPrimitive(): boolean
        isBoolean(): boolean
        getAsLong(): number
        isJsonObject(): boolean
        hashCode(): number
        isNumber(): boolean
        isString(): boolean
        getAsBigInteger(): Internal.BigInteger
        getAsJsonObject(): Internal.JsonObject
        getAsJsonNull(): Internal.JsonNull
        isJsonNull(): boolean
        getAsDouble(): number
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonPrimitive
        getAsJsonArray(): Internal.JsonArray
        getAsJsonPrimitive(): Internal.JsonPrimitive
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        getAsShort(): number
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get string(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get number(): boolean;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get boolean(): boolean;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IFaction <T> {
        getName(): Internal.Component
        getChatColor(): Internal.TextColor
        isEntityOfFaction(arg0: Internal.PathfinderMob): boolean
        getColor(): number
        getID(): ResourceLocation
        getNamePlural(): Internal.Component
        getFactionEntityInterface(): Internal.Class<T>
        getVillageData(): Internal.IFactionVillage
        isHostileTowardsNeutral(): boolean
    }
    class Clipboard {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        notifyAll(): void
        addFlavorListener(arg0: Internal.FlavorListener): void
        isDataFlavorAvailable(arg0: Internal.DataFlavor): boolean
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        getAvailableDataFlavors(): Internal.DataFlavor[]
        getFlavorListeners(): Internal.FlavorListener[]
        getContents(arg0: any): Internal.Transferable
        toString(): string
        removeFlavorListener(arg0: Internal.FlavorListener): void
        setContents(arg0: Internal.Transferable, arg1: Internal.ClipboardOwner): void
        getData(arg0: Internal.DataFlavor): any
        get flavorListeners(): Internal.FlavorListener[];
        get availableDataFlavors(): Internal.DataFlavor[];
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NeutralMob {
    }
    interface ScatteringByteChannel extends Internal.ReadableByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        read(arg0: Internal.ByteBuffer[]): number
        read(arg0: Internal.ByteBuffer): number
        close(): void
    }
    class BlockEntityType <T> extends Internal.ForgeRegistryEntry<any> implements Internal.BlockEntityTypeExtension<any>, Internal.BETypeAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.BlockEntityType<any>
        setRegistryName(arg0: string): Internal.BlockEntityType<any>
        setRegistryName(arg0: string, arg1: string): Internal.BlockEntityType<any>
        getTags(): Internal.Set<ResourceLocation>
        notify(): void
        flywheel$setInstancingController(arg0: Internal.BlockEntityInstancingController<any>): void
        getValidBlocks(): Internal.Set<any>
        flywheel$getInstancingController(): Internal.BlockEntityInstancingController<any>
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.BlockEntityType<any>>
        toString(): string
        isIn(arg0: net.minecraft.tags.Tag<Internal.BlockEntityType<any>>): boolean
        readonly delegate : () => Internal.BlockEntityType<any>;
        get registryType(): Internal.Class<Internal.BlockEntityType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get validBlocks(): Internal.Set<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Predicate <T> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    interface Reference2ByteFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        getByte(arg0: any): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        removeByte(arg0: any): number
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IFluidHandler {
        getFluidInTank(arg0: number): Internal.FluidStack
        getTankCapacity(arg0: number): number
        fill(arg0: Internal.FluidStack, arg1: Internal.IFluidHandler$FluidAction): number
        getTanks(): number
        isFluidValid(arg0: number, arg1: Internal.FluidStack): boolean
        drain(arg0: Internal.FluidStack, arg1: Internal.IFluidHandler$FluidAction): Internal.FluidStack
        drain(arg0: number, arg1: Internal.IFluidHandler$FluidAction): Internal.FluidStack
    }
    class WritableRaster extends Internal.Raster {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setPixel(arg0: number, arg1: number, arg2: number[]): void
        setPixel(arg0: number, arg1: number, arg2: number[]): void
        setPixel(arg0: number, arg1: number, arg2: number[]): void
        createChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.Raster
        createWritableChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.WritableRaster
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): void
        notifyAll(): void
        getSampleFloat(arg0: number, arg1: number, arg2: number): number
        getNumDataElements(): number
        createTranslatedChild(arg0: number, arg1: number): Internal.Raster
        getNumBands(): number
        getWidth(): number
        static createWritableRaster(arg0: Internal.SampleModel, arg1: Internal.DataBuffer, arg2: Internal.Point): Internal.WritableRaster
        static createWritableRaster(arg0: Internal.SampleModel, arg1: Internal.Point): Internal.WritableRaster
        notify(): void
        getBounds(): Internal.Rectangle
        getSampleModel(): Internal.SampleModel
        getWritableParent(): Internal.WritableRaster
        getHeight(): number
        static createRaster(arg0: Internal.SampleModel, arg1: Internal.DataBuffer, arg2: Internal.Point): Internal.Raster
        getTransferType(): number
        hashCode(): number
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        setDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): void
        setDataElements(arg0: number, arg1: number, arg2: any): void
        setDataElements(arg0: number, arg1: number, arg2: Internal.Raster): void
        getSampleDouble(arg0: number, arg1: number, arg2: number): number
        getParent(): Internal.Raster
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): void
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): void
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): void
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createBandedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        getDataBuffer(): Internal.DataBuffer
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        createWritableTranslatedChild(arg0: number, arg1: number): Internal.WritableRaster
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        setRect(arg0: number, arg1: number, arg2: Internal.Raster): void
        setRect(arg0: Internal.Raster): void
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number[], arg4: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        createCompatibleWritableRaster(): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: Internal.Rectangle): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.WritableRaster
        getSampleModelTranslateX(): number
        getSampleModelTranslateY(): number
        equals(arg0: any): boolean
        getDataElements(arg0: number, arg1: number, arg2: any): any
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): any
        toString(): string
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createInterleavedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        getMinX(): number
        getSample(arg0: number, arg1: number, arg2: number): number
        getMinY(): number
        setSample(arg0: number, arg1: number, arg2: number, arg3: number): void
        setSample(arg0: number, arg1: number, arg2: number, arg3: number): void
        setSample(arg0: number, arg1: number, arg2: number, arg3: number): void
        get parent(): Internal.Raster;
        get dataBuffer(): Internal.DataBuffer;
        get writableParent(): Internal.WritableRaster;
        get numDataElements(): number;
        get numBands(): number;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get transferType(): number;
        get sampleModelTranslateX(): number;
        get class(): Internal.Class<any>;
        get sampleModel(): Internal.SampleModel;
        get height(): number;
        get sampleModelTranslateY(): number;
        set rect(arg0: Internal.Raster);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IEventListener {
        listenerName(): string
        invoke(arg0: net.minecraftforge.eventbus.api.Event): void
    }
    class DisplayData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class GuiComponent {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CharsetDecoder {
        averageCharsPerByte(): number
        getClass(): Internal.Class<any>
        charset(): Internal.Charset
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        maxCharsPerByte(): number
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder
        notifyAll(): void
        isCharsetDetected(): boolean
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer
        decode(arg0: Internal.ByteBuffer, arg1: Internal.CharBuffer, arg2: boolean): Internal.CoderResult
        notify(): void
        isAutoDetecting(): boolean
        unmappableCharacterAction(): Internal.CodingErrorAction
        detectedCharset(): Internal.Charset
        malformedInputAction(): Internal.CodingErrorAction
        flush(arg0: Internal.CharBuffer): Internal.CoderResult
        hashCode(): number
        equals(arg0: any): boolean
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder
        reset(): Internal.CharsetDecoder
        toString(): string
        replacement(): string
        replaceWith(arg0: string): Internal.CharsetDecoder
        get autoDetecting(): boolean;
        get charsetDetected(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MinecraftServer extends Internal.ReentrantBlockableEventLoop<any> implements Internal.CommandSource, Internal.AutoCloseable, Internal.MinecraftServerAccessor, Internal.MinecraftServerKJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getServerResourcesKJS(): Internal.ServerResources
        forgeGetWorldMap(): Internal.Map<Internal.ResourceKey<net.minecraft.world.level.Level>, Internal.ServerLevel>
        notifyAll(): void
        getTickTime(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>): number[]
        execute(arg0: Internal.Runnable): void
        asKJS(): any
        notify(): void
        getResources(): Internal.ServerResources
        hashCode(): number
        equals(arg0: any): boolean
        markWorldsDirty(): void
        getServerResources(): Internal.ServerResources
        handler$zdm000$reloadResources(arg0: Internal.Collection<any>, arg1: Internal.CallbackInfoReturnable<any>): void
        toString(): string
        close(): void
        get serverResources(): Internal.ServerResources;
        get resources(): Internal.ServerResources;
        get serverResourcesKJS(): Internal.ServerResources;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeRegistry <V> extends Internal.Iterable<V> {
        getKey(arg0: V): ResourceLocation
        getCodec(): Internal.Codec<V>
        getValues(): Internal.Collection<V>
        spliterator(): Internal.Spliterator<V>
        forEach(arg0: (arg0: V) => void): void
        containsKey(arg0: ResourceLocation): boolean
        registerAll(arg0: V[]): void
        getDefaultKey(): ResourceLocation
        isEmpty(): boolean
        getRegistryName(): ResourceLocation
        getKeys(): Internal.Set<ResourceLocation>
        getRegistrySuperType(): Internal.Class<V>
        getSlaveMap<T_>(arg0: ResourceLocation, arg1: Internal.Class<T_>): T_
        containsValue(arg0: V): boolean
        getResourceKey(arg0: V): Internal.Optional<Internal.ResourceKey<V>>
        getValue(arg0: ResourceLocation): V
        iterator(): Internal.Iterator<V>
        getEntries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>
        register(arg0: V): void
    }
    class ItemColors {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PageAttributes implements Internal.Cloneable {
        setOrientationRequestedToDefault(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrientationRequested(): Internal.PageAttributes$OrientationRequestedType
        set(arg0: Internal.PageAttributes): void
        getMedia(): Internal.PageAttributes$MediaType
        getOrigin(): Internal.PageAttributes$OriginType
        setOrigin(arg0: Internal.PageAttributes$OriginType): void
        notifyAll(): void
        setPrintQualityToDefault(): void
        getColor(): Internal.PageAttributes$ColorType
        setOrientationRequested(arg0: number): void
        setOrientationRequested(arg0: Internal.PageAttributes$OrientationRequestedType): void
        setPrinterResolutionToDefault(): void
        notify(): void
        setPrintQuality(arg0: number): void
        setPrintQuality(arg0: Internal.PageAttributes$PrintQualityType): void
        getPrintQuality(): Internal.PageAttributes$PrintQualityType
        setMediaToDefault(): void
        setColor(arg0: Internal.PageAttributes$ColorType): void
        getPrinterResolution(): number[]
        hashCode(): number
        equals(arg0: any): boolean
        clone(): any
        setMedia(arg0: Internal.PageAttributes$MediaType): void
        toString(): string
        setPrinterResolution(arg0: number[]): void
        setPrinterResolution(arg0: number): void
        get color(): Internal.PageAttributes$ColorType;
        get orientationRequested(): Internal.PageAttributes$OrientationRequestedType;
        get origin(): Internal.PageAttributes$OriginType;
        get printerResolution(): number[];
        get printQuality(): Internal.PageAttributes$PrintQualityType;
        get media(): Internal.PageAttributes$MediaType;
        get class(): Internal.Class<any>;
        set color(arg0: Internal.PageAttributes$ColorType);
        set orientationRequested(arg0: Internal.PageAttributes$OrientationRequestedType);
        set printerResolution(arg0: number[]);
        set origin(arg0: Internal.PageAttributes$OriginType);
        set printQuality(arg0: Internal.PageAttributes$PrintQualityType);
        set media(arg0: Internal.PageAttributes$MediaType);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractChronology implements Internal.Chronology {
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        range(arg0: Internal.ChronoField): Internal.ValueRange
        getId(): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Chronology): number
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(): Internal.ChronoLocalDate
        notify(): void
        eraOf(arg0: number): Internal.Era
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        hashCode(): number
        epochSecond(arg0: Internal.Era, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): number
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        getCalendarType(): string
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        resolveDate(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        isLeapYear(arg0: number): boolean
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        eras(): Internal.List<Internal.Era>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        toString(): string
        get calendarType(): string;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Menu extends Internal.MenuItem implements Internal.MenuContainer, Internal.Accessible {
        setName(arg0: string): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getLabel(): string
        notifyAll(): void
        getItemCount(): number
        getItem(arg0: number): Internal.MenuItem
        insert(arg0: string, arg1: number): void
        insert(arg0: Internal.MenuItem, arg1: number): void
        isTearOff(): boolean
        getShortcut(): Internal.MenuShortcut
        notify(): void
        remove(arg0: Internal.MenuComponent): void
        remove(arg0: number): void
        paramString(): string
        removeAll(): void
        removeActionListener(arg0: Internal.ActionListener): void
        addSeparator(): void
        hashCode(): number
        enable(): void
        enable(arg0: boolean): void
        setFont(arg0: java_.awt.Font): void
        setShortcut(arg0: Internal.MenuShortcut): void
        add(arg0: string): void
        add(arg0: Internal.MenuItem): Internal.MenuItem
        getParent(): Internal.MenuContainer
        dispatchEvent(arg0: Internal.AWTEvent): void
        deleteShortcut(): void
        addActionListener(arg0: Internal.ActionListener): void
        countItems(): number
        setActionCommand(arg0: string): void
        getAccessibleContext(): Internal.AccessibleContext
        postEvent(arg0: Internal.Event): boolean
        setEnabled(arg0: boolean): void
        addNotify(): void
        disable(): void
        equals(arg0: any): boolean
        isEnabled(): boolean
        getActionListeners(): Internal.ActionListener[]
        setLabel(arg0: string): void
        removeNotify(): void
        toString(): string
        getFont(): java_.awt.Font
        getActionCommand(): string
        insertSeparator(arg0: number): void
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get tearOff(): boolean;
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get itemCount(): number;
        get font(): java_.awt.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInstance implements Internal.Instance, Internal.LightListener {
        getClass(): Internal.Class<any>
        init(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        notifyAll(): void
        update(): void
        updateLight(): void
        notify(): void
        remove(): void
        getWorldPosition(): BlockPos
        getVolume(): Internal.ImmutableBox
        hashCode(): number
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        equals(arg0: any): boolean
        toString(): string
        shouldReset(): boolean
        status(): Internal.ListenerStatus
        readonly world : net.minecraft.world.level.Level;
        get volume(): Internal.ImmutableBox;
        get worldPosition(): BlockPos;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PageAttributes$MediaType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly ISO_B0 : Internal.PageAttributes$MediaType;
        static readonly ISO_B1 : Internal.PageAttributes$MediaType;
        static readonly ISO_B2 : Internal.PageAttributes$MediaType;
        static readonly NA_10X13_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B3 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_14_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B4 : Internal.PageAttributes$MediaType;
        static readonly ENV_INVITE : Internal.PageAttributes$MediaType;
        static readonly ISO_B5 : Internal.PageAttributes$MediaType;
        static readonly ISO_B6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C10 : Internal.PageAttributes$MediaType;
        static readonly ISO_B7 : Internal.PageAttributes$MediaType;
        static readonly INVITE : Internal.PageAttributes$MediaType;
        static readonly ISO_C8_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly A0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B9 : Internal.PageAttributes$MediaType;
        static readonly A1 : Internal.PageAttributes$MediaType;
        static readonly A2 : Internal.PageAttributes$MediaType;
        static readonly JIS_B7 : Internal.PageAttributes$MediaType;
        static readonly A3 : Internal.PageAttributes$MediaType;
        static readonly JIS_B8 : Internal.PageAttributes$MediaType;
        static readonly A4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C2_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly A5 : Internal.PageAttributes$MediaType;
        static readonly A6 : Internal.PageAttributes$MediaType;
        static readonly A7 : Internal.PageAttributes$MediaType;
        static readonly A8 : Internal.PageAttributes$MediaType;
        static readonly ISO_B8 : Internal.PageAttributes$MediaType;
        static readonly A9 : Internal.PageAttributes$MediaType;
        static readonly ISO_B9 : Internal.PageAttributes$MediaType;
        static readonly PERSONAL_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C1 : Internal.PageAttributes$MediaType;
        static readonly A10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C2 : Internal.PageAttributes$MediaType;
        static readonly ISO_C3 : Internal.PageAttributes$MediaType;
        static readonly ISO_C4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C5 : Internal.PageAttributes$MediaType;
        static readonly ISO_C6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C7 : Internal.PageAttributes$MediaType;
        static readonly ISO_C8 : Internal.PageAttributes$MediaType;
        static readonly JIS_B1 : Internal.PageAttributes$MediaType;
        static readonly NA_LETTER : Internal.PageAttributes$MediaType;
        static readonly ISO_2A0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B2 : Internal.PageAttributes$MediaType;
        static readonly ENV_6X9 : Internal.PageAttributes$MediaType;
        static readonly JIS_B0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B5 : Internal.PageAttributes$MediaType;
        static readonly JIS_B6 : Internal.PageAttributes$MediaType;
        static readonly JIS_B3 : Internal.PageAttributes$MediaType;
        static readonly B0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C0 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly B1 : Internal.PageAttributes$MediaType;
        static readonly B2 : Internal.PageAttributes$MediaType;
        static readonly B3 : Internal.PageAttributes$MediaType;
        static readonly B4 : Internal.PageAttributes$MediaType;
        static readonly B5 : Internal.PageAttributes$MediaType;
        static readonly B6 : Internal.PageAttributes$MediaType;
        static readonly B7 : Internal.PageAttributes$MediaType;
        static readonly B8 : Internal.PageAttributes$MediaType;
        static readonly B9 : Internal.PageAttributes$MediaType;
        static readonly ISO_C9 : Internal.PageAttributes$MediaType;
        static readonly NA_7X9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly MONARCH : Internal.PageAttributes$MediaType;
        static readonly ISO_C3_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_9X11 : Internal.PageAttributes$MediaType;
        static readonly ENV_ITALY : Internal.PageAttributes$MediaType;
        static readonly ENV_9X12 : Internal.PageAttributes$MediaType;
        static readonly ENV_10X15 : Internal.PageAttributes$MediaType;
        static readonly A : Internal.PageAttributes$MediaType;
        static readonly ENV_10X14 : Internal.PageAttributes$MediaType;
        static readonly B : Internal.PageAttributes$MediaType;
        static readonly ENV_10X13 : Internal.PageAttributes$MediaType;
        static readonly C : Internal.PageAttributes$MediaType;
        static readonly D : Internal.PageAttributes$MediaType;
        static readonly E : Internal.PageAttributes$MediaType;
        static readonly ISO_C9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C0 : Internal.PageAttributes$MediaType;
        static readonly C1 : Internal.PageAttributes$MediaType;
        static readonly C2 : Internal.PageAttributes$MediaType;
        static readonly C3 : Internal.PageAttributes$MediaType;
        static readonly ISO_DESIGNATED_LONG_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly PERSONAL : Internal.PageAttributes$MediaType;
        static readonly C4 : Internal.PageAttributes$MediaType;
        static readonly C5 : Internal.PageAttributes$MediaType;
        static readonly C6 : Internal.PageAttributes$MediaType;
        static readonly NA_10X14_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C7 : Internal.PageAttributes$MediaType;
        static readonly C8 : Internal.PageAttributes$MediaType;
        static readonly C9 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_10_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_A0 : Internal.PageAttributes$MediaType;
        static readonly ISO_A1 : Internal.PageAttributes$MediaType;
        static readonly ISO_A2 : Internal.PageAttributes$MediaType;
        static readonly ISO_A3 : Internal.PageAttributes$MediaType;
        static readonly ISO_A4 : Internal.PageAttributes$MediaType;
        static readonly ISO_A5 : Internal.PageAttributes$MediaType;
        static readonly ISO_A6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C1_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B5_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly NA_LEGAL : Internal.PageAttributes$MediaType;
        static readonly ISO_A7 : Internal.PageAttributes$MediaType;
        static readonly ISO_C6_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_A8 : Internal.PageAttributes$MediaType;
        static readonly ISO_A9 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_11_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly STATEMENT : Internal.PageAttributes$MediaType;
        static readonly LETTER : Internal.PageAttributes$MediaType;
        static readonly ISO_A10 : Internal.PageAttributes$MediaType;
        static readonly NA_9X11_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C5_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly QUARTO : Internal.PageAttributes$MediaType;
        static readonly ISO_DESIGNATED_LONG : Internal.PageAttributes$MediaType;
        static readonly NA_6X9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C4_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C10_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_4A0 : Internal.PageAttributes$MediaType;
        static readonly ITALY : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_12_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly INVOICE : Internal.PageAttributes$MediaType;
        static readonly ENV_9 : Internal.PageAttributes$MediaType;
        static readonly NA_9X12_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ITALY_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B4_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_PERSONAL : Internal.PageAttributes$MediaType;
        static readonly ISO_B10 : Internal.PageAttributes$MediaType;
        static readonly JIS_B10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C0_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly INVITE_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly NOTE : Internal.PageAttributes$MediaType;
        static readonly LEGAL : Internal.PageAttributes$MediaType;
        static readonly EXECUTIVE : Internal.PageAttributes$MediaType;
        static readonly ENV_MONARCH : Internal.PageAttributes$MediaType;
        static readonly ENV_11 : Internal.PageAttributes$MediaType;
        static readonly B10 : Internal.PageAttributes$MediaType;
        static readonly ENV_12 : Internal.PageAttributes$MediaType;
        static readonly ENV_10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C7_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_14 : Internal.PageAttributes$MediaType;
        static readonly MONARCH_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_7X9 : Internal.PageAttributes$MediaType;
        static readonly NA_10X15_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly TABLOID : Internal.PageAttributes$MediaType;
        static readonly LEDGER : Internal.PageAttributes$MediaType;
        static readonly FOLIO : Internal.PageAttributes$MediaType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ActionEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getID(): number
        notify(): void
        paramString(): string
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        getWhen(): number
        toString(): string
        getModifiers(): number
        getActionCommand(): string
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly ACTION_LAST : 1001;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly ACTION_FIRST : 1001;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly ACTION_PERFORMED : 1001;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        get actionCommand(): string;
        get iD(): number;
        get source(): any;
        get modifiers(): number;
        get class(): Internal.Class<any>;
        get when(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FastMap <Value> {
        getClass(): Internal.Class<any>
        getKey(keyIndex: number): Internal.FastMapKey<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        numProperties(): number
        notifyAll(): void
        isSingleState(): boolean
        notify(): void
        with<T>(oldIndex: number, prop: net.minecraft.world.level.block.state.properties.Property<T>, value: T): Value
        getValue<T>(stateIndex: number, property: net.minecraft.world.level.block.state.properties.Property<T>): T
        getValue(stateIndex: number, key: any): Internal.Comparable<any>
        getIndexOf(state: Internal.Map<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>>): number
        hashCode(): number
        getPropertySet(): Internal.ImmutableSet<net.minecraft.world.level.block.state.properties.Property<any>>
        equals(arg0: any): boolean
        withUnsafe<T>(globalTableIndex: number, property: net.minecraft.world.level.block.state.properties.Property<T>, newValue: any): Value
        toString(): string
        getEntry(propertyIndex: number, stateIndex: number): Internal.Map$Entry<net.minecraft.world.level.block.state.properties.Property<any>, Internal.Comparable<any>>
        get propertySet(): Internal.ImmutableSet<net.minecraft.world.level.block.state.properties.Property<any>>;
        get singleState(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IIngredientSerializer <T> {
        parse(arg0: Internal.JsonObject): T
        parse(arg0: Internal.FriendlyByteBuf): T
        write(arg0: Internal.FriendlyByteBuf, arg1: T): void
    }
    interface ContentHandlerFactory {
        createContentHandler(arg0: string): Internal.ContentHandler
    }
    class RecipeFunction extends Internal.BaseFunction implements Internal.WrappedJS {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable
        getAllIds(): any[]
        put(name: string, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        getArity(): number
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        hasPrototypeMap(): boolean
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getFunctionName(): string
        getExternalArrayLength(): any
        getAttributes(key: Internal.Symbol): number
        getAttributes(name: string): number
        getAttributes(index: number): number
        setImmunePrototypeProperty(value: any): void
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: any): any
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getClassName(): string
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        notifyAll(): void
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        createRecipe(args0: any[]): Internal.RecipeJS
        isExtensible(): boolean
        hashCode(): number
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        activatePrototypeMap(maxPrototypeId: number): void
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args0: any[]): Internal.RecipeJS
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        getLength(): number
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        readonly typeID : ResourceLocation;
        readonly type : Internal.RecipeTypeJS;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Marker extends Internal.Serializable {
        getParents(): Internal.Marker[]
        getName(): string
        setParents(markers: Internal.Marker[]): Internal.Marker
        hashCode(): number
        hasParents(): boolean
        equals(obj: any): boolean
        isInstanceOf(m: Internal.Marker): boolean
        isInstanceOf(name: string): boolean
        addParents(markers: Internal.Marker[]): Internal.Marker
        remove(marker: Internal.Marker): boolean
    }
    interface Codec <A> extends Internal.Encoder<A>, Internal.Decoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>
        flatComapMap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>
        dispatch<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        deprecated(arg0: number): Internal.Codec<A>
        simple(): Internal.Decoder$Simple<A>
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>
        dispatchMap<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T_>>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T_>>
        comapFlatMap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => A): Internal.Codec<S_>
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>
        comap<B_>(arg0: (arg0: B_) => A): Internal.Encoder<B_>
        fieldOf(arg0: string): Internal.MapCodec<A>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.Codec<S_>
        listOf(): Internal.Codec<Internal.List<A>>
        map<B_>(arg0: (arg0: A) => B_): Internal.Decoder<B_>
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): Internal.DataResult<T_>
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.Encoder<B_>
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<A>
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>
        terminal(): Internal.Decoder$Terminal<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>
        orElse(arg0: A): Internal.Codec<A>
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.Codec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.Decoder<B_>
        boxed(): Internal.Decoder$Boxed<A>
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.Codec<A>
        orElseGet(arg0: () => A): Internal.Codec<A>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>
        dispatchStable<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        stable(): Internal.Codec<A>
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>
    }
    class RoundingMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.RoundingMode
        static valueOf(arg0: number): Internal.RoundingMode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.RoundingMode[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.RoundingMode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RoundingMode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.RoundingMode>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DOWN : Internal.RoundingMode;
        static readonly FLOOR : Internal.RoundingMode;
        static readonly UNNECESSARY : Internal.RoundingMode;
        static readonly CEILING : Internal.RoundingMode;
        static readonly HALF_EVEN : Internal.RoundingMode;
        static readonly UP : Internal.RoundingMode;
        static readonly HALF_UP : Internal.RoundingMode;
        static readonly HALF_DOWN : Internal.RoundingMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RoundingMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LightListener {
        getVolume(): Internal.ImmutableBox
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        status(): Internal.ListenerStatus
    }
    class CommandSourceStack implements Internal.SharedSuggestionProvider, Internal.IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement
        getRecipeManager(): Internal.RecipeManager
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getUnsidedLevel(): net.minecraft.world.level.Level
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getScoreboard(): Internal.Scoreboard
        toString(): string
        notify(): void
        get unsidedLevel(): net.minecraft.world.level.Level;
        get recipeManager(): Internal.RecipeManager;
        get scoreboard(): Internal.Scoreboard;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BaseMapCodec <K, V> {
        encode<T>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        elementCodec(): Internal.Codec<V>
        keyCodec(): Internal.Codec<K>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<Internal.Map<K, V>>
    }
    class ImmutableMultimap$Builder <K, V> {
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableMultimap$Builder<K, V>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        build(): Internal.ImmutableMultimap<K, V>
        hashCode(): number
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableMultimap$Builder<K, V>
        notifyAll(): void
        equals(arg0: any): boolean
        putAll(arg0: K, arg1: V[]): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMultimap$Builder<K, V>
        toString(): string
        notify(): void
        put(arg0: K, arg1: V): Internal.ImmutableMultimap$Builder<K, V>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMultimap$Builder<K, V>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ItemEntity extends Internal.Entity implements Internal.AccessorItemEntity, Internal.ItemEntityAccess {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        isDynamicLightEnabled(): boolean
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        revive(): void
        dynamicLightTick(): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        setAge(arg0: number): void
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        notify(): void
        hashCode(): number
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        asKJS(): any
        getPickupDelay(): number
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        lifespan : number;
        get luminance(): number;
        get pickupDelay(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set remainingFireTicks(arg0: number);
        set age(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WrapFactory {
        getClass(): Internal.Class<any>
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, javaObject: any, staticType: Internal.Class<any>): Internal.Scriptable
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        wrapJavaClass(cx: Internal.Context, scope: Internal.Scriptable, javaClass: Internal.Class<any>): Internal.Scriptable
        setJavaPrimitiveWrap(value: boolean): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isJavaPrimitiveWrap(): boolean
        toString(): string
        wrapNewObject(cx: Internal.Context, scope: Internal.Scriptable, obj: any): Internal.Scriptable
        wrap(cx: Internal.Context, scope: Internal.Scriptable, obj: any, staticType: Internal.Class<any>): any
        notify(): void
        get javaPrimitiveWrap(): boolean;
        get class(): Internal.Class<any>;
        set javaPrimitiveWrap(value: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Window extends java_.awt.Container implements Internal.Accessible {
        getLocation(arg0: Internal.Point): Internal.Point
        getLocation(): Internal.Point
        requestFocusInWindow(): boolean
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause): boolean
        isOpaque(): boolean
        setModalExclusionType(arg0: Internal.Dialog$ModalExclusionType): void
        paint(arg0: Internal.Graphics): void
        removeWindowListener(arg0: Internal.WindowListener): void
        getInputMethodListeners(): Internal.InputMethodListener[]
        setLayout(arg0: Internal.LayoutManager): void
        mouseDown(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getOwner(): Internal.Window
        getInputMethodRequests(): Internal.InputMethodRequests
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        removeAll(): void
        getMinimumSize(): Internal.Dimension
        getAlignmentY(): number
        getWindowStateListeners(): Internal.WindowStateListener[]
        getAlignmentX(): number
        dispatchEvent(arg0: Internal.AWTEvent): void
        setFocusableWindowState(arg0: boolean): void
        getMostRecentFocusOwner(): java_.awt.Component
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void
        pack(): void
        postEvent(arg0: Internal.Event): boolean
        toBack(): void
        createBufferStrategy(arg0: number): void
        createBufferStrategy(arg0: number, arg1: Internal.BufferCapabilities): void
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point): boolean
        size(): Internal.Dimension
        getType(): Internal.Window$Type
        enableInputMethods(arg0: boolean): void
        mouseUp(arg0: Internal.Event, arg1: number, arg2: number): boolean
        removeContainerListener(arg0: Internal.ContainerListener): void
        addComponentListener(arg0: Internal.ComponentListener): void
        setName(arg0: string): void
        removeInputMethodListener(arg0: Internal.InputMethodListener): void
        removeHierarchyListener(arg0: Internal.HierarchyListener): void
        removeWindowFocusListener(arg0: Internal.WindowFocusListener): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getHeight(): number
        getIgnoreRepaint(): boolean
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior
        removeMouseWheelListener(arg0: Internal.MouseWheelListener): void
        applyComponentOrientation(arg0: Internal.ComponentOrientation): void
        isAlwaysOnTopSupported(): boolean
        validate(): void
        getParent(): java_.awt.Container
        isMinimumSizeSet(): boolean
        getWindowFocusListeners(): Internal.WindowFocusListener[]
        setComponentOrientation(arg0: Internal.ComponentOrientation): void
        setBounds(arg0: Internal.Rectangle): void
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void
        static getWindows(): Internal.Window[]
        isValidateRoot(): boolean
        addNotify(): void
        addInputMethodListener(arg0: Internal.InputMethodListener): void
        toString(): string
        getFocusCycleRootAncestor(): java_.awt.Container
        setFocusTraversalPolicyProvider(arg0: boolean): void
        addWindowFocusListener(arg0: Internal.WindowFocusListener): void
        getName(): string
        countComponents(): number
        isFocusTraversable(): boolean
        inside(arg0: number, arg1: number): boolean
        nextFocus(): void
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>
        getInputContext(): Internal.InputContext
        isCursorSet(): boolean
        getMouseWheelListeners(): Internal.MouseWheelListener[]
        getComponents(): java_.awt.Component[]
        removeMouseMotionListener(arg0: Internal.MouseMotionListener): void
        doLayout(): void
        isLocationByPlatform(): boolean
        add(arg0: java_.awt.Component, arg1: number): java_.awt.Component
        add(arg0: string, arg1: java_.awt.Component): java_.awt.Component
        add(arg0: java_.awt.Component, arg1: any): void
        add(arg0: java_.awt.Component, arg1: any, arg2: number): void
        add(arg0: java_.awt.Component): java_.awt.Component
        add(arg0: Internal.PopupMenu): void
        setVisible(arg0: boolean): void
        removeKeyListener(arg0: Internal.KeyListener): void
        setFocusCycleRoot(arg0: boolean): void
        isVisible(): boolean
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        setDropTarget(arg0: Internal.DropTarget): void
        list(arg0: Internal.PrintStream, arg1: number): void
        list(arg0: Internal.PrintWriter, arg1: number): void
        list(arg0: Internal.PrintStream): void
        list(): void
        list(arg0: Internal.PrintWriter): void
        isFocused(): boolean
        revalidate(): void
        removeWindowStateListener(arg0: Internal.WindowStateListener): void
        removeNotify(): void
        getWarningString(): string
        static getOwnerlessWindows(): Internal.Window[]
        gotFocus(arg0: Internal.Event, arg1: any): boolean
        handleEvent(arg0: Internal.Event): boolean
        notifyAll(): void
        isForegroundSet(): boolean
        show(): void
        show(arg0: boolean): void
        update(arg0: Internal.Graphics): void
        getShape(): Internal.Shape
        isFocusTraversalPolicySet(): boolean
        setMaximumSize(arg0: Internal.Dimension): void
        remove(arg0: number): void
        remove(arg0: java_.awt.Component): void
        remove(arg0: Internal.MenuComponent): void
        addMouseWheelListener(arg0: Internal.MouseWheelListener): void
        imageUpdate(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        checkImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): number
        checkImage(arg0: Internal.Image, arg1: Internal.ImageObserver): number
        getLayout(): Internal.LayoutManager
        addKeyListener(arg0: Internal.KeyListener): void
        getContainerListeners(): Internal.ContainerListener[]
        hashCode(): number
        getComponentListeners(): Internal.ComponentListener[]
        isMaximumSizeSet(): boolean
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        getWindowListeners(): Internal.WindowListener[]
        getCursor(): Internal.Cursor
        createImage(arg0: number, arg1: number): Internal.Image
        createImage(arg0: Internal.ImageProducer): Internal.Image
        mouseMove(arg0: Internal.Event, arg1: number, arg2: number): boolean
        areFocusTraversalKeysSet(arg0: number): boolean
        getKeyListeners(): Internal.KeyListener[]
        setType(arg0: Internal.Window$Type): void
        layout(): void
        getBaseline(arg0: number, arg1: number): number
        print(arg0: Internal.Graphics): void
        paintComponents(arg0: Internal.Graphics): void
        getFocusListeners(): Internal.FocusListener[]
        resize(arg0: number, arg1: number): void
        resize(arg0: Internal.Dimension): void
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities): Internal.VolatileImage
        isAutoRequestFocus(): boolean
        location(): Internal.Point
        lostFocus(arg0: Internal.Event, arg1: any): boolean
        getDropTarget(): Internal.DropTarget
        keyDown(arg0: Internal.Event, arg1: number): boolean
        getLocale(): Internal.Locale
        setOpacity(arg0: number): void
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[]
        getBounds(arg0: Internal.Rectangle): Internal.Rectangle
        getBounds(): Internal.Rectangle
        setPreferredSize(arg0: Internal.Dimension): void
        enable(): void
        enable(arg0: boolean): void
        getMousePosition(arg0: boolean): Internal.Point
        getMousePosition(): Internal.Point
        action(arg0: Internal.Event, arg1: any): boolean
        setIconImages(arg0: Internal.List<Internal.Image>): void
        addContainerListener(arg0: Internal.ContainerListener): void
        setComponentZOrder(arg0: java_.awt.Component, arg1: number): void
        firePropertyChange(arg0: string, arg1: string, arg2: string): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        addMouseMotionListener(arg0: Internal.MouseMotionListener): void
        getComponentOrientation(): Internal.ComponentOrientation
        setFocusable(arg0: boolean): void
        getTreeLock(): any
        isBackgroundSet(): boolean
        addHierarchyListener(arg0: Internal.HierarchyListener): void
        findComponentAt(arg0: number, arg1: number): java_.awt.Component
        findComponentAt(arg0: Internal.Point): java_.awt.Component
        setLocationByPlatform(arg0: boolean): void
        setEnabled(arg0: boolean): void
        isLightweight(): boolean
        isEnabled(): boolean
        minimumSize(): Internal.Dimension
        bounds(): Internal.Rectangle
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void
        repaint(): void
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void
        repaint(arg0: number): void
        getMouseMotionListeners(): Internal.MouseMotionListener[]
        setMinimumSize(arg0: Internal.Dimension): void
        getModalExclusionType(): Internal.Dialog$ModalExclusionType
        transferFocus(): void
        printComponents(arg0: Internal.Graphics): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaximumSize(): Internal.Dimension
        getLocationOnScreen(): Internal.Point
        keyUp(arg0: Internal.Event, arg1: number): boolean
        getWidth(): number
        notify(): void
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy): void
        addWindowListener(arg0: Internal.WindowListener): void
        paintAll(arg0: Internal.Graphics): void
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set<Internal.AWTKeyStroke>): void
        hasFocus(): boolean
        isPreferredSizeSet(): boolean
        addWindowStateListener(arg0: Internal.WindowStateListener): void
        getIconImages(): Internal.List<Internal.Image>
        getFocusableWindowState(): boolean
        isDoubleBuffered(): boolean
        getPropertyChangeListeners(): Internal.PropertyChangeListener[]
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[]
        getColorModel(): Internal.ColorModel
        isValid(): boolean
        getInsets(): Internal.Insets
        getFocusTraversalKeysEnabled(): boolean
        hide(): void
        getPreferredSize(): Internal.Dimension
        disable(): void
        equals(arg0: any): boolean
        prepareImage(arg0: Internal.Image, arg1: Internal.ImageObserver): boolean
        prepareImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        isFocusableWindow(): boolean
        isFocusable(): boolean
        setLocationRelativeTo(arg0: java_.awt.Component): void
        getClass(): Internal.Class<any>
        insets(): Internal.Insets
        setIconImage(arg0: Internal.Image): void
        setMixingCutoutShape(arg0: Internal.Shape): void
        isActive(): boolean
        mouseExit(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getHierarchyListeners(): Internal.HierarchyListener[]
        getOpacity(): number
        isShowing(): boolean
        mouseEnter(arg0: Internal.Event, arg1: number, arg2: number): boolean
        mouseDrag(arg0: Internal.Event, arg1: number, arg2: number): boolean
        preferredSize(): Internal.Dimension
        getMouseListeners(): Internal.MouseListener[]
        setFont(arg0: java_.awt.Font): void
        setAutoRequestFocus(arg0: boolean): void
        toFront(): void
        deliverEvent(arg0: Internal.Event): void
        getForeground(): java_.awt.Color
        getComponentCount(): number
        isAncestorOf(arg0: java_.awt.Component): boolean
        getFont(): java_.awt.Font
        setCursor(arg0: Internal.Cursor): void
        dispose(): void
        getGraphicsConfiguration(): Internal.GraphicsConfiguration
        isDisplayable(): boolean
        getComponent(arg0: number): java_.awt.Component
        setLocale(arg0: Internal.Locale): void
        removeComponentListener(arg0: Internal.ComponentListener): void
        requestFocus(arg0: Internal.FocusEvent$Cause): void
        requestFocus(): void
        locate(arg0: number, arg1: number): java_.awt.Component
        addFocusListener(arg0: Internal.FocusListener): void
        getComponentAt(arg0: Internal.Point): java_.awt.Component
        getComponentAt(arg0: number, arg1: number): java_.awt.Component
        isAlwaysOnTop(): boolean
        isFocusCycleRoot(): boolean
        isFocusCycleRoot(arg0: java_.awt.Container): boolean
        setFocusTraversalKeysEnabled(arg0: boolean): void
        getComponentZOrder(arg0: java_.awt.Component): number
        setBackground(arg0: java_.awt.Color): void
        printAll(arg0: Internal.Graphics): void
        getToolkit(): Internal.Toolkit
        transferFocusUpCycle(): void
        isFontSet(): boolean
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        isFocusTraversalPolicyProvider(): boolean
        setLocation(arg0: number, arg1: number): void
        setLocation(arg0: Internal.Point): void
        getGraphics(): Internal.Graphics
        removeFocusListener(arg0: Internal.FocusListener): void
        setIgnoreRepaint(arg0: boolean): void
        transferFocusBackward(): void
        getOwnedWindows(): Internal.Window[]
        move(arg0: number, arg1: number): void
        transferFocusDownCycle(): void
        applyResourceBundle(arg0: Internal.ResourceBundle): void
        applyResourceBundle(arg0: string): void
        setForeground(arg0: java_.awt.Color): void
        invalidate(): void
        getBufferStrategy(): Internal.BufferStrategy
        getAccessibleContext(): Internal.AccessibleContext
        setShape(arg0: Internal.Shape): void
        isFocusOwner(): boolean
        getSize(): Internal.Dimension
        getSize(arg0: Internal.Dimension): Internal.Dimension
        getX(): number
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        getY(): number
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy
        setAlwaysOnTop(arg0: boolean): void
        getFocusOwner(): java_.awt.Component
        removeMouseListener(arg0: Internal.MouseListener): void
        getBackground(): java_.awt.Color
        addMouseListener(arg0: Internal.MouseListener): void
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): java_.awt.Container;
        get warningString(): string;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get modalExclusionType(): Internal.Dialog$ModalExclusionType;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get windowFocusListeners(): Internal.WindowFocusListener[];
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get type(): Internal.Window$Type;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get ownedWindows(): Internal.Window[];
        get visible(): boolean;
        get shape(): Internal.Shape;
        get displayable(): boolean;
        get active(): boolean;
        get maximumSizeSet(): boolean;
        get autoRequestFocus(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): java_.awt.Component;
        get componentCount(): number;
        get iconImages(): Internal.List<Internal.Image>;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): java_.awt.Container;
        get focusCycleRoot(): boolean;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get focused(): boolean;
        get focusableWindow(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get containerListeners(): Internal.ContainerListener[];
        get alwaysOnTopSupported(): boolean;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get mostRecentFocusOwner(): java_.awt.Component;
        get componentOrientation(): Internal.ComponentOrientation;
        get alwaysOnTop(): boolean;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get ownerlessWindows(): Internal.Window[];
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get focusableWindowState(): boolean;
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get locationByPlatform(): boolean;
        get colorModel(): Internal.ColorModel;
        get windowStateListeners(): Internal.WindowStateListener[];
        get class(): Internal.Class<any>;
        get bufferStrategy(): Internal.BufferStrategy;
        get keyListeners(): Internal.KeyListener[];
        get owner(): Internal.Window;
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get validateRoot(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get windows(): Internal.Window[];
        get windowListeners(): Internal.WindowListener[];
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get opacity(): number;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): java_.awt.Font;
        set cursor(arg0: Internal.Cursor);
        set iconImage(arg0: Internal.Image);
        set locationRelativeTo(arg0: java_.awt.Component);
        set alwaysOnTop(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation);
        set dropTarget(arg0: Internal.DropTarget);
        set modalExclusionType(arg0: Internal.Dialog$ModalExclusionType);
        set foreground(arg0: java_.awt.Color);
        set locale(arg0: Internal.Locale);
        set type(arg0: Internal.Window$Type);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusableWindowState(arg0: boolean);
        set locationByPlatform(arg0: boolean);
        set visible(arg0: boolean);
        set shape(arg0: Internal.Shape);
        set autoRequestFocus(arg0: boolean);
        set focusable(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy);
        set iconImages(arg0: Internal.List<Internal.Image>);
        set background(arg0: java_.awt.Color);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension);
        set opacity(arg0: number);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AttachedData extends Internal.HashMap<any, any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: any): any
        notifyAll(): void
        computeIfAbsent(arg0: string, arg1: (arg0: string) => any): any
        values(): Internal.Collection<any>
        replace(arg0: string, arg1: any, arg2: any): boolean
        replace(arg0: string, arg1: any): any
        replaceAll(arg0: (arg0: string, arg1: any) => any): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: string, arg1: any): any
        remove(arg0: any, arg1: any): boolean
        remove(arg0: any): any
        compute(arg0: string, arg1: (arg0: string, arg1: any) => any): any
        hashCode(): number
        putAll(arg0: Internal.Map<string, any>): void
        merge(arg0: string, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        get(arg0: any): any
        keySet(): Internal.Set<string>
        getParent(): any
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: string, arg1: any) => void): void
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: string, arg1: (arg0: string, arg1: any) => any): any
        size(): number
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        putIfAbsent(arg0: string, arg1: any): any
        get parent(): any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Lifecycle {
        add(arg0: Internal.Lifecycle): Internal.Lifecycle
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        static stable(): Internal.Lifecycle
        notifyAll(): void
        equals(arg0: any): boolean
        static deprecated(arg0: number): Internal.Lifecycle
        toString(): string
        static experimental(): Internal.Lifecycle
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleEngineAccessor {
        create$getProviders(): Internal.Map<ResourceLocation, Internal.ParticleProvider<any>>
    }
    abstract class ConfigFromString <T> extends Internal.ConfigValue<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        notifyAll(): void
        isEqual(v1: Internal.ConfigValue<Internal.ConfigValue<T>>, v2: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Component
        getPath(): string
        copy(value: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.ConfigValue<Internal.ConfigValue<T>>, c: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, def: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getColor(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(arg0: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, arg1: string): boolean
        getIcon(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void;
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TemporalUnit {
        isDurationEstimated(): boolean
        getDuration(): Internal.Duration
        isTimeBased(): boolean
        addTo<R>(arg0: R, arg1: number): R
        toString(): string
        isDateBased(): boolean
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number
        isSupportedBy(arg0: Internal.Temporal): boolean
    }
    class CallbackInfo implements Internal.Cancellable {
        cancel(): void
        getClass(): Internal.Class<any>
        static getCallInfoClassName(arg0: org.objectweb.asm.Type): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        isCancellable(): boolean
        getId(): string
        toString(): string
        notify(): void
        get cancelled(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get cancellable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class UnmodifiableIterator <E> implements Internal.Iterator<E> {
        next(): E
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        hasNext(): boolean
        toString(): string
        forEachRemaining(arg0: (arg0: E) => void): void
        notify(): void
        remove(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityDimensions {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ByteBufAllocator {
        directBuffer(arg0: number, arg1: number): Internal.ByteBuf
        directBuffer(arg0: number): Internal.ByteBuf
        directBuffer(): Internal.ByteBuf
        isDirectBufferPooled(): boolean
        calculateNewCapacity(arg0: number, arg1: number): number
        compositeDirectBuffer(arg0: number): Internal.CompositeByteBuf
        compositeDirectBuffer(): Internal.CompositeByteBuf
        ioBuffer(arg0: number): Internal.ByteBuf
        ioBuffer(arg0: number, arg1: number): Internal.ByteBuf
        ioBuffer(): Internal.ByteBuf
        compositeBuffer(): Internal.CompositeByteBuf
        compositeBuffer(arg0: number): Internal.CompositeByteBuf
        compositeHeapBuffer(arg0: number): Internal.CompositeByteBuf
        compositeHeapBuffer(): Internal.CompositeByteBuf
        buffer(): Internal.ByteBuf
        buffer(arg0: number, arg1: number): Internal.ByteBuf
        buffer(arg0: number): Internal.ByteBuf
        heapBuffer(arg0: number, arg1: number): Internal.ByteBuf
        heapBuffer(arg0: number): Internal.ByteBuf
        heapBuffer(): Internal.ByteBuf
    }
    abstract class GraphicsDevice {
        getClass(): Internal.Class<any>
        getConfigurations(): Internal.GraphicsConfiguration[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isFullScreenSupported(): boolean
        setDisplayMode(arg0: Internal.DisplayMode): void
        notifyAll(): void
        setFullScreenWindow(arg0: Internal.Window): void
        getFullScreenWindow(): Internal.Window
        getAvailableAcceleratedMemory(): number
        getDefaultConfiguration(): Internal.GraphicsConfiguration
        notify(): void
        isDisplayChangeSupported(): boolean
        getDisplayMode(): Internal.DisplayMode
        getIDstring(): string
        getType(): number
        hashCode(): number
        getBestConfiguration(arg0: Internal.GraphicsConfigTemplate): Internal.GraphicsConfiguration
        equals(arg0: any): boolean
        isWindowTranslucencySupported(arg0: Internal.GraphicsDevice$WindowTranslucency): boolean
        toString(): string
        getDisplayModes(): Internal.DisplayMode[]
        static readonly TYPE_IMAGE_BUFFER : 2;
        static readonly TYPE_RASTER_SCREEN : 0;
        static readonly TYPE_PRINTER : 1;
        get fullScreenSupported(): boolean;
        get availableAcceleratedMemory(): number;
        get iDstring(): string;
        get configurations(): Internal.GraphicsConfiguration[];
        get displayChangeSupported(): boolean;
        get displayModes(): Internal.DisplayMode[];
        get fullScreenWindow(): Internal.Window;
        get type(): number;
        get class(): Internal.Class<any>;
        get displayMode(): Internal.DisplayMode;
        get defaultConfiguration(): Internal.GraphicsConfiguration;
        set fullScreenWindow(arg0: Internal.Window);
        set displayMode(arg0: Internal.DisplayMode);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Attribute <T> {
        set(arg0: T): void
        compareAndSet(arg0: T, arg1: T): boolean
        get(): T
        setIfAbsent(arg0: T): T
        getAndSet(arg0: T): T
        key(): Internal.AttributeKey<T>
        remove(): void
        getAndRemove(): T
    }
    class VertexFormat {
        getClass(): Internal.Class<any>
        hasColor(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasPosition(): boolean
        hashCode(): number
        hasNormal(): boolean
        notifyAll(): void
        getOffset(arg0: number): number
        equals(arg0: any): boolean
        toString(): string
        getElementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>
        hasUV(arg0: number): boolean
        notify(): void
        get elementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class MobEffect extends Internal.ForgeRegistryEntry<any> implements Internal.IForgeMobEffect, Internal.AccessorMobEffect {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.MobEffect
        setRegistryName(arg0: string): Internal.MobEffect
        setRegistryName(arg0: string, arg1: string): Internal.MobEffect
        is(arg0: net.minecraft.tags.Tag<Internal.MobEffect>): boolean
        getTags(): Internal.Set<ResourceLocation>
        getSortOrder(arg0: Internal.MobEffectInstance): number
        notify(): void
        getType(): Internal.MobEffectCategory
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.MobEffect>
        toString(): string
        initializeClient(arg0: (arg0: Internal.EffectRenderer) => void): void
        getCurativeItems(): Internal.List<Internal.ItemStack>
        getEffectRendererInternal(): any
        readonly delegate : () => Internal.MobEffect;
        get registryType(): Internal.Class<Internal.MobEffect>;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effectRendererInternal(): any;
        get registryName(): ResourceLocation;
        get type(): Internal.MobEffectCategory;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FTBQuestsKubeJSTeamData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRelativeProgress(id: any): number
        notifyAll(): void
        getTaskProgress(id: any): number
        isStarted(id: any): boolean
        addProgress(id: any, progress: number): boolean
        getFile(): Internal.QuestFile
        getLocked(): boolean
        notify(): void
        setLocked(v: boolean): void
        changeProgress(id: any, consumer: (arg0: Internal.ProgressChange) => void): void
        getOnlineMembers(): Internal.EntityArrayList
        hashCode(): number
        equals(arg0: any): boolean
        canStartQuest(id: any): boolean
        reset(id: any): void
        toString(): string
        complete(id: any): void
        getData(): Internal.TeamData
        isCompleted(id: any): boolean
        get file(): Internal.QuestFile;
        get onlineMembers(): Internal.EntityArrayList;
        get data(): Internal.TeamData;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        set locked(v: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Callable {
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any
    }
    interface CustomProperty {
        get(): any
    }
    class WidgetType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.WidgetType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.WidgetType[]
        static mouseOver(mouseOver: boolean): Internal.WidgetType
        compareTo(arg0: any): number
        compareTo(arg0: Internal.WidgetType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.WidgetType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.WidgetType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DISABLED : Internal.WidgetType;
        static readonly MOUSE_OVER : Internal.WidgetType;
        static readonly NORMAL : Internal.WidgetType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.WidgetType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClickAction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ClickAction
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ClickAction[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ClickAction): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickAction>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ClickAction>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SECONDARY : Internal.ClickAction;
        static readonly PRIMARY : Internal.ClickAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Tristate extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static read(buffer: Internal.FriendlyByteBuf): Internal.Tristate
        static read(nbt: Internal.CompoundTag, key: string): Internal.Tristate
        static valueOf(name: string): Internal.Tristate
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Tristate[]
        isFalse(): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Tristate): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Tristate>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Tristate>
        isTrue(): boolean
        isDefault(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        get(def: boolean): boolean
        name(): string
        toString(): string
        getOpposite(): Internal.Tristate
        write(nbt: Internal.CompoundTag, key: string): void
        write(buffer: Internal.FriendlyByteBuf): void
        ordinal(): number
        readonly result : Internal.InteractionResult;
        readonly color : Internal.Color4I;
        static readonly NAME_MAP : Internal.NameMap<Internal.Tristate>;
        readonly displayName : string;
        readonly icon : Internal.Icon;
        static readonly TRUE : Internal.Tristate;
        static readonly FALSE : Internal.Tristate;
        static readonly VALUES : Internal.Tristate[];
        static readonly DEFAULT : Internal.Tristate;
        get default(): boolean;
        get false(): boolean;
        get true(): boolean;
        get opposite(): Internal.Tristate;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Tristate>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2ByteFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class LunarTextComponents$Notification {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getNotificationType(): Internal.LunarTextComponents$NotificationType
        notify(): void
        getCustomTranslationTextComponent(): Internal.CustomTranslationTextComponent
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents$Notification>;
        static readonly DEFAULT : Internal.LunarTextComponents$Notification;
        get notificationType(): Internal.LunarTextComponents$NotificationType;
        get class(): Internal.Class<any>;
        get customTranslationTextComponent(): Internal.CustomTranslationTextComponent;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableMap <K, V> implements Internal.Map<K, V>, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        static ofEntries<K_, V_>(arg0: Internal.Map$Entry<K_, V_>[]): Internal.ImmutableMap<K_, V_>
        notifyAll(): void
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<any>
        values(): Internal.ImmutableCollection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        static toImmutableMap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>
        static toImmutableMap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_, arg2: (arg0: any, arg1: any) => any): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_, arg18: K_, arg19: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(): Internal.ImmutableMap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_): Internal.ImmutableMap<K_, V_>
        get(arg0: any): V
        static builder<K_, V_>(): Internal.ImmutableMap$Builder<K_, V_>
        keySet(): Internal.ImmutableSet<K>
        keySet(): Internal.Set<any>
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>
        forEach(arg0: (arg0: K, arg1: V) => void): void
        containsKey(arg0: any): boolean
        isEmpty(): boolean
        clear(): void
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMap<K_, V_>
        static copyOf<K_, V_>(arg0: Internal.Map<K_, V_>): Internal.ImmutableMap<K_, V_>
        static builderWithExpectedSize<K_, V_>(arg0: number): Internal.ImmutableMap$Builder<K_, V_>
        asMultimap(): Internal.ImmutableSetMultimap<K, V>
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: any): boolean
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WidgetLayout {
        align(arg0: Internal.Panel): number
    }
    interface TooltipComponent {
    }
    class ModuleDescriptor$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ModuleDescriptor$Modifier
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ModuleDescriptor$Modifier[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Modifier): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Modifier>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly AUTOMATIC : Internal.ModuleDescriptor$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Modifier;
        static readonly OPEN : Internal.ModuleDescriptor$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClocheFertilizerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        growthModifier(f: number): Internal.ClocheFertilizerRecipeJS
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2IntMap$Entry extends Internal.Map$Entry<number, number> {
        getKey(): any
        getKey(): number
        getValue(): any
        getValue(): number
        getIntKey(): number
        hashCode(): number
        getIntValue(): number
        equals(arg0: any): boolean
        setValue(arg0: number): number
        setValue(arg0: any): any
        setValue(arg0: number): number
    }
    class EnumConfig <E> extends Internal.ConfigWithVariants<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<E>
        notifyAll(): void
        isEqual(v1: E, v2: E): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<E>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        getIteration(v: E, next: boolean): E
        hashCode(): number
        getStringForGUI(v: E): Internal.Component
        getPath(): string
        copy(value: E): E
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: E, c: (arg0: E) => void, def: E): Internal.ConfigValue<E>
        getColor(v: E): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        getIcon(v: E): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<E>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<E>
        setNameKey(key: string): Internal.ConfigValue<E>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: E): boolean
        readonly nameMap : Internal.NameMap<E>;
        defaultValue : E;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: E) => void;
        value : E;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: E);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2CharFunction extends Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class ConfigWithVariants <T> extends Internal.ConfigValue<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        notifyAll(): void
        isEqual(v1: Internal.ConfigValue<Internal.ConfigValue<T>>, v2: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        getIteration(arg0: Internal.ConfigValue<Internal.ConfigValue<T>>, arg1: boolean): Internal.ConfigValue<Internal.ConfigValue<T>>
        hashCode(): number
        getStringForGUI(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Component
        getPath(): string
        copy(value: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.ConfigValue<Internal.ConfigValue<T>>, c: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, def: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getColor(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        getIcon(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void;
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2FloatFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class FireworksJS$Shape extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.FireworksJS$Shape
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.FireworksJS$Shape[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.FireworksJS$Shape): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FireworksJS$Shape>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.FireworksJS$Shape>
        hashCode(): number
        equals(arg0: any): boolean
        static get(name: string): Internal.FireworksJS$Shape
        name(): string
        toString(): string
        ordinal(): number
        static readonly SMALL_BALL : Internal.FireworksJS$Shape;
        static readonly LARGE_BALL : Internal.FireworksJS$Shape;
        static readonly STAR : Internal.FireworksJS$Shape;
        static readonly CREEPER : Internal.FireworksJS$Shape;
        static readonly BURST : Internal.FireworksJS$Shape;
        static readonly VALUES : Internal.FireworksJS$Shape[];
        readonly type : number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FireworksJS$Shape>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DataInput {
        readLine(): string
        readChar(): string
        skipBytes(arg0: number): number
        readLong(): number
        readUTF(): string
        readShort(): number
        readDouble(): number
        readFully(arg0: number[], arg1: number, arg2: number): void
        readFully(arg0: number[]): void
        readFloat(): number
        readBoolean(): boolean
        readByte(): number
        readInt(): number
        readUnsignedByte(): number
        readUnsignedShort(): number
    }
    abstract class FileSystemProvider {
        getFileStore(arg0: Internal.Path): Internal.FileStore
        newByteChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.SeekableByteChannel
        isSameFile(arg0: Internal.Path, arg1: Internal.Path): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getFileAttributeView<V>(arg0: Internal.Path, arg1: Internal.Class<V>, arg2: any[]): V
        newAsynchronousFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: any[]): Internal.AsynchronousFileChannel
        notifyAll(): void
        createSymbolicLink(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void
        static installedProviders(): Internal.List<Internal.FileSystemProvider>
        delete(arg0: Internal.Path): void
        notify(): void
        createLink(arg0: Internal.Path, arg1: Internal.Path): void
        setAttribute(arg0: Internal.Path, arg1: string, arg2: any, arg3: any[]): void
        newInputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.InputStream
        newFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.FileChannel
        hashCode(): number
        newOutputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.OutputStream
        readAttributes(arg0: Internal.Path, arg1: string, arg2: any[]): Internal.Map<string, any>
        readAttributes<A>(arg0: Internal.Path, arg1: Internal.Class<A>, arg2: any[]): A
        getPath(arg0: Internal.URI): Internal.Path
        createDirectory(arg0: Internal.Path, arg1: any[]): void
        copy(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void
        move(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void
        getScheme(): string
        newFileSystem(arg0: Internal.URI, arg1: Internal.Map<string, any>): Internal.FileSystem
        newFileSystem(arg0: Internal.Path, arg1: Internal.Map<string, any>): Internal.FileSystem
        deleteIfExists(arg0: Internal.Path): boolean
        newDirectoryStream(arg0: Internal.Path, arg1: Internal.DirectoryStream$Filter<Internal.Path>): Internal.DirectoryStream<Internal.Path>
        getFileSystem(arg0: Internal.URI): Internal.FileSystem
        checkAccess(arg0: Internal.Path, arg1: any[]): void
        readSymbolicLink(arg0: Internal.Path): Internal.Path
        isHidden(arg0: Internal.Path): boolean
        equals(arg0: any): boolean
        toString(): string
        get scheme(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LightLayer extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.LightLayer
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.LightLayer[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LightLayer): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LightLayer>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.LightLayer>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SKY : Internal.LightLayer;
        static readonly BLOCK : Internal.LightLayer;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LightLayer>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarContext {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        createDefaultEventConfigs(): void
        getCurrentEvent(): Internal.LunarEvent
        notifyAll(): void
        getStrength(): number
        computeLunarForecast(arg0: Internal.ServerLevel, arg1: Internal.LunarForecast): Internal.LunarForecast
        computeLunarForecast(arg0: Internal.ServerLevel, arg1: Internal.LunarForecast, arg2: number): Internal.LunarForecast
        addSettingsIfMissing(): void
        updateForecast(arg0: net.minecraft.world.level.Level, arg1: number): void
        tick(arg0: net.minecraft.world.level.Level): void
        getAndComputeLunarForecast(arg0: Internal.ServerLevel): Internal.LunarEventSavedData
        notify(): void
        getLastEvent(): Internal.LunarEvent
        getLunarForecast(): Internal.LunarForecast
        setStrength(arg0: number): void
        hashCode(): number
        getLunarEvents(): Internal.Map<string, Internal.LunarEvent>
        setLastEvent(arg0: Internal.LunarEvent): void
        equals(arg0: any): boolean
        setCurrentEvent(arg0: string): void
        toString(): string
        handleEventConfigs(arg0: boolean): void
        getLunarTimeSettings(): Internal.LunarContext$LunarTimeSettings
        static readonly CONFIG_NAME : "lunar-settings.json";
        static readonly PACKET_CODEC : Internal.Codec<Internal.LunarContext>;
        get currentEvent(): Internal.LunarEvent;
        get lunarTimeSettings(): Internal.LunarContext$LunarTimeSettings;
        get strength(): number;
        get lunarForecast(): Internal.LunarForecast;
        get lastEvent(): Internal.LunarEvent;
        get lunarEvents(): Internal.Map<string, Internal.LunarEvent>;
        get class(): Internal.Class<any>;
        set strength(arg0: number);
        set lastEvent(arg0: Internal.LunarEvent);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BooleanSupplier {
        getAsBoolean(): boolean
    }
    abstract class ItemType {
        getClass(): Internal.Class<any>
        applyDefaults(builder: Internal.ItemBuilder): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        createItem(arg0: Internal.ItemBuilder): Internal.Item
        generateData(builder: Internal.ItemBuilder, generator: Internal.DataJsonGenerator): void
        toString(): string
        generateAssets(builder: Internal.ItemBuilder, generator: Internal.AssetJsonGenerator): void
        notify(): void
        readonly name : string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Cancellable {
        cancel(): void
        isCancelled(): boolean
        isCancellable(): boolean
    }
    class JobAttributes implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        setSidesToDefault(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDefaultSelection(): Internal.JobAttributes$DefaultSelectionType
        getDestination(): Internal.JobAttributes$DestinationType
        getMaxPage(): number
        notifyAll(): void
        setMultipleDocumentHandling(arg0: Internal.JobAttributes$MultipleDocumentHandlingType): void
        setSides(arg0: Internal.JobAttributes$SidesType): void
        getPageRanges(): number[][]
        setDestination(arg0: Internal.JobAttributes$DestinationType): void
        notify(): void
        getMultipleDocumentHandling(): Internal.JobAttributes$MultipleDocumentHandlingType
        getDialog(): Internal.JobAttributes$DialogType
        setDefaultSelection(arg0: Internal.JobAttributes$DefaultSelectionType): void
        setFileName(arg0: string): void
        setMultipleDocumentHandlingToDefault(): void
        hashCode(): number
        setCopies(arg0: number): void
        setMinPage(arg0: number): void
        setPageRanges(arg0: number[][]): void
        setMaxPage(arg0: number): void
        getFileName(): string
        getCopies(): number
        set(arg0: Internal.JobAttributes): void
        setPrinter(arg0: string): void
        getSides(): Internal.JobAttributes$SidesType
        getFromPage(): number
        getToPage(): number
        setToPage(arg0: number): void
        setDialog(arg0: Internal.JobAttributes$DialogType): void
        getPrinter(): string
        equals(arg0: any): boolean
        clone(): any
        setCopiesToDefault(): void
        toString(): string
        setFromPage(arg0: number): void
        getMinPage(): number
        get fileName(): string;
        get defaultSelection(): Internal.JobAttributes$DefaultSelectionType;
        get printer(): string;
        get destination(): Internal.JobAttributes$DestinationType;
        get minPage(): number;
        get multipleDocumentHandling(): Internal.JobAttributes$MultipleDocumentHandlingType;
        get pageRanges(): number[][];
        get dialog(): Internal.JobAttributes$DialogType;
        get copies(): number;
        get fromPage(): number;
        get sides(): Internal.JobAttributes$SidesType;
        get class(): Internal.Class<any>;
        get maxPage(): number;
        get toPage(): number;
        set pageRanges(arg0: number[][]);
        set dialog(arg0: Internal.JobAttributes$DialogType);
        set fileName(arg0: string);
        set copies(arg0: number);
        set defaultSelection(arg0: Internal.JobAttributes$DefaultSelectionType);
        set fromPage(arg0: number);
        set printer(arg0: string);
        set destination(arg0: Internal.JobAttributes$DestinationType);
        set minPage(arg0: number);
        set sides(arg0: Internal.JobAttributes$SidesType);
        set multipleDocumentHandling(arg0: Internal.JobAttributes$MultipleDocumentHandlingType);
        set maxPage(arg0: number);
        set toPage(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockItem extends Internal.Item implements Internal.IPlaceableItem {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        removeFromBlockToItemMap(arg0: Internal.Map<Internal.Block, Internal.Item>, arg1: Internal.Item): void
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notifyAll(): void
        getId(): string
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getRenderPropertiesInternal(): any
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GroupPrincipal extends Internal.UserPrincipal {
        getName(): string
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
    }
    interface EnhancedCelestialsWorldData {
        getLunarContext(): Internal.LunarContext
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext
    }
    interface RecipeFilter extends Internal.Predicate<Internal.RecipeJS> {
        or(arg0: (arg0: Internal.RecipeJS) => boolean): (arg0: Internal.RecipeJS) => boolean
        test(arg0: Internal.RecipeJS): boolean
        test(arg0: any): boolean
        and(arg0: (arg0: Internal.RecipeJS) => boolean): (arg0: Internal.RecipeJS) => boolean
        negate(): (arg0: Internal.RecipeJS) => boolean
    }
    interface AWTEventListener extends Internal.EventListener {
        eventDispatched(arg0: Internal.AWTEvent): void
    }
    interface Byte2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class ByteBuf implements Internal.ReferenceCounted, Internal.Comparable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        release(arg0: number): boolean
        release(): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        nioBufferCount(): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(): boolean
        isReadable(arg0: number): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        isWritable(): boolean
        isWritable(arg0: number): boolean
        notify(): void
        readChar(): string
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        hasMemoryAddress(): boolean
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readDouble(): number
        readUnsignedShortLE(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(arg0: number, arg1: number): Internal.ByteBuf
        copy(): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        writeInt(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        readFloatLE(): number
        hasArray(): boolean
        getDoubleLE(arg0: number): number
        memoryAddress(): number
        maxFastWritableBytes(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        nioBuffers(): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: any): boolean
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBoolean(): boolean
        toString(): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        isDirect(): boolean
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getClass(): Internal.Class<any>
        getFloatLE(arg0: number): number
        readerIndex(): number
        readerIndex(arg0: number): Internal.ByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuf): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(): Internal.ByteBuffer
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        touch(arg0: any): Internal.ByteBuf
        touch(arg0: any): Internal.ReferenceCounted
        touch(): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
        discardSomeReadBytes(): Internal.ByteBuf
        duplicate(): Internal.ByteBuf
        writerIndex(): number
        writerIndex(arg0: number): Internal.ByteBuf
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        getChar(arg0: number): string
        retainedDuplicate(): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readMedium(): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByte(arg0: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        readUnsignedShort(): number
        getMedium(arg0: number): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        notifyAll(): void
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        hashCode(): number
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readLongLE(): number
        readUnsignedMediumLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        isContiguous(): boolean
        writeDoubleLE(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntSupplier {
        getAsInt(): number
    }
    class CountingMap {
        add(key: any, value: number): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        set(key: any, value: number): number
        getValues(): Internal.Collection<number>
        forEach(forEach: (arg0: Internal.Object2LongEntry) => void): void
        notifyAll(): void
        clear(): void
        getTotalCount(): number
        getKeys(): Internal.Set<any>
        notify(): void
        getSize(): number
        getEntries(): Internal.List<Internal.Object2LongEntry>
        hashCode(): number
        equals(arg0: any): boolean
        get(key: any): number
        toString(): string
        get entries(): Internal.List<Internal.Object2LongEntry>;
        get size(): number;
        get keys(): Internal.Set<any>;
        get values(): Internal.Collection<number>;
        get totalCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ViewArea {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PacketFlow extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.PacketFlow
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.PacketFlow[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.PacketFlow): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PacketFlow>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.PacketFlow>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly CLIENTBOUND : Internal.PacketFlow;
        static readonly SERVERBOUND : Internal.PacketFlow;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PacketFlow>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockStateLightInfoAccess {
        getLightInfo(): Internal.BlockStateLightInfo
    }
    interface Double2FloatFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Event implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        controlDown(): boolean
        shiftDown(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        metaDown(): boolean
        toString(): string
        notify(): void
        translate(arg0: number, arg1: number): void
        static readonly DOWN : 1005;
        static readonly PRINT_SCREEN : 1020;
        static readonly BACK_SPACE : 8;
        when : number;
        static readonly MOUSE_UP : 502;
        static readonly SCROLL_ABSOLUTE : 605;
        static readonly KEY_RELEASE : 402;
        static readonly MOUSE_DRAG : 506;
        static readonly UP : 1004;
        static readonly SCROLL_PAGE_UP : 603;
        id : number;
        static readonly LIST_DESELECT : 702;
        static readonly LOAD_FILE : 1002;
        static readonly MOUSE_EXIT : 505;
        static readonly LEFT : 1006;
        static readonly F1 : 1008;
        static readonly MOUSE_DOWN : 501;
        static readonly F2 : 1009;
        static readonly F3 : 1010;
        static readonly F4 : 1011;
        static readonly F5 : 1012;
        static readonly F6 : 1013;
        static readonly SAVE_FILE : 1003;
        static readonly F7 : 1014;
        static readonly F8 : 1015;
        static readonly F9 : 1016;
        static readonly NUM_LOCK : 1023;
        static readonly MOUSE_ENTER : 504;
        static readonly SCROLL_END : 607;
        static readonly END : 1001;
        static readonly INSERT : 1025;
        static readonly WINDOW_DEICONIFY : 204;
        static readonly GOT_FOCUS : 1004;
        static readonly WINDOW_DESTROY : 201;
        static readonly SCROLL_BEGIN : 606;
        static readonly CAPS_LOCK : 1022;
        static readonly SCROLL_LINE_DOWN : 602;
        static readonly WINDOW_EXPOSE : 202;
        clickCount : number;
        static readonly SHIFT_MASK : 1;
        static readonly KEY_ACTION : 403;
        static readonly ENTER : 10;
        static readonly LOST_FOCUS : 1005;
        modifiers : number;
        static readonly PAUSE : 1024;
        static readonly KEY_PRESS : 401;
        static readonly DELETE : 127;
        static readonly LIST_SELECT : 701;
        arg : any;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly RIGHT : 1007;
        static readonly WINDOW_MOVED : 205;
        key : number;
        evt : Internal.Event;
        static readonly PGDN : 1003;
        static readonly F10 : 1017;
        static readonly WINDOW_ICONIFY : 203;
        static readonly F12 : 1019;
        static readonly SCROLL_LINE_UP : 601;
        static readonly F11 : 1018;
        static readonly ESCAPE : 27;
        target : any;
        static readonly MOUSE_MOVE : 503;
        static readonly SCROLL_LOCK : 1021;
        static readonly TAB : 9;
        static readonly PGUP : 1002;
        static readonly SCROLL_PAGE_DOWN : 604;
        static readonly ACTION_EVENT : 1001;
        x : number;
        y : number;
        static readonly KEY_ACTION_RELEASE : 404;
        static readonly META_MASK : 4;
        static readonly HOME : 1000;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleProvider <T> {
    }
    interface AccessInputConstantsKey {
    }
    abstract class BuilderBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        translationKey(key: string): Internal.BuilderBase
        getBuilderType(): string
        hashCode(): number
        displayName(name: string): Internal.BuilderBase
        newID(pre: string, post: string): ResourceLocation
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        tag(tag: ResourceLocation): Internal.BuilderBase
        notify(): void
        readonly id : ResourceLocation;
        defaultTags : Internal.Set<ResourceLocation>;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FluidIngredient implements Internal.Predicate<Internal.FluidStack> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: Internal.FluidStack) => boolean): (arg0: Internal.FluidStack) => boolean
        static read(arg0: Internal.FriendlyByteBuf): (arg0: any) => boolean
        static fromTag(arg0: Internal.Tag$Named<Internal.Fluid>, arg1: number): (arg0: any) => boolean
        test(arg0: any): boolean
        test(arg0: Internal.FluidStack): boolean
        notifyAll(): void
        static isFluidIngredient(arg0: Internal.JsonElement): boolean
        static fromFluid(arg0: Internal.Fluid, arg1: number): (arg0: any) => boolean
        notify(): void
        getMatchingFluidStacks(): Internal.List<Internal.FluidStack>
        serialize(): Internal.JsonObject
        and(arg0: (arg0: Internal.FluidStack) => boolean): (arg0: Internal.FluidStack) => boolean
        negate(): (arg0: Internal.FluidStack) => boolean
        hashCode(): number
        equals(arg0: any): boolean
        getRequiredAmount(): number
        toString(): string
        write(arg0: Internal.FriendlyByteBuf): void
        static fromFluidStack(arg0: Internal.FluidStack): (arg0: any) => boolean
        static deserialize(arg0: Internal.JsonElement): (arg0: any) => boolean
        matchingFluidStacks : Internal.List<Internal.FluidStack>;
        static readonly EMPTY : (arg0: any) => boolean;
        get requiredAmount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInt2ObjectFunction <V> implements Internal.Int2ObjectFunction<V>, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        notifyAll(): void
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        notify(): void
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        hashCode(): number
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        toString(): string
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class GlyphVector implements Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getGlyphPosition(arg0: number): Internal.Point2D
        getGlyphPixelBounds(arg0: number, arg1: Internal.FontRenderContext, arg2: number, arg3: number): Internal.Rectangle
        getLogicalBounds(): Internal.Rectangle2D
        getGlyphCharIndices(arg0: number, arg1: number, arg2: number[]): number[]
        notifyAll(): void
        getVisualBounds(): Internal.Rectangle2D
        notify(): void
        getGlyphCharIndex(arg0: number): number
        getOutline(arg0: number, arg1: number): Internal.Shape
        getOutline(): Internal.Shape
        performDefaultLayout(): void
        getGlyphJustificationInfo(arg0: number): Internal.GlyphJustificationInfo
        hashCode(): number
        getFontRenderContext(): Internal.FontRenderContext
        getGlyphMetrics(arg0: number): Internal.GlyphMetrics
        getGlyphVisualBounds(arg0: number): Internal.Shape
        getLayoutFlags(): number
        setGlyphPosition(arg0: number, arg1: Internal.Point2D): void
        getGlyphCodes(arg0: number, arg1: number, arg2: number[]): number[]
        getGlyphLogicalBounds(arg0: number): Internal.Shape
        getPixelBounds(arg0: Internal.FontRenderContext, arg1: number, arg2: number): Internal.Rectangle
        getNumGlyphs(): number
        getGlyphTransform(arg0: number): Internal.AffineTransform
        equals(arg0: Internal.GlyphVector): boolean
        equals(arg0: any): boolean
        toString(): string
        getFont(): java_.awt.Font
        getGlyphPositions(arg0: number, arg1: number, arg2: number[]): number[]
        getGlyphCode(arg0: number): number
        getGlyphOutline(arg0: number, arg1: number, arg2: number): Internal.Shape
        getGlyphOutline(arg0: number): Internal.Shape
        setGlyphTransform(arg0: number, arg1: Internal.AffineTransform): void
        static readonly FLAG_HAS_TRANSFORMS : 1;
        static readonly FLAG_HAS_POSITION_ADJUSTMENTS : 2;
        static readonly FLAG_MASK : 15;
        static readonly FLAG_COMPLEX_GLYPHS : 8;
        static readonly FLAG_RUN_RTL : 4;
        get outline(): Internal.Shape;
        get logicalBounds(): Internal.Rectangle2D;
        get numGlyphs(): number;
        get fontRenderContext(): Internal.FontRenderContext;
        get visualBounds(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        get layoutFlags(): number;
        get font(): java_.awt.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class OptionalInt {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: number): number
        notify(): void
        getAsInt(): number
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalInt
        orElseGet(arg0: Internal.IntSupplier): number
        stream(): Internal.IntStream
        hashCode(): number
        ifPresent(arg0: java_.util.function_.IntConsumer): void
        ifPresentOrElse(arg0: java_.util.function_.IntConsumer, arg1: Internal.Runnable): void
        static of(arg0: number): Internal.OptionalInt
        equals(arg0: any): boolean
        toString(): string
        get asInt(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockBuilder extends Internal.BuilderBase {
        suffocating(b: boolean): Internal.BlockBuilder
        noItem(): Internal.BlockBuilder
        getClass(): Internal.Class<any>
        translationKey(key: string): Internal.BuilderBase
        getBuilderType(): string
        newID(pre: string, post: string): ResourceLocation
        type(t: Internal.BlockType): Internal.BlockBuilder
        unbreakable(): Internal.BlockBuilder
        model(m: string): Internal.BlockBuilder
        tag(tag: ResourceLocation): Internal.BlockBuilder
        tag(arg0: ResourceLocation): Internal.BuilderBase
        tagBoth(tag: ResourceLocation): Internal.BlockBuilder
        defaultCutout(): Internal.BlockBuilder
        item(i: (arg0: Internal.BlockItemBuilder) => void): Internal.BlockBuilder
        resistance(r: number): Internal.BlockBuilder
        hardness(h: number): Internal.BlockBuilder
        slipperiness(f: number): Internal.BlockBuilder
        textureSide(direction: Internal.Direction, tex: string): Internal.BlockBuilder
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        waterlogged(): Internal.BlockBuilder
        color(index: number, c: number): Internal.BlockBuilder
        textureAll(tex: string): Internal.BlockBuilder
        displayName(name: string): Internal.BuilderBase
        notifyAll(): void
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder
        viewBlocking(b: boolean): Internal.BlockBuilder
        notify(): void
        transparent(b: boolean): Internal.BlockBuilder
        tagBlock(tag: ResourceLocation): Internal.BlockBuilder
        fullBlock(f: boolean): Internal.BlockBuilder
        createProperties(): Internal.BlockBehaviour$Properties
        notSolid(): Internal.BlockBuilder
        hashCode(): number
        noCollission(): Internal.BlockBuilder
        requiresTool(f: boolean): Internal.BlockBuilder
        renderType(l: string): Internal.BlockBuilder
        jumpFactor(f: number): Internal.BlockBuilder
        createShape(): Internal.VoxelShape
        opaque(o: boolean): Internal.BlockBuilder
        randomTick(randomTickCallback: (arg0: Internal.RandomTickCallbackJS) => void): Internal.BlockBuilder
        texture(id: string, tex: string): Internal.BlockBuilder
        noDrops(): Internal.BlockBuilder
        tagItem(tag: ResourceLocation): Internal.BlockBuilder
        speedFactor(f: number): Internal.BlockBuilder
        noValidSpawns(b: boolean): Internal.BlockBuilder
        lightLevel(light: number): Internal.BlockBuilder
        defaultTranslucent(): Internal.BlockBuilder
        material(m: Internal.MaterialJS): Internal.BlockBuilder
        equals(arg0: any): boolean
        toString(): string
        redstoneConductor(b: boolean): Internal.BlockBuilder
        readonly textures : Internal.JsonObject;
        defaultTags : Internal.Set<ResourceLocation>;
        static current : Internal.BlockBuilder;
        lootTable : (arg0: Internal.LootBuilder) => void;
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        block : Internal.Block;
        readonly id : ResourceLocation;
        customShape : Internal.List<Internal.AABB>;
        itemBuilder : Internal.BlockItemBuilder;
        randomTickCallback : (arg0: Internal.RandomTickCallbackJS) => void;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DragSourceMotionListener extends Internal.EventListener {
        dragMouseMoved(arg0: Internal.DragSourceDragEvent): void
    }
    interface Byte2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class BlockEntityPredicate implements Internal.BlockPredicate {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        data(cd: Internal.BlockEntityPredicateDataCheck): Internal.BlockEntityPredicate
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        check(block: Internal.BlockContainerJS): boolean
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Shape {
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: Internal.Point2D): boolean
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersects(arg0: Internal.Rectangle2D): boolean
        getBounds2D(): Internal.Rectangle2D
        getBounds(): Internal.Rectangle
    }
    class AttributeKey <T> extends Internal.AbstractConstant<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        static valueOf<T_>(arg0: string): Internal.AttributeKey<T_>
        static valueOf<T_>(arg0: Internal.Class<any>, arg1: string): Internal.AttributeKey<T_>
        notifyAll(): void
        equals(arg0: any): boolean
        name(): string
        static exists(arg0: string): boolean
        toString(): string
        static newInstance<T_>(arg0: string): Internal.AttributeKey<T_>
        id(): number
        compareTo(arg0: Internal.AttributeKey<Internal.AttributeKey<T>>): number
        compareTo(arg0: any): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FormattedText {
        getString(): string
    }
    abstract class AbstractObjectList <K> extends Internal.AbstractObjectCollection<any> implements Internal.ObjectList<K>, Internal.Stack<K> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.List<K>): number
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): K
        remove(arg0: any): boolean
        pop(): K
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<any>
        iterator(): Internal.ObjectListIterator<K>
        top(): K
        stream(): Internal.Stream<K>
        hashCode(): number
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        addElements(arg0: number, arg1: K[]): void
        get(arg0: number): K
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<K>
        indexOf(arg0: any): number
        add(arg0: K): boolean
        add(arg0: number, arg1: K): void
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        subList(arg0: number, arg1: number): Internal.List<any>
        set(arg0: number, arg1: K): K
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: K) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        setElements(arg0: K[]): void
        setElements(arg0: number, arg1: K[]): void
        sort(arg0: Internal.Comparator<K>): void
        removeElements(arg0: number, arg1: number): void
        push(arg0: K): void
        removeIf(arg0: (arg0: K) => boolean): boolean
        peek(arg0: number): K
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(arg0: number): void
        size(): number
        addAll(arg0: Internal.Collection<K>): boolean
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        addAll(arg0: Internal.ObjectList<K>): boolean
        equals(arg0: any): boolean
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.ObjectListIterator<K>
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        listIterator(arg0: number): Internal.ListIterator<any>
        toString(): string
        unstableSort(arg0: Internal.Comparator<K>): void
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set elements(arg0: K[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Package extends Internal.NamedPackage implements Internal.AnnotatedElement {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        isSealed(arg0: Internal.URL): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getPackage(arg0: string): Internal.Package
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        getSpecificationTitle(): string
        getImplementationTitle(): string
        getAnnotations(): Internal.Annotation[]
        isCompatibleWith(arg0: string): boolean
        notify(): void
        getSpecificationVendor(): string
        getDeclaredAnnotations(): Internal.Annotation[]
        getAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[]
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[]
        getAnnotation<A_>(arg0: Internal.Class<A_>): A_
        hashCode(): number
        equals(arg0: any): boolean
        static getPackages(): Internal.Package[]
        getDeclaredAnnotation<A_>(arg0: Internal.Class<A_>): A_
        toString(): string
        getSpecificationVersion(): string
        getImplementationVendor(): string
        getImplementationVersion(): string
        get specificationVendor(): string;
        get declaredAnnotations(): Internal.Annotation[];
        get specificationTitle(): string;
        get implementationVersion(): string;
        get sealed(): boolean;
        get name(): string;
        get implementationVendor(): string;
        get annotations(): Internal.Annotation[];
        get implementationTitle(): string;
        get packages(): Internal.Package[];
        get class(): Internal.Class<any>;
        get specificationVersion(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FoodBuilder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        removeEffect(mobEffect: Internal.MobEffect): Internal.FoodBuilder
        notifyAll(): void
        alwaysEdible(flag: boolean): Internal.FoodBuilder
        alwaysEdible(): Internal.FoodBuilder
        fastToEat(flag: boolean): Internal.FoodBuilder
        fastToEat(): Internal.FoodBuilder
        notify(): void
        hunger(h: number): Internal.FoodBuilder
        saturation(s: number): Internal.FoodBuilder
        build(): Internal.FoodProperties
        hashCode(): number
        equals(arg0: any): boolean
        effect(mobEffectId: ResourceLocation, duration: number, amplifier: number, probability: number): Internal.FoodBuilder
        meat(flag: boolean): Internal.FoodBuilder
        meat(): Internal.FoodBuilder
        toString(): string
        eaten(e: (arg0: Internal.ItemFoodEatenEventJS) => void): Internal.FoodBuilder
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Path extends Internal.Comparable<Internal.Path>, Internal.Iterable<Internal.Path>, Internal.Watchable {
        getName(arg0: number): Internal.Path
        resolve(arg0: string): Internal.Path
        resolve(arg0: Internal.Path): Internal.Path
        resolveSibling(arg0: Internal.Path): Internal.Path
        resolveSibling(arg0: string): Internal.Path
        subpath(arg0: number, arg1: number): Internal.Path
        compareTo(arg0: Internal.Path): number
        compareTo(arg0: any): number
        iterator(): Internal.Iterator<Internal.Path>
        hashCode(): number
        normalize(): Internal.Path
        relativize(arg0: Internal.Path): Internal.Path
        getRoot(): Internal.Path
        getFileName(): Internal.Path
        getNameCount(): number
        getParent(): Internal.Path
        spliterator(): Internal.Spliterator<Internal.Path>
        forEach(arg0: (arg0: Internal.Path) => void): void
        toUri(): Internal.URI
        toAbsolutePath(): Internal.Path
        getFileSystem(): Internal.FileSystem
        equals(arg0: any): boolean
        toFile(): Internal.File
        toRealPath(arg0: any[]): Internal.Path
        endsWith(arg0: Internal.Path): boolean
        endsWith(arg0: string): boolean
        isAbsolute(): boolean
        toString(): string
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[]): Internal.WatchKey
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[], arg2: any[]): Internal.WatchKey
        startsWith(arg0: string): boolean
        startsWith(arg0: Internal.Path): boolean
    }
    class Camera {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setAnglesInternal(arg0: number, arg1: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getBlockAtCamera(): Internal.BlockState
        notify(): void
        get blockAtCamera(): Internal.BlockState;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GenericFutureListener <F> extends Internal.EventListener {
        operationComplete(arg0: F): void
    }
    abstract class AbstractInt2IntFunction implements Internal.Int2IntFunction, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        notifyAll(): void
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        notify(): void
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        hashCode(): number
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        toString(): string
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Team extends Internal.TeamBase {
        msg(player: Internal.ServerPlayer, message: string): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getOwner(): Internal.UUID
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        notify(): void
        getColoredName(): Internal.Component
        serializeNBT(): Internal.SNBTCompoundTag
        hashCode(): number
        info(source: Internal.CommandSourceStack): number
        settings(source: Internal.CommandSourceStack, key: Internal.TeamProperty<any>, value: string): number
        isAlly(profile: Internal.UUID): boolean
        getProperty<T_>(property: Internal.TeamProperty<T_>): T_
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        sendMessage(from: Internal.UUID, text: Internal.Component): void
        deserializeNBT(tag: Internal.CompoundTag): void
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        getOnlineRanked(rank: Internal.TeamRank): Internal.List<Internal.ServerPlayer>
        denyInvite(source: Internal.CommandSourceStack): number
        isFreeToJoin(): boolean
        getDisplayName(): string
        getType(): Internal.TeamType
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>
        setProperty<T_>(property: Internal.TeamProperty<T_>, value: T_): void
        equals(o: any): boolean
        toString(): string
        getMembers(): Internal.Set<Internal.UUID>
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ServerScriptManager {
        getClass(): Internal.Class<any>
        init(serverResources: Internal.ServerResources): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        reloadScriptManager(resourceManager: Internal.ResourceManager): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        resourcePackList(list0: Internal.List<Internal.PackResources>): Internal.List<Internal.PackResources>
        notify(): void
        readonly scriptManager : Internal.ScriptManager;
        static instance : Internal.ServerScriptManager;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class VarHandle implements Internal.Constable {
        getClass(): Internal.Class<any>
        toMethodHandle(arg0: Internal.VarHandle$AccessMode): Internal.MethodHandle
        getAndBitwiseXor(arg0: any[]): any
        static storeStoreFence(): void
        compareAndExchange(arg0: any[]): any
        getAndSetRelease(arg0: any[]): any
        getAndBitwiseAnd(arg0: any[]): any
        describeConstable(): Internal.Optional<Internal.VarHandle$VarHandleDesc>
        varType(): Internal.Class<any>
        getAndBitwiseOrAcquire(arg0: any[]): any
        setVolatile(arg0: any[]): void
        static releaseFence(): void
        getAndAdd(arg0: any[]): any
        weakCompareAndSetRelease(arg0: any[]): boolean
        static loadLoadFence(): void
        getAndAddAcquire(arg0: any[]): any
        setOpaque(arg0: any[]): void
        isAccessModeSupported(arg0: Internal.VarHandle$AccessMode): boolean
        compareAndExchangeRelease(arg0: any[]): any
        compareAndSet(arg0: any[]): boolean
        compareAndExchangeAcquire(arg0: any[]): any
        getAndBitwiseXorRelease(arg0: any[]): any
        withInvokeBehavior(): Internal.VarHandle
        withInvokeExactBehavior(): Internal.VarHandle
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        coordinateTypes(): Internal.List<Internal.Class<any>>
        weakCompareAndSetPlain(arg0: any[]): boolean
        getVolatile(arg0: any[]): any
        static fullFence(): void
        notifyAll(): void
        getAcquire(arg0: any[]): any
        accessModeType(arg0: Internal.VarHandle$AccessMode): Internal.MethodType
        getAndBitwiseOr(arg0: any[]): any
        static acquireFence(): void
        hasInvokeExactBehavior(): boolean
        notify(): void
        getAndBitwiseOrRelease(arg0: any[]): any
        getAndSetAcquire(arg0: any[]): any
        getOpaque(arg0: any[]): any
        getAndBitwiseXorAcquire(arg0: any[]): any
        hashCode(): number
        getAndBitwiseAndRelease(arg0: any[]): any
        get(arg0: any[]): any
        getAndSet(arg0: any[]): any
        weakCompareAndSetAcquire(arg0: any[]): boolean
        set(arg0: any[]): void
        weakCompareAndSet(arg0: any[]): boolean
        getAndAddRelease(arg0: any[]): any
        equals(arg0: any): boolean
        setRelease(arg0: any[]): void
        toString(): string
        getAndBitwiseAndAcquire(arg0: any[]): any
        get class(): Internal.Class<any>;
        set opaque(arg0: any[]);
        set release(arg0: any[]);
        set volatile(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IRefinementItem$AccessorySlotType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.IRefinementItem$AccessorySlotType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.IRefinementItem$AccessorySlotType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.IRefinementItem$AccessorySlotType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IRefinementItem$AccessorySlotType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.IRefinementItem$AccessorySlotType>
        getSlot(): number
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly RING : Internal.IRefinementItem$AccessorySlotType;
        static readonly OBI_BELT : Internal.IRefinementItem$AccessorySlotType;
        static readonly AMULET : Internal.IRefinementItem$AccessorySlotType;
        get slot(): number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IRefinementItem$AccessorySlotType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void
    }
    class Painter {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getObject(key: string): Internal.PainterObject
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clear(): void
        setVariable(key: string, variable: Internal.Unit): void
        paint(root: Internal.CompoundTag): void
        toString(): string
        make(type: string): Internal.PainterObject
        notify(): void
        readonly unitStorage : Internal.UnitStorage;
        static readonly LEFT : -1;
        static readonly RANDOM : Internal.Random;
        static readonly DRAW_INGAME : 1;
        static readonly INSTANCE : Internal.Painter;
        static readonly BOTTOM : 1;
        readonly screenHeightUnit : Internal.MutableUnit;
        static readonly DRAW_GUI : 2;
        static readonly CENTER : 0;
        readonly screenWidthUnit : Internal.MutableUnit;
        static readonly DRAW_ALWAYS : 0;
        static readonly TOP : -1;
        readonly mouseXUnit : Internal.MutableUnit;
        readonly mouseYUnit : Internal.MutableUnit;
        readonly deltaUnit : Internal.MutableUnit;
        static readonly RIGHT : 1;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CaptureEntityEntry extends Internal.WeightedEntry$IntrusiveBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getEntity(): Internal.EntityType<Internal.Mob>
        notify(): void
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityType<Internal.Mob>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class IERecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(arg0: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorScreen {
        getRenderables(): Internal.List<Internal.Widget>
        getNarratables(): Internal.List<Internal.NarratableEntry>
    }
    abstract class BaseFilterItem extends Internal.Item implements Internal.IItemFilter {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        getItems(filter: Internal.ItemStack, set: Internal.Set<Internal.Item>): void
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getDisplayItemStacks(filter: Internal.ItemStack, list: Internal.List<Internal.ItemStack>): void
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        filterItem(filter: Internal.ItemStack, item: Internal.Item): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notifyAll(): void
        getId(): string
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getRenderPropertiesInternal(): any
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        clearFilterCache(filter: Internal.ItemStack): void
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        getRegistryName(): ResourceLocation
        addInfo(filter: Internal.ItemStack, info: Internal.FilterInfo, expanded: boolean): void
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        filter(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        resetFilterData(filter: Internal.ItemStack): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntBinaryOperator extends Internal.BinaryOperator<number>, java_.util.function_.IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number
        apply(arg0: any, arg1: any): any
        apply(arg0: number, arg1: number): number
        apply(arg0: number, arg1: number): number
        andThen<V_>(arg0: (arg0: number) => V_): (arg0: number, arg1: number) => V_
    }
    class FriendlyByteBuf extends Internal.ByteBuf implements Internal.IForgeFriendlyByteBuf {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        writeItemStack(arg0: Internal.ItemStack, arg1: boolean): Internal.FriendlyByteBuf
        release(): boolean
        release(arg0: number): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRegistryId<T_>(): T_
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        nioBufferCount(): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(): boolean
        isReadable(arg0: number): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        isWritable(): boolean
        isWritable(arg0: number): boolean
        notify(): void
        readChar(): string
        capacity(arg0: number): Internal.ByteBuf
        capacity(): number
        hasMemoryAddress(): boolean
        readRegistryIdSafe<T_>(arg0: Internal.Class<T_>): T_
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readDouble(): number
        readUnsignedShortLE(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        copy(arg0: number, arg1: number): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        writeInt(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        ensureWritable(arg0: number): Internal.ByteBuf
        readFloatLE(): number
        getDoubleLE(arg0: number): number
        hasArray(): boolean
        memoryAddress(): number
        maxFastWritableBytes(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: any): boolean
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBoolean(): boolean
        toString(): string
        toString(arg0: Internal.Charset): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        retainedSlice(): Internal.ByteBuf
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        readMediumLE(): number
        isDirect(): boolean
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getClass(): Internal.Class<any>
        getFloatLE(arg0: number): number
        readerIndex(): number
        readerIndex(arg0: number): Internal.ByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuf): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<any>, arg1: ResourceLocation): void
        writeRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry<T_>, arg1: T_): void
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(): Internal.ByteBuffer
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        touch(): Internal.ByteBuf
        touch(): Internal.ReferenceCounted
        touch(arg0: any): Internal.ByteBuf
        touch(arg0: any): Internal.ReferenceCounted
        discardSomeReadBytes(): Internal.ByteBuf
        readRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry<T_>): T_
        duplicate(): Internal.ByteBuf
        writerIndex(): number
        writerIndex(arg0: number): Internal.ByteBuf
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        getChar(arg0: number): string
        retainedDuplicate(): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        readMedium(): number
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        readUnsignedShort(): number
        getMedium(arg0: number): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        readFluidStack(): Internal.FluidStack
        notifyAll(): void
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        hashCode(): number
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readLongLE(): number
        readUnsignedMediumLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        writeRegistryId<T_>(arg0: T_): void
        getUnsignedByte(arg0: number): number
        writeFluidStack(arg0: Internal.FluidStack): void
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        isContiguous(): boolean
        writeDoubleLE(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongPredicate extends Internal.Predicate<number>, java_.util.function_.LongPredicate {
        or(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        or(arg0: java_.util.function_.LongPredicate): (arg0: any) => boolean
        or(arg0: java_.util.function_.LongPredicate): java_.util.function_.LongPredicate
        or(arg0: (arg0: any) => boolean): (arg0: any) => boolean
        test(arg0: number): boolean
        test(arg0: any): boolean
        test(arg0: number): boolean
        and(arg0: java_.util.function_.LongPredicate): java_.util.function_.LongPredicate
        and(arg0: java_.util.function_.LongPredicate): (arg0: any) => boolean
        and(arg0: (arg0: any) => boolean): (arg0: any) => boolean
        and(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        negate(): java_.util.function_.LongPredicate
        negate(): (arg0: any) => boolean
        negate(): (arg0: any) => boolean
    }
    class Connection extends Internal.SimpleChannelInboundHandler<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        getDirection(): Internal.PacketFlow
        notifyAll(): void
        channel(): io.netty.channel.Channel
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        isSharable(): boolean
        notify(): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        acceptInboundMessage(arg0: any): boolean
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        get direction(): Internal.PacketFlow;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    class ItemStackJS implements Internal.IngredientJS, Internal.NBTSerializable, Internal.ChangeListener<Internal.Tag>, Internal.SpecialEquality {
        getItemIds(): Internal.Set<string>
        getClass(): Internal.Class<any>
        getNbt(): Internal.CompoundTag
        getName(): Internal.Text
        isBlock(): boolean
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        getItem(): Internal.Item
        static findGroup(id: string): Internal.CreativeModeTab
        getTags(): Internal.Collection<ResourceLocation>
        hasEnchantment(enchantment: Internal.Enchantment, level: number): boolean
        getItemGroup(): string
        setChance(c: number): void
        getFirst(): Internal.ItemStackJS
        static getList(): Internal.List<Internal.ItemStackJS>
        withName(displayName: Internal.Component): Internal.ItemStackJS
        withChance(c: number): Internal.ItemStackJS
        getCount(): number
        setCount(count: number): void
        test(other: object): boolean
        test(other: string): boolean
        test(other: Internal.ItemStackJS): boolean
        hasTag(tag: ResourceLocation): boolean
        testVanillaItem(item: Internal.Item): boolean
        hasChance(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        static getRawItem(o: any): Internal.Item
        getNbtString(): string
        createVanillaIngredient(): (arg0: any) => boolean
        toJson(): Internal.JsonElement
        isNBTEqual(other: Internal.ItemStack): boolean
        isNBTEqual(other: object): boolean
        isNBTEqual(other: string): boolean
        isNBTEqual(other: Internal.ItemStackJS): boolean
        withCount(c: number): Internal.ItemStackJS
        withCount(arg0: number): Internal.IngredientJS
        static getListJS(): Internal.ListJS
        specialEquals(o: any, shallow: boolean): boolean
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        anyStackMatches(ingredient: string): boolean
        anyStackMatches(ingredient: object): boolean
        anyStackMatches(ingredient: Internal.ItemStackJS): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasNBT(): boolean
        areItemsEqual(other: Internal.ItemStack): boolean
        areItemsEqual(other: object): boolean
        areItemsEqual(other: string): boolean
        areItemsEqual(other: Internal.ItemStackJS): boolean
        getChance(): number
        getMod(): string
        notifyAll(): void
        isInvalidRecipeIngredient(): boolean
        getId(): string
        notify(): void
        weakNBT(): Internal.IngredientJS
        static clearListCache(): void
        not(): Internal.IngredientJS
        toNBT(): Internal.Tag
        toNBT(): Internal.CompoundTag
        getHarvestSpeed(block: Internal.BlockContainerJS): number
        getHarvestSpeed(): number
        hashCode(): number
        static of(o: any): Internal.ItemStackJS
        toRawResultJson(): Internal.JsonElement
        copy(): Internal.Copyable
        copy(): Internal.ItemStackJS
        copy(): Internal.IngredientJS
        getItemStack(): Internal.ItemStack
        withNBT(nbt: Internal.CompoundTag): Internal.ItemStackJS
        toResultJson(): Internal.JsonElement
        onChanged(arg0: any): void
        onChanged(o: Internal.Tag): void
        isEmpty(): boolean
        static getTypeList(): Internal.ListJS
        strongEquals(o: any): boolean
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: object): Internal.IngredientJS
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        filter(filter: Internal.ItemStackJS): Internal.IngredientJS
        filter(filter: string): Internal.IngredientJS
        getEnchantments(): Internal.MapJS
        getFluidStack(): Internal.FluidStackJS
        removeNBT(): Internal.ItemStackJS
        static resultFromRecipeJson(json: Internal.JsonElement): Internal.ItemStackJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        equals(o: any): boolean
        enchant(enchantment: Internal.Enchantment, level: number): Internal.ItemStackJS
        enchant(enchantments: Internal.MapJS): Internal.ItemStackJS
        testVanilla(other: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        ignoreNBT(): Internal.IngredientJS
        toString(): string
        removeChance(): void
        setNbt(tag: Internal.CompoundTag): void
        static readonly EMPTY : Internal.ItemStackJS;
        get nbt(): Internal.CompoundTag;
        get itemStack(): Internal.ItemStack;
        get mod(): string;
        get itemIds(): Internal.Set<string>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get empty(): boolean;
        get harvestSpeed(): number;
        get typeList(): Internal.ListJS;
        get nbtString(): string;
        get block(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get invalidRecipeIngredient(): boolean;
        get itemGroup(): string;
        get item(): Internal.Item;
        get chance(): number;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get count(): number;
        get list(): Internal.List<Internal.ItemStackJS>;
        get enchantments(): Internal.MapJS;
        get listJS(): Internal.ListJS;
        get tags(): Internal.Collection<ResourceLocation>;
        get name(): Internal.Text;
        get fluidStack(): Internal.FluidStackJS;
        get first(): Internal.ItemStackJS;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        set nbt(tag: Internal.CompoundTag);
        set chance(c: number);
        set count(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BakedQuadAccessor {
        getSprite(): Internal.TextureAtlasSprite
    }
    interface Double2DoubleFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface AccessorMultiBufferSource {
        getFallbackBuffer(): Internal.BufferBuilder
        getFixedBuffers(): Internal.Map<Internal.RenderType, Internal.BufferBuilder>
    }
    class VecBuffer {
        getClass(): Internal.Class<any>
        putVec2(arg0: number, arg1: number): Internal.VecBuffer
        putVec2(arg0: number, arg1: number): Internal.VecBuffer
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer
        putVec4(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        putInt(arg0: number): Internal.VecBuffer
        notifyAll(): void
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        notify(): void
        put(arg0: number): Internal.VecBuffer
        put(arg0: Internal.ByteBuffer): Internal.VecBuffer
        put(arg0: Internal.FloatBuffer): Internal.VecBuffer
        putByteArray(arg0: number[]): Internal.VecBuffer
        unwrap(): Internal.ByteBuffer
        putFloat(arg0: number): Internal.VecBuffer
        static allocate(arg0: number): Internal.VecBuffer
        rewind(): Internal.VecBuffer
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        position(arg0: number): Internal.VecBuffer
        position(): number
        putShort(arg0: number): Internal.VecBuffer
        putFloatArray(arg0: number[]): Internal.VecBuffer
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Minecraft extends Internal.ReentrantBlockableEventLoop<any> implements Internal.WindowEventHandler, Internal.IForgeMinecraft, Internal.AccessorMinecraft, vazkii.botania.mixin.client.AccessorMinecraft, Internal.PausedPartialTickAccessor, Internal.MinecraftAccess {
        handler$bgh000$stop(arg0: Internal.CallbackInfo): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        popGuiLayer(): void
        bookshelf$getFontManager(): Internal.FontManager
        execute(arg0: Internal.Runnable): void
        notify(): void
        pushGuiLayer(arg0: Internal.Screen): void
        handler$bmm000$createLevel(arg0: string, arg1: Internal.LevelSettings, arg2: Internal.RegistryAccess$RegistryHolder, arg3: Internal.WorldGenSettings, arg4: Internal.CallbackInfo): void
        getSearchTreeManager(): Internal.SearchRegistry
        hashCode(): number
        handler$zcf000$pickColor(arg0: Internal.CallbackInfo): void
        equals(arg0: any): boolean
        getFontManager(): Internal.FontManager
        flywheel$getPartialTicksPaused(): number
        toString(): string
        close(): void
        getItemColors(): Internal.ItemColors
        get itemColors(): Internal.ItemColors;
        get fontManager(): Internal.FontManager;
        get searchTreeManager(): Internal.SearchRegistry;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockBehaviour extends Internal.ForgeRegistryEntry<any> implements Internal.BlockAccessor, Internal.BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setExplosionResistanceKJS(arg0: number): void
        notifyAll(): void
        setJumpFactorKJS(arg0: number): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Block
        setRegistryName(arg0: string): Internal.Block
        setRegistryName(arg0: string, arg1: string): Internal.Block
        setIsRandomlyTickingKJS(arg0: boolean): void
        notify(): void
        setMaterialKJS(arg0: Internal.Material): void
        getMaterial(): Internal.Material
        setSoundTypeKJS(arg0: Internal.SoundType): void
        hashCode(): number
        getBlockBuilderKJS(): Internal.BlockBuilder
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.Block>
        setSpeedFactorKJS(arg0: number): void
        setBlockBuilderKJS(b: Internal.BlockBuilder): void
        toString(): string
        setFrictionKJS(arg0: number): void
        setHasCollisionKJS(arg0: boolean): void
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): Internal.Material;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set frictionKJS(arg0: number);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: Internal.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Configuration {
        findModule(arg0: string): Internal.Optional<Internal.ResolvedModule>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        resolve(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration
        static resolve(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration
        resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration
        notify(): void
        modules(): Internal.Set<Internal.ResolvedModule>
        parents(): Internal.List<Internal.Configuration>
        static empty(): Internal.Configuration
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodTypeDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfMethod<Internal.ClassDesc, Internal.MethodTypeDesc> {
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>
        parameterType(arg0: number): Internal.ClassDesc
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodTypeDesc
        parameterCount(): number
        changeReturnType(arg0: Internal.ClassDesc): Internal.MethodTypeDesc
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        descriptorString(): string
        insertParameterTypes(arg0: number, arg1: Internal.ClassDesc[]): Internal.MethodTypeDesc
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        changeParameterType(arg0: number, arg1: Internal.ClassDesc): Internal.MethodTypeDesc
        parameterArray(): Internal.TypeDescriptor$OfField[]
        parameterArray(): Internal.ClassDesc[]
        equals(arg0: any): boolean
        parameterList(): Internal.List<Internal.ClassDesc>
        displayDescriptor(): string
        returnType(): Internal.TypeDescriptor$OfField<any>
        returnType(): Internal.ClassDesc
    }
    interface FormattedCharSequence {
    }
    class EventPriority extends Internal.Enum<any> implements Internal.IEventListener {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.EventPriority
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.EventPriority[]
        invoke(arg0: net.minecraftforge.eventbus.api.Event): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.EventPriority): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.EventPriority>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.EventPriority>
        hashCode(): number
        listenerName(): string
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly LOWEST : Internal.EventPriority;
        static readonly HIGH : Internal.EventPriority;
        static readonly LOW : Internal.EventPriority;
        static readonly HIGHEST : Internal.EventPriority;
        static readonly NORMAL : Internal.EventPriority;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.EventPriority>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TickingBlockEntity {
    }
    abstract class ConfigValue <T> implements Internal.Comparable<Internal.ConfigValue<T>> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        notifyAll(): void
        isEqual(v1: Internal.ConfigValue<Internal.ConfigValue<T>>, v2: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        hashCode(): number
        getStringForGUI(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Component
        getPath(): string
        copy(value: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.ConfigValue<Internal.ConfigValue<T>>, c: (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void, def: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getColor(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        getIcon(v: Internal.ConfigValue<Internal.ConfigValue<T>>): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>
        equals(arg0: any): boolean
        onClicked(arg0: Internal.MouseButton, arg1: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>): boolean
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void;
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.ConfigValue<Internal.ConfigValue<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Duration implements Internal.TemporalAmount, Internal.Comparable<Internal.Duration>, Internal.Serializable {
        getClass(): Internal.Class<any>
        negated(): Internal.Duration
        plusHours(arg0: number): Internal.Duration
        compareTo(arg0: Internal.Duration): number
        compareTo(arg0: any): number
        multipliedBy(arg0: number): Internal.Duration
        plusSeconds(arg0: number): Internal.Duration
        toMillis(): number
        static from(arg0: Internal.TemporalAmount): Internal.Duration
        plusNanos(arg0: number): Internal.Duration
        static ofMinutes(arg0: number): Internal.Duration
        static between(arg0: Internal.Temporal, arg1: Internal.Temporal): Internal.Duration
        static ofSeconds(arg0: number, arg1: number): Internal.Duration
        static ofSeconds(arg0: number): Internal.Duration
        truncatedTo(arg0: Internal.TemporalUnit): Internal.Duration
        minusNanos(arg0: number): Internal.Duration
        getNano(): number
        toMillisPart(): number
        plus(arg0: Internal.Duration): Internal.Duration
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        toMinutesPart(): number
        toNanos(): number
        toMinutes(): number
        toHours(): number
        plusMillis(arg0: number): Internal.Duration
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        toSecondsPart(): number
        static ofMillis(arg0: number): Internal.Duration
        minus(arg0: Internal.Duration): Internal.Duration
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        minusHours(arg0: number): Internal.Duration
        notifyAll(): void
        withSeconds(arg0: number): Internal.Duration
        minusMillis(arg0: number): Internal.Duration
        plusMinutes(arg0: number): Internal.Duration
        notify(): void
        toSeconds(): number
        plusDays(arg0: number): Internal.Duration
        dividedBy(arg0: Internal.Duration): number
        dividedBy(arg0: number): Internal.Duration
        minusMinutes(arg0: number): Internal.Duration
        hashCode(): number
        static of(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        get(arg0: Internal.TemporalUnit): number
        isZero(): boolean
        toDays(): number
        toNanosPart(): number
        isNegative(): boolean
        static ofDays(arg0: number): Internal.Duration
        static parse(arg0: Internal.CharSequence): Internal.Duration
        minusDays(arg0: number): Internal.Duration
        toHoursPart(): number
        toDaysPart(): number
        static ofNanos(arg0: number): Internal.Duration
        getSeconds(): number
        abs(): Internal.Duration
        static ofHours(arg0: number): Internal.Duration
        withNanos(arg0: number): Internal.Duration
        equals(arg0: any): boolean
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        toString(): string
        minusSeconds(arg0: number): Internal.Duration
        static readonly ZERO : Internal.Duration;
        get zero(): boolean;
        get negative(): boolean;
        get seconds(): number;
        get nano(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JobAttributes$DefaultSelectionType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly ALL : Internal.JobAttributes$DefaultSelectionType;
        static readonly SELECTION : Internal.JobAttributes$DefaultSelectionType;
        static readonly RANGE : Internal.JobAttributes$DefaultSelectionType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ForwardingMultimap <K, V> extends Internal.ForwardingObject implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>
        containsEntry(arg0: any, arg1: any): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        forEach(arg0: (arg0: K, arg1: V) => void): void
        keys(): Internal.Multiset<K>
        containsKey(arg0: any): boolean
        asMap(): Internal.Map<K, Internal.Collection<V>>
        notifyAll(): void
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: any): boolean
        get(arg0: K): Internal.Collection<V>
        toString(): string
        keySet(): Internal.Set<K>
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DirectoryStream <T> extends Internal.Closeable, Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        close(): void
    }
    class Transformation implements Internal.IForgeTransformation {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation
        notifyAll(): void
        isIdentity(): boolean
        rotateTransform(arg0: Internal.Direction): Internal.Direction
        push(arg0: Internal.PoseStack): void
        notify(): void
        getNormalMatrix(): Internal.Matrix3f
        blockCornerToCenter(): Internal.Transformation
        hashCode(): number
        equals(arg0: any): boolean
        transformPosition(arg0: Internal.Vector4f): void
        toString(): string
        transformNormal(arg0: Internal.Vector3f): void
        blockCenterToCorner(): Internal.Transformation
        get normalMatrix(): Internal.Matrix3f;
        get identity(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ShapelessRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2LongFunction <K> extends Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        removeLong(arg0: any): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getLong(arg0: any): number
        applyAsLong(arg0: K): number
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Int2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface ChannelProgressivePromise extends Internal.ProgressivePromise<void>, Internal.ChannelProgressiveFuture, Internal.ChannelPromise {
        cancel(arg0: boolean): boolean
        unvoid(): Internal.ChannelProgressivePromise
        unvoid(): Internal.ChannelPromise
        channel(): io.netty.channel.Channel
        setProgress(arg0: number, arg1: number): Internal.ChannelProgressivePromise
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<void>
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelProgressivePromise
        awaitUninterruptibly(): Internal.ProgressivePromise<void>
        awaitUninterruptibly(): Internal.Promise<void>
        awaitUninterruptibly(): Internal.Future<void>
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): Internal.ChannelPromise
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        trySuccess(arg0: void): boolean
        trySuccess(): boolean
        tryProgress(arg0: number, arg1: number): boolean
        syncUninterruptibly(): Internal.ChannelProgressivePromise
        syncUninterruptibly(): Internal.ProgressivePromise<void>
        syncUninterruptibly(): Internal.Promise<void>
        syncUninterruptibly(): Internal.Future<void>
        syncUninterruptibly(): Internal.ProgressiveFuture<void>
        syncUninterruptibly(): Internal.ChannelProgressiveFuture
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): Internal.ChannelPromise
        get(): void
        get(arg0: number, arg1: Internal.TimeUnit): void
        await(): Internal.ChannelProgressivePromise
        await(): Internal.ProgressivePromise<void>
        await(): Internal.Promise<void>
        await(): Internal.Future<void>
        await(): Internal.ProgressiveFuture<void>
        await(): Internal.ChannelProgressiveFuture
        await(): Internal.ChannelFuture
        await(): Internal.ChannelPromise
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressivePromise
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressivePromise<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressivePromise
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressivePromise<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise
        getNow(): void
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressivePromise
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressivePromise<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ChannelProgressivePromise
        sync(): Internal.ProgressivePromise<void>
        sync(): Internal.Promise<void>
        sync(): Internal.Future<void>
        sync(): Internal.ProgressiveFuture<void>
        sync(): Internal.ChannelProgressiveFuture
        sync(): Internal.ChannelFuture
        sync(): Internal.ChannelPromise
        setSuccess(arg0: void): Internal.ChannelProgressivePromise
        setSuccess(arg0: void): Internal.ChannelPromise
        setSuccess(): Internal.ChannelProgressivePromise
        setSuccess(): Internal.ChannelPromise
        setSuccess(arg0: void): Internal.ProgressivePromise<void>
        setSuccess(arg0: void): Internal.Promise<void>
        setFailure(arg0: Internal.Throwable): Internal.ChannelProgressivePromise
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<void>
        setFailure(arg0: Internal.Throwable): Internal.Promise<void>
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise
        isVoid(): boolean
        isCancellable(): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressivePromise
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressivePromise<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise
        setUncancellable(): boolean
    }
    interface Char2ObjectFunction <V> extends Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: string, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: string) => V_
        put(arg0: any, arg1: any): any
        put(arg0: string, arg1: V): V
        put(arg0: string, arg1: V): V
        remove(arg0: string): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: string): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: string): V
        containsKey(arg0: any): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Float2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class TeamPropertyType <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static read(buf: Internal.FriendlyByteBuf): Internal.TeamProperty<any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static write(buf: Internal.FriendlyByteBuf, p: Internal.TeamProperty<any>): void
        notify(): void
        static register<Y>(id: string, p: Internal.TeamPropertyType$FromNet<Y>): Internal.TeamPropertyType<Y>
        static readonly ENUM : Internal.TeamPropertyType<string>;
        static readonly PRIVACY_MODE : Internal.TeamPropertyType<Internal.PrivacyMode>;
        static readonly COLOR : Internal.TeamPropertyType<Internal.Color4I>;
        static readonly STRING : Internal.TeamPropertyType<string>;
        readonly deserializer : Internal.TeamPropertyType$FromNet<T>;
        static readonly DOUBLE : Internal.TeamPropertyType<number>;
        readonly id : string;
        static readonly MAP : Internal.Map<string, Internal.TeamPropertyType<any>>;
        static readonly BOOLEAN : Internal.TeamPropertyType<boolean>;
        static readonly INT : Internal.TeamPropertyType<number>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder$Boxed <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
    }
    abstract class AWTEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>
        paramString(): string
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getSource(): any
        notifyAll(): void
        equals(arg0: any): boolean
        getID(): number
        toString(): string
        notify(): void
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        get source(): any;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Particle {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        shouldCull(): boolean
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Rectangle extends Internal.Rectangle2D implements Internal.Shape, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        intersects(arg0: Internal.Rectangle): boolean
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersects(arg0: Internal.Rectangle2D): boolean
        notifyAll(): void
        getFrame(): Internal.Rectangle2D
        getWidth(): number
        inside(arg0: number, arg1: number): boolean
        notify(): void
        getBounds(): Internal.Rectangle
        translate(arg0: number, arg1: number): void
        setFrameFromCenter(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void
        getHeight(): number
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void
        setFrame(arg0: Internal.Point2D, arg1: Internal.Dimension2D): void
        setFrame(arg0: Internal.Rectangle2D): void
        setLocation(arg0: Internal.Point): void
        setLocation(arg0: number, arg1: number): void
        hashCode(): number
        intersection(arg0: Internal.Rectangle): Internal.Rectangle
        getCenterY(): number
        getCenterX(): number
        add(arg0: number, arg1: number): void
        add(arg0: Internal.Point): void
        add(arg0: Internal.Rectangle): void
        add(arg0: Internal.Point2D): void
        add(arg0: number, arg1: number): void
        add(arg0: Internal.Rectangle2D): void
        move(arg0: number, arg1: number): void
        grow(arg0: number, arg1: number): void
        static intersect(arg0: Internal.Rectangle2D, arg1: Internal.Rectangle2D, arg2: Internal.Rectangle2D): void
        getMaxX(): number
        isEmpty(): boolean
        getMaxY(): number
        setRect(arg0: number, arg1: number, arg2: number, arg3: number): void
        setRect(arg0: Internal.Rectangle2D): void
        union(arg0: Internal.Rectangle): Internal.Rectangle
        static union(arg0: Internal.Rectangle2D, arg1: Internal.Rectangle2D, arg2: Internal.Rectangle2D): void
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void
        setBounds(arg0: Internal.Rectangle): void
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void
        setFrameFromDiagonal(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        intersectsLine(arg0: Internal.Line2D): boolean
        getSize(): Internal.Dimension
        contains(arg0: Internal.Point): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Rectangle): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point2D): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        getX(): number
        getY(): number
        createUnion(arg0: Internal.Rectangle2D): Internal.Rectangle2D
        equals(arg0: any): boolean
        outcode(arg0: number, arg1: number): number
        outcode(arg0: Internal.Point2D): number
        clone(): any
        getBounds2D(): Internal.Rectangle2D
        resize(arg0: number, arg1: number): void
        toString(): string
        createIntersection(arg0: Internal.Rectangle2D): Internal.Rectangle2D
        getMinX(): number
        getMinY(): number
        static readonly OUT_TOP : 2;
        static readonly OUT_RIGHT : 4;
        x : number;
        width : number;
        y : number;
        static readonly OUT_BOTTOM : 8;
        static readonly OUT_LEFT : 1;
        height : number;
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get size(): Internal.Dimension;
        get minY(): number;
        get minX(): number;
        get bounds(): Internal.Rectangle;
        get location(): Internal.Point;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        set rect(arg0: Internal.Rectangle2D);
        set size(arg0: Internal.Dimension);
        set bounds(arg0: Internal.Rectangle);
        set location(arg0: Internal.Point);
        set frame(arg0: Internal.Rectangle2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MenuItem extends Internal.MenuComponent implements Internal.Accessible {
        setName(arg0: string): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getLabel(): string
        notifyAll(): void
        getShortcut(): Internal.MenuShortcut
        notify(): void
        paramString(): string
        removeActionListener(arg0: Internal.ActionListener): void
        hashCode(): number
        enable(): void
        enable(arg0: boolean): void
        setFont(arg0: java_.awt.Font): void
        setShortcut(arg0: Internal.MenuShortcut): void
        getParent(): Internal.MenuContainer
        dispatchEvent(arg0: Internal.AWTEvent): void
        deleteShortcut(): void
        addActionListener(arg0: Internal.ActionListener): void
        setActionCommand(arg0: string): void
        getAccessibleContext(): Internal.AccessibleContext
        postEvent(arg0: Internal.Event): boolean
        setEnabled(arg0: boolean): void
        addNotify(): void
        disable(): void
        equals(arg0: any): boolean
        isEnabled(): boolean
        getActionListeners(): Internal.ActionListener[]
        removeNotify(): void
        setLabel(arg0: string): void
        toString(): string
        getFont(): java_.awt.Font
        getActionCommand(): string
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get font(): java_.awt.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICapabilityProviderImpl <B> extends Internal.ICapabilityProvider {
        invalidateCaps(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        reviveCaps(): void
    }
    interface WithAttachedData {
        getData(): Internal.AttachedData
    }
    class TimeUnit extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        static values(): Internal.TimeUnit[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.TimeUnit): number
        convert(arg0: number, arg1: Internal.TimeUnit): number
        convert(arg0: Internal.Duration): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TimeUnit>>
        notify(): void
        toSeconds(arg0: number): number
        sleep(arg0: number): void
        getDeclaringClass(): Internal.Class<Internal.TimeUnit>
        hashCode(): number
        static of(arg0: Internal.ChronoUnit): Internal.TimeUnit
        toMillis(arg0: number): number
        toDays(arg0: number): number
        toChronoUnit(): Internal.ChronoUnit
        timedJoin(arg0: Internal.Thread, arg1: number): void
        timedWait(arg0: any, arg1: number): void
        static valueOf(arg0: string): Internal.TimeUnit
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        toNanos(arg0: number): number
        toMinutes(arg0: number): number
        toHours(arg0: number): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        toMicros(arg0: number): number
        ordinal(): number
        static readonly MILLISECONDS : Internal.TimeUnit;
        static readonly MICROSECONDS : Internal.TimeUnit;
        static readonly HOURS : Internal.TimeUnit;
        static readonly SECONDS : Internal.TimeUnit;
        static readonly NANOSECONDS : Internal.TimeUnit;
        static readonly DAYS : Internal.TimeUnit;
        static readonly MINUTES : Internal.TimeUnit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TimeUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MaterialGroup {
        material<D>(arg0: Internal.StructType<D>): com.jozufozu.flywheel.api.Material<D>
    }
    class UseOnContext {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ClassLoader {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getResource(arg0: string): Internal.URL
        getName(): string
        notifyAll(): void
        setDefaultAssertionStatus(arg0: boolean): void
        setPackageAssertionStatus(arg0: string, arg1: boolean): void
        notify(): void
        setClassAssertionStatus(arg0: string, arg1: boolean): void
        getDefinedPackage(arg0: string): Internal.Package
        clearAssertionStatus(): void
        isRegisteredAsParallelCapable(): boolean
        getResources(arg0: string): Internal.Enumeration<Internal.URL>
        hashCode(): number
        getDefinedPackages(): Internal.Package[]
        getUnnamedModule(): Internal.Module
        static getSystemResources(arg0: string): Internal.Enumeration<Internal.URL>
        getParent(): Internal.ClassLoader
        static getPlatformClassLoader(): Internal.ClassLoader
        getResourceAsStream(arg0: string): Internal.InputStream
        resources(arg0: string): Internal.Stream<Internal.URL>
        static getSystemClassLoader(): Internal.ClassLoader
        static getSystemResource(arg0: string): Internal.URL
        static getSystemResourceAsStream(arg0: string): Internal.InputStream
        equals(arg0: any): boolean
        loadClass(arg0: string): Internal.Class<any>
        toString(): string
        get parent(): Internal.ClassLoader;
        get systemClassLoader(): Internal.ClassLoader;
        get unnamedModule(): Internal.Module;
        get name(): string;
        get registeredAsParallelCapable(): boolean;
        get platformClassLoader(): Internal.ClassLoader;
        get definedPackages(): Internal.Package[];
        get class(): Internal.Class<any>;
        set defaultAssertionStatus(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorFontManager {
        bookshelf$getFonts(): Internal.Map<ResourceLocation, Internal.FontSet>
    }
    interface PaintContext {
        getColorModel(): Internal.ColorModel
        dispose(): void
        getRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Raster
    }
    abstract class SocketAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SectionPos extends Vec3i {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getX(): number
        getY(): number
        getZ(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(arg0: Vec3i): number
        compareTo(arg0: any): number
        notify(): void
        get x(): number;
        get y(): number;
        get z(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AttributedCharacterIterator extends Internal.CharacterIterator {
        next(): string
        getAttributes(): Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>
        getIndex(): number
        previous(): string
        last(): string
        getRunLimit(): number
        getRunLimit(arg0: Internal.Set<Internal.AttributedCharacterIterator$Attribute>): number
        getRunLimit(arg0: Internal.AttributedCharacterIterator$Attribute): number
        getBeginIndex(): number
        current(): string
        getAttribute(arg0: Internal.AttributedCharacterIterator$Attribute): any
        getEndIndex(): number
        setIndex(arg0: number): string
        clone(): any
        getRunStart(arg0: Internal.AttributedCharacterIterator$Attribute): number
        getRunStart(arg0: Internal.Set<Internal.AttributedCharacterIterator$Attribute>): number
        getRunStart(): number
        first(): string
        getAllAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>
    }
    class KnownClientPlayer implements Internal.Comparable<Internal.KnownClientPlayer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getProfile(): Internal.GameProfile
        update(p: Internal.KnownClientPlayer): void
        compareTo(o: Internal.KnownClientPlayer): number
        compareTo(arg0: any): number
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        write(buf: Internal.FriendlyByteBuf): void
        isInternalTeam(): boolean
        teamId : Internal.UUID;
        name : string;
        online : boolean;
        readonly uuid : Internal.UUID;
        get valid(): boolean;
        get internalTeam(): boolean;
        get extraData(): Internal.CompoundTag;
        get profile(): Internal.GameProfile;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MobCategory extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.IExtensibleEnum {
        getClass(): Internal.Class<any>
        init(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.MobCategory
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.MobCategory[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.MobCategory): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobCategory>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.MobCategory>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        static create(arg0: string, arg1: string, arg2: number, arg3: boolean, arg4: boolean, arg5: number): Internal.MobCategory
        toString(): string
        ordinal(): number
        static readonly UNDERGROUND_WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_AMBIENT : Internal.MobCategory;
        static readonly AXOLOTLS : Internal.MobCategory;
        static readonly AMBIENT : Internal.MobCategory;
        static readonly CREATURE : Internal.MobCategory;
        static readonly MISC : Internal.MobCategory;
        static readonly MONSTER : Internal.MobCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class EffectRenderingInventoryScreen <T> extends Internal.AbstractContainerScreen<any> implements Internal.DisplayEffectScreenAccessor {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getHoveredSlot(): Internal.Slot
        isCancelShift(): boolean
        notifyAll(): void
        getYSize(): number
        getIsQuickCrafting(): boolean
        getLeftPos(): number
        notify(): void
        getImageHeight(): number
        balm_getNarratables(): Internal.List<any>
        static renderSlotHighlight(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot
        hashCode(): number
        setIsQuickCrafting(arg0: boolean): void
        getQuickCraftingButton(): number
        getSlotColor(arg0: number): number
        getNarratables(): Internal.List<any>
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void
        setSkipNextRelease(arg0: boolean): void
        handler$zcd000$getTooltipFromItem(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void
        getRenderables(): Internal.List<any>
        getImageWidth(): number
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void
        getMinecraft(): Internal.Minecraft
        getGuiTop(): number
        getTopPos(): number
        getGuiLeft(): number
        balm_getChildren(): Internal.List<any>
        balm_getRenderables(): Internal.List<any>
        equals(arg0: any): boolean
        getSlotUnderMouse(): Internal.Slot
        toString(): string
        getXSize(): number
        tooltipFont : Internal.Font;
        get leftPos(): number;
        get imageWidth(): number;
        get minecraft(): Internal.Minecraft;
        get quickCraftingButton(): number;
        get isQuickCrafting(): boolean;
        get ySize(): number;
        get cancelShift(): boolean;
        get imageHeight(): number;
        get renderables(): Internal.List<any>;
        get hoveredSlot(): Internal.Slot;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get narratables(): Internal.List<any>;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get topPos(): number;
        get guiTop(): number;
        set isQuickCrafting(arg0: boolean);
        set skipNextRelease(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Theme {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        drawCheckboxBackground(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, radioButton: boolean): void
        listFormattedStringToWidth(text: Internal.FormattedText, width: number): Internal.List<Internal.FormattedText>
        trimStringToWidth(text: string, width: number): string
        trimStringToWidth(text: Internal.FormattedText, width: number): Internal.FormattedText
        drawWidget(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType): void
        notifyAll(): void
        drawScrollBar(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType, vertical: boolean): void
        notify(): void
        drawString(matrixStack: Internal.PoseStack, text: any, x: number, y: number): number
        drawString(matrixStack: Internal.PoseStack, text: any, x: number, y: number, color: Internal.Color4I, flags: number): number
        drawString(matrixStack: Internal.PoseStack, text: any, x: number, y: number, flags: number): number
        drawGui(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType): void
        drawScrollBarBackground(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType): void
        drawSlot(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType): void
        hashCode(): number
        getContentColor(type: Internal.WidgetType): Internal.Color4I
        drawContainerSlot(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        drawButton(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType): void
        drawContextMenuBackground(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        drawTextBox(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        getStringWidth(text: Internal.FormattedText): number
        getStringWidth(text: Internal.FormattedCharSequence): number
        getStringWidth(text: string): number
        drawHorizontalTab(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, selected: boolean): void
        getFontHeight(): number
        drawCheckbox(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number, type: Internal.WidgetType, selected: boolean, radioButton: boolean): void
        trimStringToWidthReverse(text: string, width: number): string
        equals(arg0: any): boolean
        toString(): string
        getFont(): Internal.Font
        getInvertedContentColor(): Internal.Color4I
        drawPanelBackground(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        static readonly MOUSE_OVER : 16;
        static readonly BACKGROUND_SQUARES : Internal.ImageIcon;
        static readonly CENTERED : 4;
        static readonly SHADOW : 2;
        static readonly CENTERED_V : 32;
        static readonly DARK : 1;
        static renderDebugBoxes : false;
        static readonly UNICODE : 8;
        static readonly DEFAULT : Internal.Theme;
        get invertedContentColor(): Internal.Color4I;
        get fontHeight(): number;
        get class(): Internal.Class<any>;
        get font(): Internal.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LivingEntityKJS {
        foodEatenKJS(is: Internal.ItemStack): void
    }
    class BlockEntityWithoutLevelRenderer implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectList <K> extends Internal.List<K>, Internal.Comparable<Internal.List<K>>, Internal.ObjectCollection<K> {
        compareTo(arg0: Internal.List<K>): number
        replaceAll(arg0: (arg0: any) => any): void
        remove(arg0: any): boolean
        remove(arg0: number): K
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<any>
        iterator(): Internal.ObjectListIterator<K>
        stream(): Internal.Stream<K>
        hashCode(): number
        addElements(arg0: number, arg1: K[]): void
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        get(arg0: number): K
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<K>
        indexOf(arg0: any): number
        add(arg0: number, arg1: K): void
        add(arg0: K): boolean
        subList(arg0: number, arg1: number): Internal.List<any>
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        set(arg0: number, arg1: K): K
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: Internal.List<K>) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        setElements(arg0: K[]): void
        setElements(arg0: number, arg1: K[]): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        sort(arg0: Internal.Comparator<K>): void
        removeElements(arg0: number, arg1: number): void
        removeIf(arg0: (arg0: K) => boolean): boolean
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(arg0: number): void
        size(): number
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        addAll(arg0: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean
        addAll(arg0: Internal.Collection<K>): boolean
        equals(arg0: any): boolean
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.ObjectListIterator<K>
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        unstableSort(arg0: Internal.Comparator<K>): void
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    abstract class BlockType {
        getClass(): Internal.Class<any>
        applyDefaults(builder: Internal.BlockBuilder): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        generateBlockModels(builder: Internal.BlockBuilder): Internal.Map<ResourceLocation, Internal.JsonObject>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        createBlock(arg0: Internal.BlockBuilder): Internal.Block
        generateData(builder: Internal.BlockBuilder, generator: Internal.DataJsonGenerator): void
        toString(): string
        generateAssets(b: Internal.BlockBuilder, generator: Internal.AssetJsonGenerator): void
        notify(): void
        readonly name : string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Field extends Internal.AccessibleObject implements Internal.Member {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setByte(arg0: any, arg1: number): void
        getByte(arg0: any): number
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        isSynthetic(): boolean
        getDouble(arg0: any): number
        setShort(arg0: any, arg1: number): void
        getFloat(arg0: any): number
        notify(): void
        getDeclaredAnnotations(): Internal.Annotation[]
        setDouble(arg0: any, arg1: number): void
        setChar(arg0: any, arg1: string): void
        getDeclaringClass(): Internal.Class<any>
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        hashCode(): number
        canAccess(arg0: any): boolean
        toGenericString(): string
        get(arg0: any): any
        getBoolean(arg0: any): boolean
        getGenericType(): Internal.Type
        getModifiers(): number
        getAnnotatedType(): Internal.AnnotatedType
        trySetAccessible(): boolean
        setFloat(arg0: any, arg1: number): void
        isAccessible(): boolean
        set(arg0: any, arg1: any): void
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        getShort(arg0: any): number
        getAnnotations(): Internal.Annotation[]
        setInt(arg0: any, arg1: number): void
        getLong(arg0: any): number
        getInt(arg0: any): number
        getChar(arg0: any): string
        setLong(arg0: any, arg1: number): void
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getType(): Internal.Class<any>
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        equals(arg0: any): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        toString(): string
        isEnumConstant(): boolean
        setBoolean(arg0: any, arg1: boolean): void
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get synthetic(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedType(): Internal.AnnotatedType;
        get enumConstant(): boolean;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get genericType(): Internal.Type;
        get modifiers(): number;
        get type(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BakedQuad implements Internal.IVertexProducer, Internal.BakedQuadAccessor, Internal.BakedQuadAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setVertices(arg0: number[]): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        pipe(arg0: Internal.IVertexConsumer): void
        notify(): void
        getSprite(): Internal.TextureAtlasSprite
        get sprite(): Internal.TextureAtlasSprite;
        get class(): Internal.Class<any>;
        set vertices(arg0: number[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AgeableListModel <E> extends Internal.EntityModel<any> implements Internal.AgeableModelAccessor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getBodyParts_vampirism(): Internal.Iterable<any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        get bodyParts_vampirism(): Internal.Iterable<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CollisionGetter extends Internal.BlockGetter {
    }
    class TeamType extends Internal.Enum<any> implements Internal.StringRepresentable {
        isPlayer(): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isServer(): boolean
        static valueOf(name: string): Internal.TeamType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.TeamType[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.TeamType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TeamType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.TeamType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        isParty(): boolean
        ordinal(): number
        static readonly PLAYER : Internal.TeamType;
        static readonly PARTY : Internal.TeamType;
        readonly factory : (arg0: Internal.TeamManager) => Internal.Team;
        static readonly SERVER : Internal.TeamType;
        static readonly VALUES : Internal.TeamType[];
        static readonly MAP : Internal.Map<string, Internal.TeamType>;
        get server(): boolean;
        get class(): Internal.Class<any>;
        get party(): boolean;
        get player(): boolean;
        get declaringClass(): Internal.Class<Internal.TeamType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongFunction <R> {
        apply(arg0: number): R
    }
    interface DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number
    }
    class DirectVertexConsumer implements Internal.VertexConsumer {
        getClass(): Internal.Class<any>
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        memSetZero(): void
        notifyAll(): void
        notify(): void
        hasOverlay(): boolean
        split(arg0: number): Internal.DirectVertexConsumer
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
        readonly format : Internal.VertexFormat;
        readonly startPos : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ColorSpace implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(arg0: number): string
        toCIEXYZ(arg0: number[]): number[]
        fromCIEXYZ(arg0: number[]): number[]
        toRGB(arg0: number[]): number[]
        getNumComponents(): number
        getMaxValue(arg0: number): number
        notifyAll(): void
        notify(): void
        fromRGB(arg0: number[]): number[]
        getMinValue(arg0: number): number
        isCS_sRGB(): boolean
        getType(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static getInstance(arg0: number): Internal.ColorSpace
        static readonly TYPE_ECLR : 24;
        static readonly TYPE_Lab : 1;
        static readonly TYPE_Luv : 2;
        static readonly TYPE_RGB : 5;
        static readonly TYPE_GRAY : 6;
        static readonly TYPE_CMY : 11;
        static readonly TYPE_CCLR : 22;
        static readonly TYPE_ACLR : 20;
        static readonly TYPE_HSV : 7;
        static readonly TYPE_YCbCr : 3;
        static readonly TYPE_7CLR : 17;
        static readonly CS_LINEAR_RGB : 1004;
        static readonly TYPE_9CLR : 19;
        static readonly TYPE_5CLR : 15;
        static readonly CS_sRGB : 1000;
        static readonly TYPE_3CLR : 13;
        static readonly CS_PYCC : 1002;
        static readonly TYPE_XYZ : 0;
        static readonly TYPE_FCLR : 25;
        static readonly TYPE_DCLR : 23;
        static readonly TYPE_HLS : 8;
        static readonly TYPE_CMYK : 9;
        static readonly TYPE_BCLR : 21;
        static readonly CS_GRAY : 1003;
        static readonly TYPE_8CLR : 18;
        static readonly TYPE_6CLR : 16;
        static readonly TYPE_4CLR : 14;
        static readonly TYPE_Yxy : 4;
        static readonly TYPE_2CLR : 12;
        static readonly CS_CIEXYZ : 1001;
        get cS_sRGB(): boolean;
        get type(): number;
        get class(): Internal.Class<any>;
        get numComponents(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DamageSource implements Internal.DamageSourceAccessor, Internal.AccessorDamageSource {
        getClass(): Internal.Class<any>
        botania_setBypassArmor(): Internal.DamageSource
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        static create_$md$204703$0(arg0: string): Internal.DamageSource
        notifyAll(): void
        equals(arg0: any): boolean
        callBypassArmor(): Internal.DamageSource
        callBypassMagic(): Internal.DamageSource
        toString(): string
        notify(): void
        callBypassInvul(): Internal.DamageSource
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Dimension extends Internal.Dimension2D implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getSize(): Internal.Dimension
        getHeight(): number
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        setSize(arg0: number, arg1: number): void
        setSize(arg0: Internal.Dimension2D): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        getWidth(): number
        notify(): void
        width : number;
        height : number;
        get size(): Internal.Dimension;
        get class(): Internal.Class<any>;
        set size(arg0: Internal.Dimension);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ListenerStatus extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        shouldRemove(): boolean
        static valueOf(arg0: string): Internal.ListenerStatus
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ListenerStatus[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ListenerStatus): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ListenerStatus>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ListenerStatus>
        hashCode(): number
        equals(arg0: any): boolean
        isOk(): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly OKAY : Internal.ListenerStatus;
        static readonly REMOVE : Internal.ListenerStatus;
        static readonly UPDATE : Internal.ListenerStatus;
        get ok(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ListenerStatus>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TemporalField {
        resolve(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.TemporalAccessor, arg2: Internal.ResolverStyle): Internal.TemporalAccessor
        rangeRefinedBy(arg0: Internal.TemporalAccessor): Internal.ValueRange
        getBaseUnit(): Internal.TemporalUnit
        getDisplayName(arg0: Internal.Locale): string
        isTimeBased(): boolean
        adjustInto<R>(arg0: R, arg1: number): R
        range(): Internal.ValueRange
        getRangeUnit(): Internal.TemporalUnit
        toString(): string
        isDateBased(): boolean
        getFrom(arg0: Internal.TemporalAccessor): number
        isSupportedBy(arg0: Internal.TemporalAccessor): boolean
    }
    interface Transferable {
        isDataFlavorSupported(arg0: Internal.DataFlavor): boolean
        getTransferData(arg0: Internal.DataFlavor): any
        getTransferDataFlavors(): Internal.DataFlavor[]
    }
    interface FlavorListener extends Internal.EventListener {
        flavorsChanged(arg0: Internal.FlavorEvent): void
    }
    class Module implements Internal.AnnotatedElement {
        getDescriptor(): Internal.ModuleDescriptor
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        canRead(arg0: Internal.Module): boolean
        notifyAll(): void
        addUses(arg0: Internal.Class<any>): Internal.Module
        getClassLoader(): Internal.ClassLoader
        isNamed(): boolean
        notify(): void
        getDeclaredAnnotations(): Internal.Annotation[]
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        hashCode(): number
        addReads(arg0: Internal.Module): Internal.Module
        getLayer(): Internal.ModuleLayer
        getResourceAsStream(arg0: string): Internal.InputStream
        addExports(arg0: string, arg1: Internal.Module): Internal.Module
        getAnnotations(): Internal.Annotation[]
        canUse(arg0: Internal.Class<any>): boolean
        isOpen(arg0: string): boolean
        isOpen(arg0: string, arg1: Internal.Module): boolean
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        equals(arg0: any): boolean
        isExported(arg0: string, arg1: Internal.Module): boolean
        isExported(arg0: string): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getPackages(): Internal.Set<string>
        toString(): string
        addOpens(arg0: string, arg1: Internal.Module): Internal.Module
        get declaredAnnotations(): Internal.Annotation[];
        get named(): boolean;
        get classLoader(): Internal.ClassLoader;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get descriptor(): Internal.ModuleDescriptor;
        get packages(): Internal.Set<string>;
        get class(): Internal.Class<any>;
        get layer(): Internal.ModuleLayer;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Text implements Internal.Iterable<Internal.Text>, Internal.Comparable<Internal.Text>, Internal.JsonSerializable, Internal.WrappedJS {
        getClass(): Internal.Class<any>
        rawCopy(): Internal.Text
        compareTo(arg0: any): number
        compareTo(other: Internal.Text): number
        hasStyle(): boolean
        italic(value: boolean): Internal.Text
        italic(): Internal.Text
        static componentOf(o: any): Internal.Component
        red(): Internal.Text
        aqua(): Internal.Text
        iterator(): Internal.Iterator<Internal.Text>
        white(): Internal.Text
        noColor(): Internal.Text
        darkPurple(): Internal.Text
        static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text
        write(buffer: Internal.FriendlyByteBuf): void
        obfuscated(): Internal.Text
        obfuscated(value: boolean): Internal.Text
        static read(buffer: Internal.FriendlyByteBuf): Internal.Text
        spliterator(): Internal.Spliterator<Internal.Text>
        getSiblings(): Internal.List<Internal.Text>
        bold(): Internal.Text
        bold(value: boolean): Internal.Text
        click(value: string): Internal.Text
        toJson(): Internal.JsonElement
        darkGray(): Internal.Text
        insertion(value: string): Internal.Text
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        color(c: Internal.Color): Internal.Text
        notifyAll(): void
        yellow(): Internal.Text
        darkBlue(): Internal.Text
        notify(): void
        gold(): Internal.Text
        hover(text: any): Internal.Text
        gray(): Internal.Text
        hashCode(): number
        darkRed(): Internal.Text
        static of(o: any): Internal.Text
        copy(): Internal.Text
        strikethrough(value: boolean): Internal.Text
        strikethrough(): Internal.Text
        rawComponent(): Internal.MutableComponent
        createStyleJson(): Internal.JsonObject
        green(): Internal.Text
        hasSiblings(): boolean
        darkGreen(): Internal.Text
        forEach(arg0: (arg0: Internal.Text) => void): void
        black(): Internal.Text
        lightPurple(): Internal.Text
        getString(): string
        getStyleAndSiblingJson(): Internal.JsonObject
        darkAqua(): Internal.Text
        component(): Internal.Component
        blue(): Internal.Text
        equals(obj: any): boolean
        underlined(): Internal.Text
        underlined(value: boolean): Internal.Text
        toString(): string
        append(sibling: any): Internal.Text
        createStyle(): Internal.Style
        font(value: string): Internal.Text
        get siblings(): Internal.List<Internal.Text>;
        get string(): string;
        get styleAndSiblingJson(): Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NonNullSupplier <T> {
        get(): T
    }
    interface Function14 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13, arg1: T14) => R>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function5<T10, T11, T12, T13, T14, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14): R
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14) => R>
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function7<T8, T9, T10, T11, T12, T13, T14, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function6<T9, T10, T11, T12, T13, T14, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function4<T11, T12, T13, T14, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function3<T12, T13, T14, R>>
        curry(): (arg0: T1) => Internal.Function13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function9<T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function8<T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function11<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function10<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function12<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>
    }
    abstract class GraphicsConfiguration {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getColorModel(arg0: number): Internal.ColorModel
        getColorModel(): Internal.ColorModel
        getNormalizingTransform(): Internal.AffineTransform
        notifyAll(): void
        getDefaultTransform(): Internal.AffineTransform
        isTranslucencyCapable(): boolean
        notify(): void
        getBounds(): Internal.Rectangle
        getDevice(): Internal.GraphicsDevice
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities, arg3: number): Internal.VolatileImage
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities): Internal.VolatileImage
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: number): Internal.VolatileImage
        createCompatibleVolatileImage(arg0: number, arg1: number): Internal.VolatileImage
        hashCode(): number
        getImageCapabilities(): Internal.ImageCapabilities
        equals(arg0: any): boolean
        createCompatibleImage(arg0: number, arg1: number): Internal.BufferedImage
        createCompatibleImage(arg0: number, arg1: number, arg2: number): Internal.BufferedImage
        getBufferCapabilities(): Internal.BufferCapabilities
        toString(): string
        get normalizingTransform(): Internal.AffineTransform;
        get translucencyCapable(): boolean;
        get defaultTransform(): Internal.AffineTransform;
        get bounds(): Internal.Rectangle;
        get colorModel(): Internal.ColorModel;
        get imageCapabilities(): Internal.ImageCapabilities;
        get bufferCapabilities(): Internal.BufferCapabilities;
        get class(): Internal.Class<any>;
        get device(): Internal.GraphicsDevice;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DependencyRequirement extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.DependencyRequirement
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.DependencyRequirement[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DependencyRequirement): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DependencyRequirement>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.DependencyRequirement>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly ONE_STARTED : Internal.DependencyRequirement;
        static readonly ALL_STARTED : Internal.DependencyRequirement;
        static readonly NAME_MAP : Internal.NameMap<Internal.DependencyRequirement>;
        readonly one : boolean;
        readonly id : string;
        readonly completed : boolean;
        static readonly ALL_COMPLETED : Internal.DependencyRequirement;
        static readonly ONE_COMPLETED : Internal.DependencyRequirement;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DependencyRequirement>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MixerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Reward extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>
        getMutableTitle(): Internal.MutableComponent
        isTeamReward(): boolean
        getTags(): Internal.Set<string>
        automatedClaimPre(tileEntity: Internal.BlockEntity, items: Internal.List<Internal.ItemStack>, random: Internal.Random, playerId: Internal.UUID, player: Internal.ServerPlayer): boolean
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getTitle(): Internal.Component
        getPath(): string
        claim(arg0: Internal.ServerPlayer, arg1: boolean): void
        clearCachedData(): void
        static parseCodeString(id: string): number
        editedFromGUI(): void
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        static getID(object: Internal.QuestObjectBase): number
        onEditButtonClicked(gui: Internal.Runnable): void
        addMouseOverText(list: Internal.TooltipList): void
        getIngredient(): any
        getType(): Internal.RewardType
        getAltTitle(): Internal.Component
        automatedClaimPost(tileEntity: Internal.BlockEntity, playerId: Internal.UUID, player: Internal.ServerPlayer): void
        onButtonClicked(button: Internal.Button, canClick: boolean): void
        deleteSelf(): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addTitleInMouseOverText(): boolean
        getExcludeFromClaimAll(): boolean
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        notify(): void
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        getAutoClaimType(): Internal.RewardAutoClaim
        getParentID(): number
        refreshJEI(): number
        getQuestChapter(): Internal.Chapter
        getQuestFile(): Internal.QuestFile
        getButtonText(): string
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        claimAutomated(tileEntity: Internal.BlockEntity, playerId: Internal.UUID, player: Internal.ServerPlayer, simulate: boolean): Internal.Optional<Internal.ItemStack>
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        autoclaim : Internal.RewardAutoClaim;
        invalid : boolean;
        icon : Internal.ItemStack;
        team : Internal.Tristate;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        quest : Internal.Quest;
        get buttonText(): string;
        get ingredient(): any;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get type(): Internal.RewardType;
        get excludeFromClaimAll(): boolean;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get autoClaimType(): Internal.RewardAutoClaim;
        get path(): string;
        get teamReward(): boolean;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SawmillRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        hasStripped : boolean;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        stripping : Internal.List<boolean>;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectIterable <K> extends Internal.Iterable<K> {
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: K) => void): void
    }
    interface ObjIntConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    interface MenuAccess <T> {
    }
    interface StyleAccess {
    }
    class DefaultedRegistry <T> extends Internal.MappedRegistry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        hashCode(): number
        keys<U_>(arg0: Internal.DynamicOps<U_>): Internal.Stream<U_>
        notifyAll(): void
        equals(arg0: any): boolean
        static invokeRegisterSimple_$md$204703$1(arg0: Internal.ResourceKey<any>, arg1: () => any)): Internal.Registry<any>
        static callRegisterDefaulted_$md$204703$0(arg0: Internal.ResourceKey<any>, arg1: string, arg2: () => any)): Internal.DefaultedRegistry<any>
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootBuilderPool implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        survivesExplosion(): Internal.ConditionContainer
        notifyAll(): void
        addEmpty(weight: number): Internal.LootTableEntry
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(o: Internal.JsonObject): Internal.LootBuilderPool
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        addTag(tag: string, expand: boolean): Internal.LootTableEntry
        notify(): void
        addItem(item: Internal.ItemStack, weight: number, count: Internal.NumberProvider): Internal.LootTableEntry
        addItem(item: Internal.ItemStack, weight: number): Internal.LootTableEntry
        addItem(item: Internal.ItemStack): Internal.LootTableEntry
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        setBinomialRolls(n: number, p: number): void
        hashCode(): number
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootBuilderPool
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        setUniformRolls(min: number, max: number): void
        toJson(): Internal.JsonObject
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        addEntry(json: Internal.JsonObject): Internal.LootTableEntry
        equals(arg0: any): boolean
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        addLootTable(table: ResourceLocation): Internal.LootTableEntry
        toString(): string
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        readonly entries : Internal.JsonArray;
        readonly functions : Internal.JsonArray;
        rolls : Internal.NumberProvider;
        readonly conditions : Internal.JsonArray;
        bonusRolls : Internal.NumberProvider;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DisplayEffectScreenAccessor {
        isCancelShift(): boolean
    }
    interface AttributeSet {
        getResolveParent(): Internal.AttributeSet
        getAttribute(arg0: any): any
        getAttributeNames(): Internal.Enumeration<any>
        containsAttributes(arg0: Internal.AttributeSet): boolean
        isEqual(arg0: Internal.AttributeSet): boolean
        isDefined(arg0: any): boolean
        containsAttribute(arg0: any, arg1: any): boolean
        copyAttributes(): Internal.AttributeSet
        getAttributeCount(): number
    }
    interface Float2LongFunction extends Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IVertexProducer {
        pipe(arg0: Internal.IVertexConsumer): void
    }
    class Collector$Characteristics extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Collector$Characteristics
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Collector$Characteristics[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Collector$Characteristics): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Collector$Characteristics>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Collector$Characteristics>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly IDENTITY_FINISH : Internal.Collector$Characteristics;
        static readonly UNORDERED : Internal.Collector$Characteristics;
        static readonly CONCURRENT : Internal.Collector$Characteristics;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Collector$Characteristics>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockPredicate {
        check(arg0: Internal.BlockContainerJS): boolean
    }
    class ServerLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        getPlayerData(player: Internal.Player): Internal.ServerPlayerDataJS
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void
        getTime(): number
        notifyAll(): void
        getSide(): Internal.ScriptType
        getGameRules(): Internal.GameRulesJS
        notify(): void
        setRainStrength(strength: number): void
        hashCode(): number
        getDimension(): string
        isDaytime(): boolean
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        setTime(time: number): void
        getMinecraftLevel(): Internal.ServerLevel
        getMinecraftLevel(): net.minecraft.world.level.Level
        getServer(): Internal.ServerJS
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS
        getBlock(pos: BlockPos): Internal.BlockContainerJS
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS
        getSeed(): number
        isOverworld(): boolean
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS
        getEntity(e: Internal.Entity): Internal.EntityJS
        createEntity(id: ResourceLocation): Internal.EntityJS
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void
        getLocalTime(): number
        equals(arg0: any): boolean
        isThundering(): boolean
        getEntities(filter: string): Internal.EntityArrayList
        getEntities(): Internal.EntityArrayList
        toString(): string
        isRaining(): boolean
        setLocalTime(time: number): void
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get seed(): number;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set localTime(time: number);
        set time(time: number);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ActionListener extends Internal.EventListener {
        actionPerformed(arg0: Internal.ActionEvent): void
    }
    class WorldBorder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Biome$BiomeCategory extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Biome$BiomeCategory
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Biome$BiomeCategory[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Biome$BiomeCategory): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Biome$BiomeCategory>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Biome$BiomeCategory>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly BEACH : Internal.Biome$BiomeCategory;
        static readonly UNDERGROUND : Internal.Biome$BiomeCategory;
        static readonly MESA : Internal.Biome$BiomeCategory;
        static readonly SAVANNA : Internal.Biome$BiomeCategory;
        static readonly THEEND : Internal.Biome$BiomeCategory;
        static readonly JUNGLE : Internal.Biome$BiomeCategory;
        static readonly OCEAN : Internal.Biome$BiomeCategory;
        static readonly TAIGA : Internal.Biome$BiomeCategory;
        static readonly MOUNTAIN : Internal.Biome$BiomeCategory;
        static readonly DESERT : Internal.Biome$BiomeCategory;
        static readonly RIVER : Internal.Biome$BiomeCategory;
        static readonly FOREST : Internal.Biome$BiomeCategory;
        static readonly MUSHROOM : Internal.Biome$BiomeCategory;
        static readonly NETHER : Internal.Biome$BiomeCategory;
        static readonly PLAINS : Internal.Biome$BiomeCategory;
        static readonly SWAMP : Internal.Biome$BiomeCategory;
        static readonly NONE : Internal.Biome$BiomeCategory;
        static readonly EXTREME_HILLS : Internal.Biome$BiomeCategory;
        static readonly ICY : Internal.Biome$BiomeCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Biome$BiomeCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Thread$UncaughtExceptionHandler {
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void
    }
    interface RandomAccess {
    }
    class MaterialJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getMinecraftMaterial(): Internal.Material
        toString(): string
        getId(): string
        notify(): void
        getSound(): Internal.SoundType
        get minecraftMaterial(): Internal.Material;
        get sound(): Internal.SoundType;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelHeightAccessor {
    }
    class NamedPackage {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableCollection <E> extends Internal.AbstractCollection<any> implements Internal.Serializable {
        add(arg0: E): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        notifyAll(): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        notify(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ColorModel implements Internal.Transparency {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getNumColorComponents(): number
        notifyAll(): void
        coerceData(arg0: Internal.WritableRaster, arg1: boolean): Internal.ColorModel
        notify(): void
        getAlpha(arg0: any): number
        getAlpha(arg0: number): number
        getUnnormalizedComponents(arg0: number[], arg1: number, arg2: number[], arg3: number): number[]
        getDataElement(arg0: number[], arg1: number): number
        getDataElement(arg0: number[], arg1: number): number
        getRed(arg0: number): number
        getRed(arg0: any): number
        getTransferType(): number
        hashCode(): number
        createCompatibleSampleModel(arg0: number, arg1: number): Internal.SampleModel
        getComponents(arg0: any, arg1: number[], arg2: number): number[]
        getComponents(arg0: number, arg1: number[], arg2: number): number[]
        static getRGBdefault(): Internal.ColorModel
        getAlphaRaster(arg0: Internal.WritableRaster): Internal.WritableRaster
        hasAlpha(): boolean
        getRGB(arg0: any): number
        getRGB(arg0: number): number
        isCompatibleSampleModel(arg0: Internal.SampleModel): boolean
        getNumComponents(): number
        getPixelSize(): number
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster
        getColorSpace(): Internal.ColorSpace
        getBlue(arg0: number): number
        getBlue(arg0: any): number
        isAlphaPremultiplied(): boolean
        getTransparency(): number
        getNormalizedComponents(arg0: any, arg1: number[], arg2: number): number[]
        getNormalizedComponents(arg0: number[], arg1: number, arg2: number[], arg3: number): number[]
        getGreen(arg0: number): number
        getGreen(arg0: any): number
        equals(arg0: any): boolean
        getDataElements(arg0: number, arg1: any): any
        getDataElements(arg0: number[], arg1: number, arg2: any): any
        getDataElements(arg0: number[], arg1: number, arg2: any): any
        toString(): string
        finalize(): void
        isCompatibleRaster(arg0: Internal.Raster): boolean
        getComponentSize(arg0: number): number
        getComponentSize(): number[]
        static readonly OPAQUE : 1;
        static readonly TRANSLUCENT : 3;
        static readonly BITMASK : 2;
        get colorSpace(): Internal.ColorSpace;
        get rGBdefault(): Internal.ColorModel;
        get alphaPremultiplied(): boolean;
        get transparency(): number;
        get transferType(): number;
        get componentSize(): number[];
        get numColorComponents(): number;
        get class(): Internal.Class<any>;
        get pixelSize(): number;
        get numComponents(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ForgeAccessorModelBakery {
        getResourceManager(): Internal.ResourceManager
    }
    class InputConstants$Key implements Internal.AccessInputConstantsKey {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static getNAME_MAP_$md$204703$0(): Internal.Map<any, any>
        notify(): void
        get nAME_MAP_$md$204703$0(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockableEventLoop <R> implements Internal.ProfilerMeasured, Internal.ProcessorHandle<R>, Internal.Executor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        execute(arg0: Internal.Runnable): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2ReferenceFunction <V> extends Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: string, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: string) => V_
        put(arg0: any, arg1: any): any
        put(arg0: string, arg1: V): V
        put(arg0: string, arg1: V): V
        remove(arg0: string): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: string): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: string): V
        containsKey(arg0: any): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class Period implements Internal.ChronoPeriod, Internal.Serializable {
        getClass(): Internal.Class<any>
        minus(arg0: Internal.TemporalAmount): Internal.Period
        minus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        negated(): Internal.Period
        negated(): Internal.ChronoPeriod
        normalized(): Internal.ChronoPeriod
        normalized(): Internal.Period
        notifyAll(): void
        static ofYears(arg0: number): Internal.Period
        notify(): void
        getMonths(): number
        plusDays(arg0: number): Internal.Period
        multipliedBy(arg0: number): Internal.ChronoPeriod
        multipliedBy(arg0: number): Internal.Period
        hashCode(): number
        getYears(): number
        static of(arg0: number, arg1: number, arg2: number): Internal.Period
        get(arg0: Internal.TemporalUnit): number
        isZero(): boolean
        static from(arg0: Internal.TemporalAmount): Internal.Period
        withDays(arg0: number): Internal.Period
        getChronology(): Internal.IsoChronology
        getChronology(): Internal.Chronology
        static between(arg0: Internal.LocalDate, arg1: Internal.LocalDate): Internal.Period
        isNegative(): boolean
        withMonths(arg0: number): Internal.Period
        minusYears(arg0: number): Internal.Period
        plusMonths(arg0: number): Internal.Period
        plusYears(arg0: number): Internal.Period
        static ofDays(arg0: number): Internal.Period
        static parse(arg0: Internal.CharSequence): Internal.Period
        plus(arg0: Internal.TemporalAmount): Internal.Period
        plus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        toTotalMonths(): number
        minusDays(arg0: number): Internal.Period
        minusMonths(arg0: number): Internal.Period
        getDays(): number
        static ofWeeks(arg0: number): Internal.Period
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        equals(arg0: any): boolean
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        static ofMonths(arg0: number): Internal.Period
        toString(): string
        withYears(arg0: number): Internal.Period
        static readonly ZERO : Internal.Period;
        get zero(): boolean;
        get negative(): boolean;
        get months(): number;
        get chronology(): Internal.Chronology;
        get days(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
        get class(): Internal.Class<any>;
        get years(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootContext$Builder {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScrollBar extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        setCanAlwaysScrollPlane(v: boolean): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        getGui(): Internal.BaseScreen
        canMouseScroll(): boolean
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        updateMouseOver(mouseX: number, mouseY: number): void
        getScrollStep(): number
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        onClosed(): void
        isMouseOver(): boolean
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        openGui(): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        getMappedValue(max: number): number
        tick(): void
        setHeight(v: number): void
        setMaxValue(max: number): void
        addMouseOverText(list: Internal.TooltipList): void
        canMouseScrollPlane(): boolean
        showValueOnMouseOver(): boolean
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        getScrollBarSize(): number
        setMinValue(min: number): void
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        getMaxValue(): number
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        drawScrollBar(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        closeContextMenu(): void
        notify(): void
        mouseReleased(button: Internal.MouseButton): void
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        setCanAlwaysScroll(v: boolean): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        setScrollStep(s: number): void
        getWidgetType(): Internal.WidgetType
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        onMoved(): void
        getValue(): number
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getMinValue(): number
        getY(): number
        equals(arg0: any): boolean
        setValue(v: number): void
        toString(): string
        getIngredientUnderMouse(): any
        readonly plane : Internal.ScrollBar$Plane;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get maxValue(): number;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get scrollBarSize(): number;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get minValue(): number;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get value(): number;
        get partialTicks(): number;
        set canAlwaysScroll(v: boolean);
        set canAlwaysScrollPlane(v: boolean);
        set minValue(min: number);
        set clipboardString(string: string);
        set maxValue(max: number);
        set x(v: number);
        set y(v: number);
        set scrollStep(s: number);
        set value(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BakedModel extends Internal.IForgeBakedModel {
        doesHandlePerspectives(): boolean
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData
        isLayered(): boolean
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>
        useAmbientOcclusion(arg0: Internal.BlockState): boolean
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite
    }
    interface Reference2ObjectFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        get(arg0: any): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): V
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface LongStream$LongMapMultiConsumer {
        accept(arg0: number, arg1: Internal.LongConsumer): void
    }
    class MobSpawnSettings$SpawnerData extends Internal.WeightedEntry$IntrusiveBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DragSourceContext implements Internal.DragSourceListener, Internal.DragSourceMotionListener, Internal.Serializable {
        removeDragSourceListener(arg0: Internal.DragSourceListener): void
        getClass(): Internal.Class<any>
        getCursor(): Internal.Cursor
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getTrigger(): Internal.DragGestureEvent
        dragEnter(arg0: Internal.DragSourceDragEvent): void
        notifyAll(): void
        dragDropEnd(arg0: Internal.DragSourceDropEvent): void
        transferablesFlavorsChanged(): void
        dropActionChanged(arg0: Internal.DragSourceDragEvent): void
        notify(): void
        getSourceActions(): number
        addDragSourceListener(arg0: Internal.DragSourceListener): void
        getTransferable(): Internal.Transferable
        dragMouseMoved(arg0: Internal.DragSourceDragEvent): void
        hashCode(): number
        getDragSource(): Internal.DragSource
        equals(arg0: any): boolean
        toString(): string
        setCursor(arg0: Internal.Cursor): void
        dragOver(arg0: Internal.DragSourceDragEvent): void
        getComponent(): java_.awt.Component
        dragExit(arg0: Internal.DragSourceEvent): void
        get cursor(): Internal.Cursor;
        get sourceActions(): number;
        get component(): java_.awt.Component;
        get transferable(): Internal.Transferable;
        get trigger(): Internal.DragGestureEvent;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        set cursor(arg0: Internal.Cursor);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ListenerList {
        getListeners(arg0: number): Internal.IEventListener[]
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static clearBusID(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        unregister(arg0: number, arg1: Internal.IEventListener): void
        toString(): string
        static unregisterAll(arg0: number, arg1: Internal.IEventListener): void
        notify(): void
        register(arg0: number, arg1: Internal.EventPriority, arg2: Internal.IEventListener): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ToLongFunction <T> {
        applyAsLong(arg0: T): number
    }
    class DragSourceDragEvent extends Internal.DragSourceEvent {
        getDropAction(): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        getTargetActions(): number
        notifyAll(): void
        getGestureModifiersEx(): number
        notify(): void
        getX(): number
        getY(): number
        hashCode(): number
        getSource(): any
        getDragSourceContext(): Internal.DragSourceContext
        equals(arg0: any): boolean
        getUserAction(): number
        getGestureModifiers(): number
        toString(): string
        get userAction(): number;
        get gestureModifiers(): number;
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        get gestureModifiersEx(): number;
        get dropAction(): number;
        get targetActions(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ToolAction {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get(arg0: string): Internal.ToolAction
        name(): string
        static getActions(): Internal.Collection<Internal.ToolAction>
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        get actions(): Internal.Collection<Internal.ToolAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DamageSourceJS {
        getClass(): Internal.Class<any>
        getLevel(): Internal.LevelJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getActual(): Internal.EntityJS
        getPlayer(): Internal.PlayerJS<any>
        getType(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getImmediate(): Internal.EntityJS
        toString(): string
        notify(): void
        readonly source : Internal.DamageSource;
        get actual(): Internal.EntityJS;
        get level(): Internal.LevelJS;
        get immediate(): Internal.EntityJS;
        get type(): string;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FieldAttributes {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        notifyAll(): void
        getDeclaredClass(): Internal.Class<any>
        getAnnotations(): Internal.Collection<Internal.Annotation>
        notify(): void
        getDeclaringClass(): Internal.Class<any>
        getAnnotation<T>(arg0: Internal.Class<T>): T
        hasModifier(arg0: number): boolean
        hashCode(): number
        equals(arg0: any): boolean
        getDeclaredType(): Internal.Type
        toString(): string
        get name(): string;
        get annotations(): Internal.Collection<Internal.Annotation>;
        get declaredType(): Internal.Type;
        get declaredClass(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function9 <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8, arg1: T9) => R>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function4<T6, T7, T8, T9, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function3<T7, T8, T9, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function6<T4, T5, T6, T7, T8, T9, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function5<T5, T6, T7, T8, T9, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function7<T3, T4, T5, T6, T7, T8, T9, R>
        curry(): (arg0: T1) => Internal.Function8<T2, T3, T4, T5, T6, T7, T8, T9, R>
    }
    class ItemStack extends Internal.CapabilityProvider<any> implements Internal.IForgeItemStack, Internal.ItemFiltersStack, Internal.ItemStackKJS {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.LivingEntity): boolean
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        createDataIF(item: Internal.Item): any
        canPerformAction(arg0: Internal.ToolAction): boolean
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean
        getItemEnchantability(): number
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): Internal.Tag
        invalidateCaps(): void
        getInventoryFilterData(): Internal.ItemInventory
        getXpRepairRatio(): number
        readShareTag(arg0: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean
        isBookEnchantable(arg0: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.ItemStack>): boolean
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void
        isPiglinCurrency(): boolean
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB
        reviveCaps(): void
        isRepairable(): boolean
        getShareTag(): Internal.CompoundTag
        getBurnTime(arg0: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.Player): boolean
        onEntitySwing(arg0: Internal.LivingEntity): boolean
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean
        areShareTagsEqual(arg0: Internal.ItemStack): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean
        notifyAll(): void
        notify(): void
        getStringValueFilterData(): Internal.StringValueData<any>
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean
        onHorseArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Mob): void
        getEntityLifespan(arg0: net.minecraft.world.level.Level): number
        hashCode(): number
        getHighlightTip(arg0: Internal.Component): Internal.Component
        removeTagKJS(): void
        onArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Player): void
        hasContainerItem(): boolean
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(): Internal.ItemStack
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        getItemFiltersData(): any
        asKJS(): any
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        getEquipmentSlot(): EquipmentSlot
        equals(arg0: any): boolean
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean
        get shareTag(): Internal.CompoundTag;
        get repairable(): boolean;
        get inventoryFilterData(): Internal.ItemInventory;
        get stringValueFilterData(): Internal.StringValueData<any>;
        get itemFiltersData(): any;
        get itemEnchantability(): number;
        get equipmentSlot(): EquipmentSlot;
        get piglinCurrency(): boolean;
        get containerItem(): Internal.ItemStack;
        get class(): Internal.Class<any>;
        get xpRepairRatio(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor$OfField <F> extends Internal.TypeDescriptor {
        componentType(): F
        arrayType(): F
        descriptorString(): string
        isArray(): boolean
        isPrimitive(): boolean
    }
    class ContextMenuItem implements Internal.Comparable<Internal.ContextMenuItem> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setYesNo(s: Internal.Component): Internal.ContextMenuItem
        notifyAll(): void
        compareTo(o: Internal.ContextMenuItem): number
        compareTo(arg0: any): number
        drawIcon(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        notify(): void
        setCloseMenu(v: boolean): Internal.ContextMenuItem
        setEnabled(v: Internal.BooleanSupplier): Internal.ContextMenuItem
        setEnabled(v: boolean): Internal.ContextMenuItem
        addMouseOverText(list: Internal.TooltipList): void
        hashCode(): number
        equals(arg0: any): boolean
        onClicked(panel: Internal.Panel, button: Internal.MouseButton): void
        toString(): string
        createWidget(panel: Internal.ContextMenu): dev.ftb.mods.ftblibrary.ui.Widget
        static readonly SEPARATOR : Internal.ContextMenuItem;
        icon : Internal.Icon;
        static readonly TRUE : Internal.BooleanSupplier;
        callback : Internal.Runnable;
        static readonly FALSE : Internal.BooleanSupplier;
        title : Internal.Component;
        yesNoText : Internal.Component;
        closeMenu : boolean;
        enabled : Internal.BooleanSupplier;
        get class(): Internal.Class<any>;
        set yesNo(s: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableList <E> extends Internal.ImmutableCollection<any> implements Internal.List<E>, Internal.RandomAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: number): E
        remove(arg0: any): boolean
        static sortedCopyOf<E_>(arg0: Internal.Comparator<E_>, arg1: Internal.Iterable<E_>): Internal.ImmutableList<E_>
        static sortedCopyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableList<E_>
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.UnmodifiableIterator<E>
        iterator(): Internal.Iterator<any>
        stream(): Internal.Stream<E>
        hashCode(): number
        get(arg0: number): E
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_): Internal.ImmutableList<E_>
        static of<E_>(): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_, arg11: E_, arg12: E_[]): Internal.ImmutableList<E_>
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_): Internal.ImmutableList<E_>
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        static builder<E_>(): Internal.ImmutableList$Builder<E_>
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<any>
        subList(arg0: number, arg1: number): Internal.ImmutableList<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        reverse(): Internal.ImmutableList<E>
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableList<E_>
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableList<E_>
        static copyOf<E_>(arg0: Internal.Collection<E_>): Internal.ImmutableList<E_>
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableList<E_>
        removeIf(arg0: (arg0: E) => boolean): boolean
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableList$Builder<E_>
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: any): boolean
        static toImmutableList<E_>(): Internal.Collector<E_, any, Internal.ImmutableList<E_>>
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.UnmodifiableListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.UnmodifiableListIterator<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NativeContinuation extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable
        getAllIds(): any[]
        put(name: string, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        hasPrototypeMap(): boolean
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getExternalArrayLength(): any
        static init(cx: Internal.Context, scope: Internal.Scriptable, sealed: boolean): void
        getAttributes(key: Internal.Symbol): number
        getAttributes(name: string): number
        getAttributes(index: number): number
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: any): any
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void
        static equalImplementations(c1: Internal.NativeContinuation, c2: Internal.NativeContinuation): boolean
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getClassName(): string
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        getImplementation(): any
        notifyAll(): void
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        initImplementation(implementation: any): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        hashCode(): number
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        activatePrototypeMap(maxPrototypeId: number): void
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static isContinuationConstructor(f: Internal.IdFunctionObject): boolean
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get implementation(): any;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P12 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P13 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ModuleReader extends Internal.Closeable {
        read(arg0: string): Internal.Optional<Internal.ByteBuffer>
        release(arg0: Internal.ByteBuffer): void
        find(arg0: string): Internal.Optional<Internal.URI>
        list(): Internal.Stream<string>
        close(): void
        open(arg0: string): Internal.Optional<Internal.InputStream>
    }
    class RecordItem extends Internal.Item {
        getClass(): Internal.Class<any>
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        bookshelf$setCraftingRemainder(arg0: Internal.Item): void
        onEnchantment(arg0: Internal.ItemStack, arg1: Internal.List<Internal.EnchantmentInstance>): Internal.ItemStack
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        isTreasureAllowed(arg0: Internal.ItemStack, arg1: boolean): boolean
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        setCategory(arg0: Internal.CreativeModeTab): void
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        getCategory(): Internal.CreativeModeTab
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        isDamageable(arg0: Internal.ItemStack): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getRegistryType(): Internal.Class<Internal.Item>
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        selectEnchantments(arg0: Internal.List<Internal.EnchantmentInstance>, arg1: Internal.Random, arg2: Internal.ItemStack, arg3: number, arg4: number, arg5: number, arg6: boolean): Internal.List<Internal.EnchantmentInstance>
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<net.minecraft.world.entity.ai.attributes.Attribute, Internal.AttributeModifier>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        handler$bef000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab): void
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        notifyAll(): void
        getId(): string
        notify(): void
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number
        getRenderPropertiesInternal(): any
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hashCode(): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.Item
        setRegistryName(arg0: string): Internal.Item
        setRegistryName(arg0: string, arg1: string): Internal.Item
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        handler$bef000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        getItemStackLimit(arg0: Internal.ItemStack): number
        equals(arg0: any): boolean
        forciblyAllowsTableEnchantment(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        set craftingRemainingItemFTBL(arg0: Internal.Item);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IntOpenHashSet extends Internal.AbstractIntSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        notify(): void
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        trim(): boolean
        trim(arg0: number): boolean
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        static of(): Internal.IntOpenHashSet
        static of(arg0: number[]): Internal.IntOpenHashSet
        static of(arg0: number, arg1: number, arg2: number): Internal.IntOpenHashSet
        static of(arg0: number, arg1: number): Internal.IntOpenHashSet
        static of(arg0: number): Internal.IntOpenHashSet
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.IntCollection): boolean
        isEmpty(): boolean
        clear(): void
        static toSetWithExpectedSize(arg0: Internal.IntStream, arg1: number): Internal.IntOpenHashSet
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.IntPredicate): boolean
        static toSet(arg0: Internal.IntStream): Internal.IntOpenHashSet
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        clone(): any
        clone(): Internal.IntOpenHashSet
        toString(): string
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.IntCollection): boolean
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ZoneOffsetTransition implements Internal.Comparable<Internal.ZoneOffsetTransition>, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDateTimeAfter(): Internal.LocalDateTime
        notifyAll(): void
        getDateTimeBefore(): Internal.LocalDateTime
        getOffsetBefore(): Internal.ZoneOffset
        getOffsetAfter(): Internal.ZoneOffset
        compareTo(arg0: Internal.ZoneOffsetTransition): number
        compareTo(arg0: any): number
        notify(): void
        getInstant(): Internal.Instant
        isGap(): boolean
        getDuration(): Internal.Duration
        toEpochSecond(): number
        hashCode(): number
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneOffset): Internal.ZoneOffsetTransition
        equals(arg0: any): boolean
        isOverlap(): boolean
        toString(): string
        isValidOffset(arg0: Internal.ZoneOffset): boolean
        get duration(): Internal.Duration;
        get overlap(): boolean;
        get gap(): boolean;
        get dateTimeBefore(): Internal.LocalDateTime;
        get offsetAfter(): Internal.ZoneOffset;
        get dateTimeAfter(): Internal.LocalDateTime;
        get class(): Internal.Class<any>;
        get offsetBefore(): Internal.ZoneOffset;
        get instant(): Internal.Instant;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(arg0: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DropTargetContext implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getComponent(): java_.awt.Component
        getDropTarget(): Internal.DropTarget
        dropComplete(arg0: boolean): void
        notify(): void
        get component(): java_.awt.Component;
        get dropTarget(): Internal.DropTarget;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockStateLightInfo {
        getExtrudedFaces(): Internal.VoxelShape[]
        getLightSubtracted(): number
    }
    interface WritableByteChannel extends Internal.Channel {
        isOpen(): boolean
        close(): void
        write(arg0: Internal.ByteBuffer): number
    }
    class VillagerProfession extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.VillagerProfession>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.VillagerProfession
        setRegistryName(arg0: string): Internal.VillagerProfession
        setRegistryName(arg0: string, arg1: string): Internal.VillagerProfession
        toString(): string
        notify(): void
        readonly delegate : () => Internal.VillagerProfession;
        get registryType(): Internal.Class<Internal.VillagerProfession>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MobSpawnInfoAccess {
        getSpawners(): Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>
        getMobSpawnCosts(): Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>
    }
    abstract class URLStreamHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleOptions {
    }
    class JobAttributes$MultipleDocumentHandlingType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly SEPARATE_DOCUMENTS_COLLATED_COPIES : Internal.JobAttributes$MultipleDocumentHandlingType;
        static readonly SEPARATE_DOCUMENTS_UNCOLLATED_COPIES : Internal.JobAttributes$MultipleDocumentHandlingType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InputContext {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        dispatchEvent(arg0: Internal.AWTEvent): void
        notifyAll(): void
        reconvert(): void
        getInputMethodControlObject(): any
        notify(): void
        isCompositionEnabled(): boolean
        setCharacterSubsets(arg0: any[]): void
        endComposition(): void
        setCompositionEnabled(arg0: boolean): void
        hashCode(): number
        equals(arg0: any): boolean
        removeNotify(arg0: java_.awt.Component): void
        toString(): string
        dispose(): void
        static getInstance(): Internal.InputContext
        selectInputMethod(arg0: Internal.Locale): boolean
        getLocale(): Internal.Locale
        get inputMethodControlObject(): any;
        get compositionEnabled(): boolean;
        get instance(): Internal.InputContext;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        set compositionEnabled(arg0: boolean);
        set characterSubsets(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientLevel extends net.minecraft.world.level.Level implements Internal.ClientLevelExtension {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$bmf000$onDisconnect(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        notifyAll(): void
        redirect$bnp000$getRedstonePowerAsCallFromNeighbours(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction): number
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void
        notify(): void
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void
        handler$bnp000$updateComparatorOutputLevel(arg0: BlockPos, arg1: Internal.Block, arg2: Internal.CallbackInfo): void
        invalidateCaps(): void
        getLunarContext(): Internal.LunarContext
        hashCode(): number
        increaseMaxEntityRadius(arg0: number): number
        handler$zom000$addFreshBlockEntities_HammerLib(arg0: Internal.Collection<any>, arg1: Internal.CallbackInfo): void
        close(): void
        unloadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        flywheel$getAllLoadedEntities(): Internal.Iterable<any>
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean
        handler$zom000$tickBlockEntities_HammerLib(arg0: Internal.CallbackInfo): void
        loadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        getMaxEntityRadius(): number
        asKJS(): any
        reviveCaps(): void
        getLoadedBlockEntities_HammerLib(): Internal.List<any>
        equals(arg0: any): boolean
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
        toString(): string
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext
        redirect$bbn000$redirectTick(blockEntity: Internal.TickingBlockEntity): void
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        get loadedBlockEntities_HammerLib(): Internal.List<any>;
        set lunarContext(arg0: Internal.LunarContext);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodHandleDesc extends Internal.ConstantDesc {
        invocationType(): Internal.MethodTypeDesc
        equals(arg0: any): boolean
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc
    }
    class WeightedEntry$IntrusiveBase implements Internal.WeightedEntry {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiFunction <T, U, R> {
        apply(arg0: T, arg1: U): R
        andThen<V>(arg0: (arg0: R) => V): (arg0: T, arg1: U) => V
    }
    interface Int2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface TransformStack extends Internal.Transform<Internal.TransformStack>, Internal.TStack<Internal.TransformStack> {
        rotate(arg0: Internal.Direction, arg1: number): Internal.TransformStack
        rotate(arg0: number, arg1: (arg0: any) => boolean): Internal.TransformStack
        translateAll(arg0: number): Internal.TransformStack
        scale(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        scale(arg0: number): Internal.TransformStack
        translate(arg0: Internal.Vector3f): Internal.TransformStack
        translate(arg0: Vec3): Internal.TransformStack
        translate(arg0: Vec3i): Internal.TransformStack
        translate(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        translateZ(arg0: number): Internal.TransformStack
        pushPose(): Internal.TransformStack
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Internal.TransformStack
        transform(arg0: Internal.PoseStack): Internal.TransformStack
        mulNormal(arg0: Internal.Matrix3f): Internal.TransformStack
        translateY(arg0: number): Internal.TransformStack
        translateX(arg0: number): Internal.TransformStack
        multiply(arg0: Internal.Quaternion): Internal.TransformStack
        multiply(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack
        rotateX(arg0: number): Internal.TransformStack
        rotateY(arg0: number): Internal.TransformStack
        translateBack(arg0: Vec3i): Internal.TransformStack
        translateBack(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        translateBack(arg0: Vec3): Internal.TransformStack
        rotateToFace(arg0: Internal.Direction): Internal.TransformStack
        rotateZ(arg0: number): Internal.TransformStack
        nudge(arg0: number): Internal.TransformStack
        rotateCentered(arg0: Internal.Direction, arg1: number): Internal.TransformStack
        rotateCentered(arg0: Internal.Quaternion): Internal.TransformStack
        centre(): Internal.TransformStack
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack
        rotateZRadians(arg0: number): Internal.TransformStack
        mulPose(arg0: Internal.Matrix4f): Internal.TransformStack
        rotateYRadians(arg0: number): Internal.TransformStack
        rotateXRadians(arg0: number): Internal.TransformStack
        popPose(): Internal.TransformStack
        unCentre(): Internal.TransformStack
    }
    interface VertexConsumer extends Internal.IForgeVertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface Tier {
        getTag(): net.minecraft.tags.Tag<Internal.Block>
    }
    interface EffectInstanceWithSource {
        setSource(arg0: ResourceLocation): void
        hasSource(): boolean
        getSource(): ResourceLocation
        removeEffect(): void
        getHiddenEffect(): Internal.MobEffectInstance
    }
    class DragSource implements Internal.Serializable {
        removeDragSourceListener(arg0: Internal.DragSourceListener): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        createDefaultDragGestureRecognizer(arg0: java_.awt.Component, arg1: number, arg2: Internal.DragGestureListener): Internal.DragGestureRecognizer
        createDragGestureRecognizer<T_>(arg0: Internal.Class<T_>, arg1: java_.awt.Component, arg2: number, arg3: Internal.DragGestureListener): T_
        notifyAll(): void
        static isDragImageSupported(): boolean
        addDragSourceMotionListener(arg0: Internal.DragSourceMotionListener): void
        getDragSourceMotionListeners(): Internal.DragSourceMotionListener[]
        notify(): void
        addDragSourceListener(arg0: Internal.DragSourceListener): void
        removeDragSourceMotionListener(arg0: Internal.DragSourceMotionListener): void
        static getDefaultDragSource(): Internal.DragSource
        getFlavorMap(): Internal.FlavorMap
        static getDragThreshold(): number
        hashCode(): number
        equals(arg0: any): boolean
        startDrag(arg0: Internal.DragGestureEvent, arg1: Internal.Cursor, arg2: Internal.Transferable, arg3: Internal.DragSourceListener): void
        startDrag(arg0: Internal.DragGestureEvent, arg1: Internal.Cursor, arg2: Internal.Image, arg3: Internal.Point, arg4: Internal.Transferable, arg5: Internal.DragSourceListener, arg6: Internal.FlavorMap): void
        startDrag(arg0: Internal.DragGestureEvent, arg1: Internal.Cursor, arg2: Internal.Image, arg3: Internal.Point, arg4: Internal.Transferable, arg5: Internal.DragSourceListener): void
        startDrag(arg0: Internal.DragGestureEvent, arg1: Internal.Cursor, arg2: Internal.Transferable, arg3: Internal.DragSourceListener, arg4: Internal.FlavorMap): void
        toString(): string
        getDragSourceListeners(): Internal.DragSourceListener[]
        static readonly DefaultCopyNoDrop : Internal.Cursor;
        static readonly DefaultMoveNoDrop : Internal.Cursor;
        static readonly DefaultMoveDrop : Internal.Cursor;
        static readonly DefaultLinkDrop : Internal.Cursor;
        static readonly DefaultLinkNoDrop : Internal.Cursor;
        static readonly DefaultCopyDrop : Internal.Cursor;
        get dragImageSupported(): boolean;
        get dragSourceMotionListeners(): Internal.DragSourceMotionListener[];
        get flavorMap(): Internal.FlavorMap;
        get dragThreshold(): number;
        get defaultDragSource(): Internal.DragSource;
        get dragSourceListeners(): Internal.DragSourceListener[];
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Appendable {
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string): Internal.Appendable
    }
    class FontManager implements Internal.AutoCloseable, Internal.AccessorFontManager, Internal.FontResourceManagerAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getFontSets(): Internal.Map<any, any>
        bookshelf$getFonts(): Internal.Map<any, any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get fontSets(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ResourceBundle {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getObject(arg0: string): any
        containsKey(arg0: string): boolean
        getBaseBundleName(): string
        notifyAll(): void
        getString(arg0: string): string
        getKeys(): Internal.Enumeration<string>
        static clearCache(arg0: Internal.ClassLoader): void
        static clearCache(): void
        notify(): void
        static getBundle(arg0: string, arg1: Internal.Locale, arg2: Internal.ClassLoader, arg3: Internal.ResourceBundle$Control): Internal.ResourceBundle
        static getBundle(arg0: string): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.ResourceBundle$Control): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.Locale, arg2: Internal.ClassLoader): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.Locale, arg2: Internal.ResourceBundle$Control): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.Locale, arg2: Internal.Module): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.Module): Internal.ResourceBundle
        static getBundle(arg0: string, arg1: Internal.Locale): Internal.ResourceBundle
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getStringArray(arg0: string): string[]
        keySet(): Internal.Set<string>
        getLocale(): Internal.Locale
        get baseBundleName(): string;
        get keys(): Internal.Enumeration<string>;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TeamProperties {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        read(tag: Internal.CompoundTag): void
        read(buffer: Internal.FriendlyByteBuf): void
        set<T>(key: Internal.TeamProperty<T>, value: T): void
        updateFrom(properties: Internal.TeamProperties): Internal.TeamProperties
        notifyAll(): void
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        get<T>(key: Internal.TeamProperty<T>): T
        toString(): string
        copy(): Internal.TeamProperties
        write(tag: Internal.CompoundTag): Internal.CompoundTag
        write(buffer: Internal.FriendlyByteBuf): void
        collect(): Internal.TeamProperties
        readonly map : Internal.Map<Internal.TeamProperty, Internal.TeamPropertyValue>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Clearable {
    }
    class FormatStyle extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.FormatStyle
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.FormatStyle[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.FormatStyle): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FormatStyle>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.FormatStyle>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly MEDIUM : Internal.FormatStyle;
        static readonly FULL : Internal.FormatStyle;
        static readonly LONG : Internal.FormatStyle;
        static readonly SHORT : Internal.FormatStyle;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FormatStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockIDPredicate implements Internal.BlockPredicate {
        getBlockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>
        getClass(): Internal.Class<any>
        with(key: string, value: string): Internal.BlockIDPredicate
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        checkState(state: Internal.BlockState): boolean
        toString(): string
        check(b: Internal.BlockContainerJS): boolean
        getBlockState(): Internal.BlockState
        notify(): void
        get blockState(): Internal.BlockState;
        get blockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SimpleChannelInboundHandler <I> extends Internal.ChannelInboundHandlerAdapter {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        notifyAll(): void
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        isSharable(): boolean
        notify(): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        acceptInboundMessage(arg0: any): boolean
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StringBuffer extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuffer>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.StringBuffer
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        codePointAt(arg0: number): number
        notifyAll(): void
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuffer
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.StringBuffer
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: any): Internal.StringBuffer
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuffer
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuffer
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.StringBuffer
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuffer
        compareTo(arg0: Internal.StringBuffer): number
        compareTo(arg0: any): number
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.StringBuffer
        notify(): void
        substring(arg0: number, arg1: number): string
        substring(arg0: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        appendCodePoint(arg0: number): Internal.StringBuffer
        hashCode(): number
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        isEmpty(): boolean
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.StringBuffer
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string, arg1: number): number
        lastIndexOf(arg0: string): number
        setLength(arg0: number): void
        equals(arg0: any): boolean
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: string[]): Internal.StringBuffer
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuffer
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: boolean): Internal.StringBuffer
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuffer
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuffer
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.StringBuffer
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.StringBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: any): Internal.AbstractStringBuilder
        append(arg0: any): Internal.StringBuffer
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CommonLevelAccessor extends Internal.EntityGetter, Internal.LevelReader, Internal.LevelSimulatedRW {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    interface ListIterator <E> extends Internal.Iterator<E> {
        next(): E
        add(arg0: E): void
        set(arg0: E): void
        previous(): E
        hasPrevious(): boolean
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        nextIndex(): number
        previousIndex(): number
        remove(): void
    }
    class NativeJavaClass extends Internal.NativeJavaObject implements dev.latvian.mods.rhino.Function {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static canConvert(cx: Internal.Context, fromObj: any, to: Internal.Class<any>): boolean
        setParentScope(m: Internal.Scriptable): void
        notifyAll(): void
        getIds(): any[]
        getClassObject(): Internal.Class<any>
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable
        getAllIds(): any[]
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        put(name: string, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        put(symbol: Internal.Symbol, start: Internal.Scriptable, value: any): void
        unwrap(): any
        getDefaultValue(hint: Internal.Class<any>): any
        getPrototype(): Internal.Scriptable
        hashCode(): number
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        has(name: string, start: Internal.Scriptable): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        hasInstance(value: Internal.Scriptable): boolean
        addCustomProperty(name: string, getter: Internal.CustomProperty): void
        setPrototype(m: Internal.Scriptable): void
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        equals(arg0: any): boolean
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getClassName(): string
        getParentScope(): Internal.Scriptable
        static readonly NOT_FOUND : any;
        get classObject(): Internal.Class<any>;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PlantType {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get(arg0: string): Internal.PlantType
        toString(): string
        notify(): void
        static readonly BEACH : Internal.PlantType;
        static readonly CAVE : Internal.PlantType;
        static readonly NETHER : Internal.PlantType;
        static readonly PLAINS : Internal.PlantType;
        static readonly DESERT : Internal.PlantType;
        static readonly WATER : Internal.PlantType;
        static readonly CROP : Internal.PlantType;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CodingErrorAction {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly REPORT : Internal.CodingErrorAction;
        static readonly IGNORE : Internal.CodingErrorAction;
        static readonly REPLACE : Internal.CodingErrorAction;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelOutboundBuffer$MessageProcessor {
        processMessage(arg0: any): boolean
    }
    interface WindowEventHandler {
    }
    interface ConditionContainer {
        killedByPlayer(): Internal.ConditionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer
        survivesExplosion(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
    }
    interface Guard {
        checkGuard(arg0: any): void
    }
    interface AccessorAbstractContainerScreen {
        getHoveredSlot(): Internal.Slot
    }
    class Matcher implements Internal.MatchResult {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasTransparentBounds(): boolean
        requireEnd(): boolean
        notifyAll(): void
        useTransparentBounds(arg0: boolean): Internal.Matcher
        pattern(): Internal.Pattern
        replaceFirst(arg0: string): string
        replaceFirst(arg0: (arg0: Internal.MatchResult) => string): string
        regionStart(): number
        replaceAll(arg0: string): string
        replaceAll(arg0: (arg0: Internal.MatchResult) => string): string
        notify(): void
        lookingAt(): boolean
        toMatchResult(): Internal.MatchResult
        static quoteReplacement(arg0: string): string
        hashCode(): number
        find(arg0: number): boolean
        find(): boolean
        end(): number
        end(arg0: number): number
        end(arg0: string): number
        results(): Internal.Stream<Internal.MatchResult>
        group(arg0: number): string
        group(): string
        group(arg0: string): string
        start(): number
        start(arg0: string): number
        start(arg0: number): number
        regionEnd(): number
        matches(): boolean
        hasAnchoringBounds(): boolean
        appendReplacement(arg0: Internal.StringBuffer, arg1: string): Internal.Matcher
        appendReplacement(arg0: Internal.StringBuilder, arg1: string): Internal.Matcher
        appendTail(arg0: Internal.StringBuffer): Internal.StringBuffer
        appendTail(arg0: Internal.StringBuilder): Internal.StringBuilder
        groupCount(): number
        equals(arg0: any): boolean
        reset(arg0: Internal.CharSequence): Internal.Matcher
        reset(): Internal.Matcher
        toString(): string
        region(arg0: number, arg1: number): Internal.Matcher
        useAnchoringBounds(arg0: boolean): Internal.Matcher
        hitEnd(): boolean
        usePattern(arg0: Internal.Pattern): Internal.Matcher
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Explosion$BlockInteraction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Explosion$BlockInteraction
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Explosion$BlockInteraction[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Explosion$BlockInteraction): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Explosion$BlockInteraction>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly DESTROY : Internal.Explosion$BlockInteraction;
        static readonly BREAK : Internal.Explosion$BlockInteraction;
        static readonly NONE : Internal.Explosion$BlockInteraction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntStream extends Internal.BaseStream<number, Internal.IntStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.IntStream
        takeWhile(arg0: java_.util.function_.IntPredicate): Internal.IntStream
        distinct(): Internal.IntStream
        findFirst(): Internal.OptionalInt
        sum(): number
        skip(arg0: number): Internal.IntStream
        asLongStream(): Internal.LongStream
        allMatch(arg0: java_.util.function_.IntPredicate): boolean
        mapToObj<U_>(arg0: Internal.IntFunction<U_>): Internal.Stream<U_>
        mapMulti(arg0: Internal.IntStream$IntMapMultiConsumer): Internal.IntStream
        iterator(): Internal.Iterator<any>
        iterator(): Internal.PrimitiveIterator$OfInt
        asDoubleStream(): Internal.DoubleStream
        min(): Internal.OptionalInt
        mapToLong(arg0: Internal.IntToLongFunction): Internal.LongStream
        parallel(): Internal.IntStream
        parallel(): Internal.BaseStream<any, any>
        noneMatch(arg0: java_.util.function_.IntPredicate): boolean
        findAny(): Internal.OptionalInt
        isParallel(): boolean
        limit(arg0: number): Internal.IntStream
        toArray(): number[]
        forEachOrdered(arg0: java_.util.function_.IntConsumer): void
        close(): void
        anyMatch(arg0: java_.util.function_.IntPredicate): boolean
        map(arg0: Internal.IntUnaryOperator): Internal.IntStream
        mapToDouble(arg0: Internal.IntToDoubleFunction): Internal.DoubleStream
        unordered(): Internal.IntStream
        reduce(arg0: number, arg1: java_.util.function_.IntBinaryOperator): number
        reduce(arg0: java_.util.function_.IntBinaryOperator): Internal.OptionalInt
        spliterator(): Internal.Spliterator$OfInt
        spliterator(): Internal.Spliterator<any>
        max(): Internal.OptionalInt
        forEach(arg0: java_.util.function_.IntConsumer): void
        count(): number
        dropWhile(arg0: java_.util.function_.IntPredicate): Internal.IntStream
        peek(arg0: java_.util.function_.IntConsumer): Internal.IntStream
        flatMap(arg0: Internal.IntFunction<Internal.IntStream>): Internal.IntStream
        filter(arg0: java_.util.function_.IntPredicate): Internal.IntStream
        onClose(arg0: Internal.Runnable): Internal.IntStream
        sorted(): Internal.IntStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.IntSummaryStatistics
        collect<R_>(arg0: () => R_, arg1: Internal.ObjIntConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_
    }
    interface DoubleFunction <R> {
        apply(arg0: number): R
    }
    interface Script {
        exec(arg0: Internal.Context, arg1: Internal.Scriptable): any
    }
    class PortalInfo {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ScreenAccessor {
        balm_getChildren(): Internal.List<Internal.GuiEventListener>
        balm_getRenderables(): Internal.List<Internal.Widget>
        balm_getNarratables(): Internal.List<Internal.NarratableEntry>
    }
    abstract class DataBuffer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getNumBanks(): number
        static getDataTypeSize(arg0: number): number
        getElemDouble(arg0: number, arg1: number): number
        getElemDouble(arg0: number): number
        notifyAll(): void
        getDataType(): number
        getOffset(): number
        getOffsets(): number[]
        setElemFloat(arg0: number, arg1: number, arg2: number): void
        setElemFloat(arg0: number, arg1: number): void
        notify(): void
        getSize(): number
        setElemDouble(arg0: number, arg1: number, arg2: number): void
        setElemDouble(arg0: number, arg1: number): void
        hashCode(): number
        equals(arg0: any): boolean
        setElem(arg0: number, arg1: number, arg2: number): void
        setElem(arg0: number, arg1: number): void
        getElemFloat(arg0: number, arg1: number): number
        getElemFloat(arg0: number): number
        toString(): string
        getElem(arg0: number): number
        getElem(arg0: number, arg1: number): number
        static readonly TYPE_INT : 3;
        static readonly TYPE_DOUBLE : 5;
        static readonly TYPE_SHORT : 2;
        static readonly TYPE_UNDEFINED : 32;
        static readonly TYPE_BYTE : 0;
        static readonly TYPE_USHORT : 1;
        static readonly TYPE_FLOAT : 4;
        get offset(): number;
        get size(): number;
        get offsets(): number[];
        get dataType(): number;
        get numBanks(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class EntityModel <T> extends net.minecraft.client.model.Model {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootTableEntry implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        survivesExplosion(): Internal.ConditionContainer
        notifyAll(): void
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(o: Internal.JsonObject): Internal.LootTableEntry
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        notify(): void
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        hashCode(): number
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootTableEntry
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        weight(weight: number): Internal.LootTableEntry
        quality(quality: number): Internal.LootTableEntry
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        equals(arg0: any): boolean
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        toString(): string
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        readonly json : Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NonNullPredicate <T> {
        test(arg0: T): boolean
    }
    interface DomainCombiner {
        combine(arg0: Internal.ProtectionDomain[], arg1: Internal.ProtectionDomain[]): Internal.ProtectionDomain[]
    }
    class ClientPlayerDataJS extends Internal.PlayerDataJS<any, any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.PlayerJS<any>
        getPlayer(): Internal.ClientPlayerJS
        getName(): string
        notifyAll(): void
        getProfile(): Internal.GameProfile
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        notify(): void
        getLevel(): Internal.ClientLevelJS
        getMinecraftPlayer(): Internal.Player
        hashCode(): number
        equals(arg0: any): boolean
        hasClientMod(): boolean
        toString(): string
        getData(): Internal.AttachedData
        get data(): Internal.AttachedData;
        get level(): Internal.ClientLevelJS;
        get minecraftPlayer(): Internal.Player;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FlowMessage extends org.apache.logging.log4j.message.Message {
        getText(): string
        getParameters(): any[]
        getFormattedMessage(): string
        getMessage(): org.apache.logging.log4j.message.Message
        getFormat(): string
        getThrowable(): Internal.Throwable
    }
    interface TemporalQuery <R> {
        queryFrom(arg0: Internal.TemporalAccessor): R
    }
    class EventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        canCancel(): boolean
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInterruptibleChannel implements Internal.Channel, Internal.InterruptibleChannel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isOpen(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        notify(): void
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeItemStack extends Internal.ICapabilitySerializable<Internal.CompoundTag>, Internal.IForgeItemStackMixin {
        canElytraFly(arg0: Internal.LivingEntity): boolean
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean
        canPerformAction(arg0: Internal.ToolAction): boolean
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean
        onHorseArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Mob): void
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean
        getItemEnchantability(): number
        getEntityLifespan(arg0: net.minecraft.world.level.Level): number
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): Internal.Tag
        getXpRepairRatio(): number
        getHighlightTip(arg0: Internal.Component): Internal.Component
        readShareTag(arg0: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean
        onArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Player): void
        isBookEnchantable(arg0: Internal.ItemStack): boolean
        hasContainerItem(): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult
        deserializeNBT(arg0: Internal.CompoundTag): void
        getContainerItem(): Internal.ItemStack
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void
        isPiglinCurrency(): boolean
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void
        isRepairable(): boolean
        getEquipmentSlot(): EquipmentSlot
        getShareTag(): Internal.CompoundTag
        getBurnTime(arg0: Internal.RecipeType<any>): number
        onDroppedByPlayer(arg0: Internal.Player): boolean
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean
        onEntitySwing(arg0: Internal.LivingEntity): boolean
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean
        areShareTagsEqual(arg0: Internal.ItemStack): boolean
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean
    }
    class NetworkEvent$Context {
        getClass(): Internal.Class<any>
        getNetworkManager(): Internal.Connection
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDirection(): Internal.NetworkDirection
        enqueueWork(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        notifyAll(): void
        notify(): void
        getPacketHandled(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        setPacketHandled(arg0: boolean): void
        attr<T>(arg0: Internal.AttributeKey<T>): Internal.Attribute<T>
        getSender(): Internal.ServerPlayer
        getPacketDispatcher(): Internal.NetworkEvent$PacketDispatcher
        get networkManager(): Internal.Connection;
        get packetHandled(): boolean;
        get sender(): Internal.ServerPlayer;
        get class(): Internal.Class<any>;
        get direction(): Internal.NetworkDirection;
        get packetDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        set packetHandled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IVertexConsumer {
        setQuadOrientation(arg0: Internal.Direction): void
        setTexture(arg0: Internal.TextureAtlasSprite): void
        setApplyDiffuseLighting(arg0: boolean): void
        setQuadTint(arg0: number): void
        getVertexFormat(): Internal.VertexFormat
        put(arg0: number, arg1: number[]): void
    }
    class PixelBuffer {
        getClass(): Internal.Class<any>
        getSubimage(x: number, y: number, w: number, h: number): Internal.PixelBuffer
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setPixels(p: number[]): void
        notifyAll(): void
        setRGB(x: number, y: number, col: number): void
        setRGB(startX: number, startY: number, w: number, h: number, rgbArray: number[]): void
        setRGB(startX: number, startY: number, buffer: Internal.PixelBuffer): void
        getWidth(): number
        fill(col: number): void
        fill(startX: number, startY: number, w: number, h: number, col: number): void
        toByteBuffer(alpha: boolean): Internal.ByteBuffer
        notify(): void
        getHeight(): number
        toImage(type: number): Internal.BufferedImage
        hashCode(): number
        getPixels(): number[]
        equals(o: any): boolean
        toString(): string
        static from(img: Internal.BufferedImage): Internal.PixelBuffer
        static from(stream: Internal.InputStream): Internal.PixelBuffer
        copy(): Internal.PixelBuffer
        getRGB(startX: number, startY: number, w: number, h: number, p: number[]): number[]
        getRGB(x: number, y: number): number
        get pixels(): number[];
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        set pixels(p: number[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AffineTransform implements Internal.Cloneable, Internal.Serializable {
        setToIdentity(): void
        getClass(): Internal.Class<any>
        rotate(arg0: number): void
        rotate(arg0: number, arg1: number, arg2: number, arg3: number): void
        rotate(arg0: number, arg1: number, arg2: number): void
        rotate(arg0: number, arg1: number): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        concatenate(arg0: Internal.AffineTransform): void
        preConcatenate(arg0: Internal.AffineTransform): void
        notifyAll(): void
        scale(arg0: number, arg1: number): void
        static getScaleInstance(arg0: number, arg1: number): Internal.AffineTransform
        static getRotateInstance(arg0: number): Internal.AffineTransform
        static getRotateInstance(arg0: number, arg1: number): Internal.AffineTransform
        static getRotateInstance(arg0: number, arg1: number, arg2: number): Internal.AffineTransform
        static getRotateInstance(arg0: number, arg1: number, arg2: number, arg3: number): Internal.AffineTransform
        notify(): void
        translate(arg0: number, arg1: number): void
        setToQuadrantRotation(arg0: number, arg1: number, arg2: number): void
        setToQuadrantRotation(arg0: number): void
        setToRotation(arg0: number): void
        setToRotation(arg0: number, arg1: number): void
        setToRotation(arg0: number, arg1: number, arg2: number): void
        setToRotation(arg0: number, arg1: number, arg2: number, arg3: number): void
        transform(arg0: Internal.Point2D, arg1: Internal.Point2D): Internal.Point2D
        transform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        transform(arg0: Internal.Point2D[], arg1: number, arg2: Internal.Point2D[], arg3: number, arg4: number): void
        transform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        transform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        transform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        getMatrix(arg0: number[]): void
        quadrantRotate(arg0: number, arg1: number, arg2: number): void
        quadrantRotate(arg0: number): void
        setTransform(arg0: Internal.AffineTransform): void
        setTransform(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void
        hashCode(): number
        inverseTransform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        inverseTransform(arg0: Internal.Point2D, arg1: Internal.Point2D): Internal.Point2D
        setToShear(arg0: number, arg1: number): void
        getTranslateY(): number
        getTranslateX(): number
        getDeterminant(): number
        shear(arg0: number, arg1: number): void
        invert(): void
        static getQuadrantRotateInstance(arg0: number, arg1: number, arg2: number): Internal.AffineTransform
        static getQuadrantRotateInstance(arg0: number): Internal.AffineTransform
        isIdentity(): boolean
        createTransformedShape(arg0: Internal.Shape): Internal.Shape
        createInverse(): Internal.AffineTransform
        getShearX(): number
        getScaleY(): number
        getScaleX(): number
        static getTranslateInstance(arg0: number, arg1: number): Internal.AffineTransform
        getShearY(): number
        getType(): number
        setToScale(arg0: number, arg1: number): void
        equals(arg0: any): boolean
        clone(): any
        toString(): string
        setToTranslation(arg0: number, arg1: number): void
        static getShearInstance(arg0: number, arg1: number): Internal.AffineTransform
        deltaTransform(arg0: Internal.Point2D, arg1: Internal.Point2D): Internal.Point2D
        deltaTransform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void
        static readonly TYPE_QUADRANT_ROTATION : 8;
        static readonly TYPE_TRANSLATION : 1;
        static readonly TYPE_IDENTITY : 0;
        static readonly TYPE_UNIFORM_SCALE : 2;
        static readonly TYPE_MASK_SCALE : 6;
        static readonly TYPE_MASK_ROTATION : 24;
        static readonly TYPE_GENERAL_SCALE : 4;
        static readonly TYPE_FLIP : 64;
        static readonly TYPE_GENERAL_ROTATION : 16;
        static readonly TYPE_GENERAL_TRANSFORM : 32;
        get scaleX(): number;
        get shearX(): number;
        get scaleY(): number;
        get translateY(): number;
        get identity(): boolean;
        get translateX(): number;
        get type(): number;
        get class(): Internal.Class<any>;
        get shearY(): number;
        get determinant(): number;
        set toQuadrantRotation(arg0: number);
        set toRotation(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Exports$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ModuleDescriptor$Exports$Modifier
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ModuleDescriptor$Exports$Modifier[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Exports$Modifier): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Exports$Modifier>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Exports$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Exports$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Member {
        getDeclaringClass(): Internal.Class<any>
        getName(): string
        isSynthetic(): boolean
        getModifiers(): number
    }
    class IItemWithTier$TIER extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        static valueOf(arg0: string): Internal.IItemWithTier$TIER
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.IItemWithTier$TIER[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.IItemWithTier$TIER): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IItemWithTier$TIER>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.IItemWithTier$TIER>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly ENHANCED : Internal.IItemWithTier$TIER;
        static readonly ULTIMATE : Internal.IItemWithTier$TIER;
        static readonly NORMAL : Internal.IItemWithTier$TIER;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IItemWithTier$TIER>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Int2IntOpenHashMap extends Internal.AbstractInt2IntMap implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: any, arg1: any): any
        replace(arg0: number, arg1: number): number
        replace(arg0: any, arg1: any, arg2: any): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        containsValue(arg0: number): boolean
        containsValue(arg0: any): boolean
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number
        mergeInt(arg0: number, arg1: number, arg2: java_.util.function_.IntBinaryOperator): number
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        trim(arg0: number): boolean
        trim(): boolean
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>
        entrySet(): Internal.Set<any>
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any
        values(): Internal.IntCollection
        values(): Internal.Collection<any>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number
        replaceAll(arg0: (arg0: number, arg1: number) => number): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        notify(): void
        remove(arg0: number, arg1: number): boolean
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        remove(arg0: any, arg1: any): boolean
        int2IntEntrySet(): Internal.ObjectSet<any>
        int2IntEntrySet(): Internal.Int2IntMap$FastEntrySet
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        hashCode(): number
        putAll(arg0: Internal.Map<number, number>): void
        get(arg0: number): number
        get(arg0: any): any
        get(arg0: any): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        forEach(arg0: (arg0: number, arg1: number) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        equals(arg0: any): boolean
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        clone(): (arg0: any) => any
        clone(): any
        addTo(arg0: number, arg1: number): number
        toString(): string
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: any, arg1: any): any
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerJS implements Internal.MessageSender, Internal.WithAttachedData {
        getAdvancement(id: ResourceLocation): Internal.AdvancementJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(minecraftPlayer: Internal.Player): Internal.ServerPlayerJS
        getPlayer(name: string): Internal.ServerPlayerJS
        getPlayer(uuid: Internal.UUID): Internal.ServerPlayerJS
        getName(): Internal.Text
        updateWorldList(): void
        release(): void
        notifyAll(): void
        tell(message: Internal.Component): void
        getAllLevels(): Internal.List<Internal.ServerLevelJS>
        getHardcore(): boolean
        getMotd(): string
        getOverworld(): Internal.ServerLevelJS
        notify(): void
        runCommandSilent(command: string): number
        scheduleInTicks(ticks: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        scheduleInTicks(ticks: number, data: any, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        isRunning(): boolean
        hashCode(): number
        setMotd(text: Internal.Component): void
        runCommand(command: string): number
        isSinglePlayer(): boolean
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        setStatusMessage(message: Internal.Component): void
        sendDataToAll(channel: string, data: Internal.CompoundTag): void
        isDedicated(): boolean
        getLevel(minecraftLevel: net.minecraft.world.level.Level): Internal.LevelJS
        getLevel(dimension: string): Internal.LevelJS
        schedule(timer: number, data: any, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        schedule(timer: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        stop(): void
        getMinecraftServer(): Internal.MinecraftServer
        getDisplayName(): Internal.Text
        equals(arg0: any): boolean
        getEntities(): Internal.EntityArrayList
        getEntities(filter: string): Internal.EntityArrayList
        toString(): string
        readonly playerMap : Internal.Map<Internal.UUID, Internal.ServerPlayerDataJS>;
        readonly serverScriptManager : Internal.ServerScriptManager;
        static instance : Internal.ServerJS;
        readonly allLevels : Internal.List<Internal.ServerLevelJS>;
        readonly persistentData : Internal.CompoundTag;
        readonly fakePlayerMap : Internal.Map<Internal.UUID, Internal.FakeServerPlayerDataJS>;
        readonly scheduledEvents : Internal.List<Internal.ScheduledEvent>;
        readonly levelMap : Internal.Map<string, Internal.ServerLevelJS>;
        overworld : Internal.ServerLevelJS;
        readonly scheduledTickEvents : Internal.List<Internal.ScheduledEvent>;
        get running(): boolean;
        get singlePlayer(): boolean;
        get motd(): string;
        get dedicated(): boolean;
        get data(): Internal.AttachedData;
        get hardcore(): boolean;
        get entities(): Internal.EntityArrayList;
        get players(): Internal.EntityArrayList;
        get displayName(): Internal.Text;
        get name(): Internal.Text;
        get minecraftServer(): Internal.MinecraftServer;
        get class(): Internal.Class<any>;
        set statusMessage(message: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TypeToken <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRawType(): Internal.Class<T>
        getType(): Internal.Type
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static get<T>(arg0: Internal.Class<T>): Internal.TypeToken<T>
        static get(arg0: Internal.Type): Internal.TypeToken<any>
        static getArray(arg0: Internal.Type): Internal.TypeToken<any>
        toString(): string
        isAssignableFrom(arg0: Internal.Type): boolean
        isAssignableFrom(arg0: Internal.Class<any>): boolean
        isAssignableFrom(arg0: Internal.TypeToken<any>): boolean
        notify(): void
        static getParameterized(arg0: Internal.Type, arg1: Internal.Type[]): Internal.TypeToken<any>
        get rawType(): Internal.Class<T>;
        get type(): Internal.Type;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClocheRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        render(o: any): Internal.ClocheRecipeJS
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        renderReference : Internal.ClocheRenderFunction$ClocheRenderReference;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractLongSet extends Internal.AbstractLongCollection implements Internal.Cloneable, Internal.LongSet {
        getClass(): Internal.Class<any>
        longIterator(): Internal.LongIterator
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        removeAll(arg0: Internal.LongCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.LongIterator
        iterator(): Internal.Iterator<any>
        stream(): Internal.Stream<number>
        hashCode(): number
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        longStream(): Internal.LongStream
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        longSpliterator(): Internal.LongSpliterator
        toLongArray(): number[]
        toLongArray(arg0: number[]): number[]
        spliterator(): Internal.LongSpliterator
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: Internal.LongConsumer): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.LongCollection): boolean
        isEmpty(): boolean
        clear(): void
        longParallelStream(): Internal.LongStream
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.LongPredicate): boolean
        contains(arg0: any): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.Collection<number>): boolean
        addAll(arg0: Internal.LongCollection): boolean
        equals(arg0: any): boolean
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.LongCollection): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class OffsetTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetTime>, Internal.Serializable {
        getClass(): Internal.Class<any>
        plusHours(arg0: number): Internal.OffsetTime
        isEqual(arg0: Internal.OffsetTime): boolean
        toLocalTime(): Internal.LocalTime
        atDate(arg0: Internal.LocalDate): Internal.OffsetDateTime
        compareTo(arg0: any): number
        compareTo(arg0: Internal.OffsetTime): number
        withOffsetSameLocal(arg0: Internal.ZoneOffset): Internal.OffsetTime
        plusSeconds(arg0: number): Internal.OffsetTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.OffsetTime
        plusNanos(arg0: number): Internal.OffsetTime
        withHour(arg0: number): Internal.OffsetTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.OffsetTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.OffsetTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: Internal.TemporalAmount): Internal.OffsetTime
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        toEpochSecond(arg0: Internal.LocalDate): number
        isAfter(arg0: Internal.OffsetTime): boolean
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.OffsetTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.OffsetTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetTime
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        minusHours(arg0: number): Internal.OffsetTime
        notifyAll(): void
        getOffset(): Internal.ZoneOffset
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        plusMinutes(arg0: number): Internal.OffsetTime
        notify(): void
        minusMinutes(arg0: number): Internal.OffsetTime
        hashCode(): number
        static now(): Internal.OffsetTime
        static now(arg0: Internal.ZoneId): Internal.OffsetTime
        static now(arg0: Internal.Clock): Internal.OffsetTime
        static of(arg0: Internal.LocalTime, arg1: Internal.ZoneOffset): Internal.OffsetTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ZoneOffset): Internal.OffsetTime
        get(arg0: Internal.TemporalField): number
        getHour(): number
        withMinute(arg0: number): Internal.OffsetTime
        static parse(arg0: Internal.CharSequence): Internal.OffsetTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.OffsetTime
        isBefore(arg0: Internal.OffsetTime): boolean
        withNano(arg0: number): Internal.OffsetTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.OffsetTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.OffsetTime
        withOffsetSameInstant(arg0: Internal.ZoneOffset): Internal.OffsetTime
        equals(arg0: any): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.OffsetTime
        withSecond(arg0: number): Internal.OffsetTime
        static readonly MIN : Internal.OffsetTime;
        static readonly MAX : Internal.OffsetTime;
        get offset(): Internal.ZoneOffset;
        get hour(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlastFurnaceRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LightProvider {
        getLight(arg0: Internal.LightLayer, arg1: number, arg2: number, arg3: number): number
        getPackedLight(arg0: number, arg1: number, arg2: number): number
    }
    class NativeJavaObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Wrapper, Internal.Serializable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasInstance(value: Internal.Scriptable): boolean
        static canConvert(cx: Internal.Context, fromObj: any, to: Internal.Class<any>): boolean
        setParentScope(m: Internal.Scriptable): void
        notifyAll(): void
        getIds(): any[]
        addCustomProperty(name: string, getter: Internal.CustomProperty): void
        getAllIds(): any[]
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        put(index: number, start: Internal.Scriptable, value: any): void
        put(name: string, start: Internal.Scriptable, value: any): void
        put(symbol: Internal.Symbol, start: Internal.Scriptable, value: any): void
        unwrap(): any
        getDefaultValue(hint: Internal.Class<any>): any
        setPrototype(m: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        hashCode(): number
        equals(arg0: any): boolean
        get(index: number, start: Internal.Scriptable): any
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getClassName(): string
        getParentScope(): Internal.Scriptable
        static readonly NOT_FOUND : any;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NoFogDynamicRegistryManagerExtensions {
        no_fog_get<E>(arg0: Internal.ResourceKey<Internal.Registry<E>>): Internal.MappedRegistry<E>
    }
    interface DoubleSupplier {
        getAsDouble(): number
    }
    class DataResult$PartialResult <R> {
        flatMap<R2>(arg0: (arg0: R) => Internal.DataResult$PartialResult<R2>): Internal.DataResult$PartialResult<R2>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        message(): string
        map<R2>(arg0: (arg0: R) => R2): Internal.DataResult$PartialResult<R2>
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Component$BaselineResizeBehavior extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.Component$BaselineResizeBehavior
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.Component$BaselineResizeBehavior[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Component$BaselineResizeBehavior): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Component$BaselineResizeBehavior>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.Component$BaselineResizeBehavior>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly OTHER : Internal.Component$BaselineResizeBehavior;
        static readonly CONSTANT_DESCENT : Internal.Component$BaselineResizeBehavior;
        static readonly CENTER_OFFSET : Internal.Component$BaselineResizeBehavior;
        static readonly CONSTANT_ASCENT : Internal.Component$BaselineResizeBehavior;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Component$BaselineResizeBehavior>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Opens$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ModuleDescriptor$Opens$Modifier
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ModuleDescriptor$Opens$Modifier[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Opens$Modifier): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Opens$Modifier>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Opens$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Opens$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class TeamBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): Internal.Component
        notifyAll(): void
        getHighestRank(playerId: Internal.UUID): Internal.TeamRank
        save(): void
        getId(): Internal.UUID
        isMember(uuid: Internal.UUID): boolean
        getDescription(): string
        isOfficer(profile: Internal.UUID): boolean
        notify(): void
        getColoredName(): Internal.Component
        hashCode(): number
        isAlly(profile: Internal.UUID): boolean
        getProperty<T>(property: Internal.TeamProperty<T>): T
        isValid(): boolean
        getExtraData(): Internal.CompoundTag
        getColor(): number
        getRanked(rank: Internal.TeamRank): Internal.Map<Internal.UUID, Internal.TeamRank>
        isFreeToJoin(): boolean
        getDisplayName(): string
        getType(): Internal.TeamType
        getStringID(): string
        isInvited(profile: Internal.UUID): boolean
        setProperty<T>(property: Internal.TeamProperty<T>, value: T): void
        equals(o: any): boolean
        toString(): string
        getMembers(): Internal.Set<Internal.UUID>
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FileAttributeView extends Internal.AttributeView {
        name(): string
    }
    interface ChangeListener <T> {
        onChanged(arg0: T): void
    }
    class RegistryAccess$RegistryHolder extends net.minecraft.core.RegistryAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        no_fog_get(key: Internal.ResourceKey<any>): Internal.MappedRegistry<any>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2FloatFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        getFloat(arg0: any): number
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        removeFloat(arg0: any): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface App <F, A> {
    }
    abstract class SavedData {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoubleStream$Builder extends Internal.DoubleConsumer {
        add(arg0: number): Internal.DoubleStream$Builder
        build(): Internal.DoubleStream
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        accept(arg0: number): void
    }
    interface ProgressiveFuture <V> extends Internal.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(): Internal.Future<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        isDone(): boolean
        sync(): Internal.ProgressiveFuture<V>
        sync(): Internal.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        syncUninterruptibly(): Internal.Future<V>
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isCancellable(): boolean
        await(): Internal.ProgressiveFuture<V>
        await(): Internal.Future<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
    }
    abstract class FastMapKey <T> {
        getClass(): Internal.Class<any>
        getValue(arg0: number): T
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getProperty(): net.minecraft.world.level.block.state.properties.Property<T>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        numValues(): number
        notify(): void
        get property(): net.minecraft.world.level.block.state.properties.Property<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Spliterator$OfDouble extends Internal.Spliterator$OfPrimitive<number, Internal.DoubleConsumer, Internal.Spliterator$OfDouble> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfDouble
        characteristics(): number
        tryAdvance(arg0: any): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: Internal.DoubleConsumer): boolean
        getComparator(): Internal.Comparator<number>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: Internal.DoubleConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
    }
    class CodeSource implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.URL
        getCodeSigners(): any[]
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getCertificates(): any[]
        toString(): string
        implies(arg0: Internal.CodeSource): boolean
        notify(): void
        get codeSigners(): any[];
        get certificates(): any[];
        get location(): Internal.URL;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CoderResult {
        static malformedForLength(arg0: number): Internal.CoderResult
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isMalformed(): boolean
        isOverflow(): boolean
        notifyAll(): void
        isUnmappable(): boolean
        length(): number
        throwException(): void
        notify(): void
        isError(): boolean
        static unmappableForLength(arg0: number): Internal.CoderResult
        hashCode(): number
        equals(arg0: any): boolean
        isUnderflow(): boolean
        toString(): string
        static readonly OVERFLOW : Internal.CoderResult;
        static readonly UNDERFLOW : Internal.CoderResult;
        get underflow(): boolean;
        get overflow(): boolean;
        get unmappable(): boolean;
        get error(): boolean;
        get class(): Internal.Class<any>;
        get malformed(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SmithingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IScreenWrapper extends Internal.IOpenableScreen {
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        openContextMenu(panel: Internal.Panel): void
        openGui(): void
        openGuiLater(): void
        run(): void
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        getGui(): Internal.BaseScreen
    }
    class PlatformWrapper$ModInfo {
        getVersion(): string
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        getId(): string
        notify(): void
        get name(): string;
        get id(): string;
        get version(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractConstant <T> implements Internal.Constant<T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        name(): string
        toString(): string
        id(): number
        compareTo(arg0: T): number
        compareTo(arg0: any): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Raster {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        createChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.Raster
        notifyAll(): void
        getSampleFloat(arg0: number, arg1: number, arg2: number): number
        getNumDataElements(): number
        createTranslatedChild(arg0: number, arg1: number): Internal.Raster
        getNumBands(): number
        getWidth(): number
        static createWritableRaster(arg0: Internal.SampleModel, arg1: Internal.DataBuffer, arg2: Internal.Point): Internal.WritableRaster
        static createWritableRaster(arg0: Internal.SampleModel, arg1: Internal.Point): Internal.WritableRaster
        notify(): void
        getBounds(): Internal.Rectangle
        getSampleModel(): Internal.SampleModel
        getHeight(): number
        static createRaster(arg0: Internal.SampleModel, arg1: Internal.DataBuffer, arg2: Internal.Point): Internal.Raster
        getTransferType(): number
        hashCode(): number
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[]
        getSampleDouble(arg0: number, arg1: number, arg2: number): number
        getParent(): Internal.Raster
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createBandedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        getDataBuffer(): Internal.DataBuffer
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[]
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        getPixel(arg0: number, arg1: number, arg2: number[]): number[]
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number[], arg4: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.Point): Internal.WritableRaster
        static createPackedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        createCompatibleWritableRaster(): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: Internal.Rectangle): Internal.WritableRaster
        createCompatibleWritableRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.WritableRaster
        getSampleModelTranslateX(): number
        getSampleModelTranslateY(): number
        equals(arg0: any): boolean
        getDataElements(arg0: number, arg1: number, arg2: any): any
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): any
        toString(): string
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createInterleavedRaster(arg0: Internal.DataBuffer, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point): Internal.WritableRaster
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point): Internal.WritableRaster
        getMinX(): number
        getSample(arg0: number, arg1: number, arg2: number): number
        getMinY(): number
        get parent(): Internal.Raster;
        get dataBuffer(): Internal.DataBuffer;
        get numDataElements(): number;
        get numBands(): number;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get transferType(): number;
        get sampleModelTranslateX(): number;
        get class(): Internal.Class<any>;
        get sampleModel(): Internal.SampleModel;
        get height(): number;
        get sampleModelTranslateY(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorRenderType {
    }
    class LunarTextComponents$NotificationType extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.LunarTextComponents$NotificationType
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.LunarTextComponents$NotificationType[]
        static byName(arg0: string): Internal.LunarTextComponents$NotificationType
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LunarTextComponents$NotificationType): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LunarTextComponents$NotificationType>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.LunarTextComponents$NotificationType>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents$NotificationType>;
        static readonly CHAT : Internal.LunarTextComponents$NotificationType;
        static readonly HOT_BAR : Internal.LunarTextComponents$NotificationType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LunarTextComponents$NotificationType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Tag$Named <T> extends net.minecraft.tags.Tag<T> {
    }
    class BlockDestructionProgress implements Internal.Comparable<Internal.BlockDestructionProgress> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(arg0: Internal.BlockDestructionProgress): number
        compareTo(arg0: any): number
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BETypeAccess {
        getValidBlocks(): Internal.Set<Internal.Block>
    }
    class Style implements Internal.StyleAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        static create_$md$204703$0(arg0: Internal.TextColor, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: Internal.ClickEvent, arg7: Internal.HoverEvent, arg8: string, arg9: ResourceLocation): Internal.Style
        notifyAll(): void
        equals(arg0: any): boolean
        setObfuscated(arg0: boolean): Internal.Style
        toString(): string
        notify(): void
        setUnderlined(arg0: boolean): Internal.Style
        setStrikethrough(arg0: boolean): Internal.Style
        get class(): Internal.Class<any>;
        set underlined(arg0: boolean);
        set strikethrough(arg0: boolean);
        set obfuscated(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DayOfWeek extends Internal.Enum<any> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getClass(): Internal.Class<any>
        minus(arg0: number): Internal.DayOfWeek
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        static values(): Internal.DayOfWeek[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DayOfWeek): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DayOfWeek>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.DayOfWeek>
        hashCode(): number
        static of(arg0: number): Internal.DayOfWeek
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.DayOfWeek
        static valueOf(arg0: string): Internal.DayOfWeek
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number): Internal.DayOfWeek
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly WEDNESDAY : Internal.DayOfWeek;
        static readonly MONDAY : Internal.DayOfWeek;
        static readonly THURSDAY : Internal.DayOfWeek;
        static readonly SUNDAY : Internal.DayOfWeek;
        static readonly TUESDAY : Internal.DayOfWeek;
        static readonly FRIDAY : Internal.DayOfWeek;
        static readonly SATURDAY : Internal.DayOfWeek;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.DayOfWeek>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerSettings {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static exportData(): void
        logInvalidRecipeHandlers : boolean;
        useOriginalRecipeForFilters : boolean;
        dataPackOutput : boolean;
        logSkippedRecipes : boolean;
        static instance : Internal.ServerSettings;
        logOverrides : boolean;
        logErroringRecipes : boolean;
        static source : Internal.CommandSourceStack;
        logAddedRecipes : boolean;
        logRemovedRecipes : boolean;
        static dataExport : Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VariantBlockStateGenerator {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        variant(key: string, consumer: (arg0: Internal.VariantBlockStateGenerator$Variant) => void): void
        variant(key: string, model: string): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Chronology extends Internal.Comparable<Internal.Chronology> {
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>
        range(arg0: Internal.ChronoField): Internal.ValueRange
        getId(): string
        compareTo(arg0: Internal.Chronology): number
        compareTo(arg0: any): number
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(): Internal.ChronoLocalDate
        eraOf(arg0: number): Internal.Era
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        hashCode(): number
        epochSecond(arg0: Internal.Era, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): number
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        getCalendarType(): string
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        resolveDate(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        isLeapYear(arg0: number): boolean
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        eras(): Internal.List<Internal.Era>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        equals(arg0: any): boolean
        toString(): string
    }
    interface AccessorMobEffectInstance {
        setDuration(arg0: number): void
        bookshelf$setHiddenEffect(arg0: Internal.MobEffectInstance): void
        bookshelf$tickDownDuration(): number
        bookshelf$getHiddenEffect(): Internal.MobEffectInstance
    }
    interface ItemFTBL {
        setCraftingRemainingItemFTBL(arg0: Internal.Item): void
    }
    class GlyphMetrics {
        isLigature(): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRSB(): number
        isCombining(): boolean
        notifyAll(): void
        isWhitespace(): boolean
        getAdvanceY(): number
        getLSB(): number
        getAdvanceX(): number
        notify(): void
        isStandard(): boolean
        getType(): number
        hashCode(): number
        getAdvance(): number
        equals(arg0: any): boolean
        getBounds2D(): Internal.Rectangle2D
        toString(): string
        isComponent(): boolean
        static readonly COMBINING : 2;
        static readonly WHITESPACE : 4;
        static readonly LIGATURE : 1;
        static readonly COMPONENT : 3;
        static readonly STANDARD : 0;
        get rSB(): number;
        get standard(): boolean;
        get combining(): boolean;
        get type(): number;
        get bounds2D(): Internal.Rectangle2D;
        get advance(): number;
        get advanceY(): number;
        get advanceX(): number;
        get component(): boolean;
        get ligature(): boolean;
        get lSB(): number;
        get whitespace(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MouseEvent extends Internal.InputEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        translatePoint(arg0: number, arg1: number): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocationOnScreen(): Internal.Point
        notifyAll(): void
        isMetaDown(): boolean
        consume(): void
        getModifiersEx(): number
        notify(): void
        isPopupTrigger(): boolean
        isShiftDown(): boolean
        paramString(): string
        getButton(): number
        isConsumed(): boolean
        static getModifiersExText(arg0: number): string
        hashCode(): number
        isAltGraphDown(): boolean
        static getMaskForButton(arg0: number): number
        getModifiers(): number
        isAltDown(): boolean
        static getMouseModifiersText(arg0: number): string
        getPoint(): Internal.Point
        isControlDown(): boolean
        getID(): number
        getX(): number
        getY(): number
        getYOnScreen(): number
        getSource(): any
        equals(arg0: any): boolean
        getWhen(): number
        getClickCount(): number
        toString(): string
        getComponent(): java_.awt.Component
        getXOnScreen(): number
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_FIRST : 500;
        static readonly BUTTON1_MASK : 16;
        static readonly MOUSE_PRESSED : 501;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON1 : 1;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly COMPONENT_SHOWN : 102;
        static readonly MOUSE_LAST : 507;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly NOBUTTON : 0;
        static readonly COMPONENT_RESIZED : 101;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly MOUSE_WHEEL : 507;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_EXITED : 505;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_CLICKED : 500;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly MOUSE_MOVED : 503;
        static readonly COMPONENT_MOVED : 100;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly BUTTON2 : 2;
        static readonly BUTTON3 : 3;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly MOUSE_RELEASED : 502;
        static readonly BUTTON3_MASK : 4;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly MOUSE_ENTERED : 504;
        static readonly MOUSE_DRAGGED : 506;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get clickCount(): number;
        get yOnScreen(): number;
        get xOnScreen(): number;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get point(): Internal.Point;
        get altGraphDown(): boolean;
        get button(): number;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get popupTrigger(): boolean;
        get locationOnScreen(): Internal.Point;
        get metaDown(): boolean;
        get x(): number;
        get y(): number;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RewardType$Provider {
        create(arg0: Internal.Quest): Internal.Reward
    }
    class Products$P2 <F, T1, T2> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: (arg0: T1, arg1: T2) => R): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, (arg0: T1, arg1: T2) => R>): Internal.App<F, R>
        hashCode(): number
        and<T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P6<F, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T3, T4, T5, T6>(arg0: Internal.Products$P4<F, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        and<T3>(arg0: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        and<T3, T4>(arg0: Internal.Products$P2<F, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T3, T4, T5>(arg0: Internal.Products$P3<F, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T3, T4, T5, T6, T7>(arg0: Internal.Products$P5<F, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        notify(): void
        t2(): Internal.App<F, T2>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CrusherRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AlloyRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        energy(e: number): Internal.IERecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        time(t: number): Internal.IERecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        parseResultItem(o: any): Internal.ItemStackJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ForgeModelBakery extends Internal.ModelBakery {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static defaultTextureGetter(): (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite
        static instance(): Internal.ForgeModelBakery
        handler$zpc000$injectProcessLoading(arg0: Internal.ProfilerFiller, arg1: number, arg2: Internal.CallbackInfo): void
        notifyAll(): void
        static getMaterials_$md$204703$0(): Internal.Set<any>
        getSpecialModels(): Internal.Set<ResourceLocation>
        getResourceManager(): Internal.ResourceManager
        notify(): void
        isLoading(): boolean
        static addSpecialModel(arg0: ResourceLocation): void
        getSpriteMap(): Internal.AtlasSet
        static getInventoryVariant(arg0: string): Internal.ModelResourceLocation
        getModelOrLogError(arg0: ResourceLocation, arg1: string): Internal.UnbakedModel
        getSpriteAtlasManager(): Internal.AtlasSet
        hashCode(): number
        equals(arg0: any): boolean
        bake(arg0: ResourceLocation, arg1: Internal.ModelState, arg2: (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite): Internal.BakedModel
        onPostBakeEvent(arg0: Internal.Map<ResourceLocation, Internal.BakedModel>): void
        toString(): string
        static defaultModelGetter(): (arg0: ResourceLocation) => Internal.UnbakedModel
        getModelOrMissing(arg0: ResourceLocation): Internal.UnbakedModel
        handler$zpc000$injectLoadModel(arg0: ResourceLocation, arg1: Internal.CallbackInfo): void
        get spriteMap(): Internal.AtlasSet;
        get specialModels(): Internal.Set<ResourceLocation>;
        get materials_$md$204703$0(): Internal.Set<any>;
        get spriteAtlasManager(): Internal.AtlasSet;
        get loading(): boolean;
        get class(): Internal.Class<any>;
        get resourceManager(): Internal.ResourceManager;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceProvider {
    }
    class EntityType <T> extends Internal.ForgeRegistryEntry<any> implements Internal.EntityTypeTest<Internal.Entity, T>, Internal.EntityTypeExtension<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.EntityType<any>
        setRegistryName(arg0: string): Internal.EntityType<any>
        setRegistryName(arg0: string, arg1: string): Internal.EntityType<any>
        getTags(): Internal.Set<ResourceLocation>
        notify(): void
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<any>): void
        flywheel$getInstancingController(): Internal.EntityInstancingController<any>
        hashCode(): number
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.EntityType<any>>
        toString(): string
        customClientSpawn(arg0: Internal.PlayMessages$SpawnEntity, arg1: net.minecraft.world.level.Level): T
        readonly delegate : () => Internal.EntityType<any>;
        get registryType(): Internal.Class<Internal.EntityType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DragGestureListener extends Internal.EventListener {
        dragGestureRecognized(arg0: Internal.DragGestureEvent): void
    }
    interface PrimitiveIterator <T, T_CONS> extends Internal.Iterator<T> {
        next(): T
        hasNext(): boolean
        forEachRemaining(arg0: T_CONS): void
        forEachRemaining(arg0: (arg0: T) => void): void
        remove(): void
    }
    class ListConfig <E, CV> extends Internal.ConfigValue<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.List<E>>
        notifyAll(): void
        isEqual(v1: Internal.List<E>, v2: Internal.List<E>): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<Internal.List<E>>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        hashCode(): number
        getStringForGUI(arg0: any): Internal.Component
        getStringForGUI(v: Internal.List<E>): Internal.Component
        getPath(): string
        copy(v: Internal.List<E>): Internal.List<E>
        copy(arg0: any): any
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: Internal.List<E>, c: (arg0: Internal.List<E>) => void, def: Internal.List<E>): Internal.ConfigValue<Internal.List<E>>
        getColor(v: Internal.List<E>): Internal.Color4I
        getColor(arg0: any): Internal.Color4I
        addInfo(l: Internal.TooltipList): void
        getIcon(v: Internal.List<E>): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<Internal.List<E>>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<Internal.List<E>>
        setNameKey(key: string): Internal.ConfigValue<Internal.List<E>>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: Internal.List<E>): boolean
        static readonly COLOR : Internal.Color4I;
        defaultValue : Internal.List<E>;
        static readonly EMPTY_LIST : Internal.TextComponent;
        static readonly NON_EMPTY_LIST : Internal.TextComponent;
        id : string;
        readonly type : CV;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: Internal.List<E>) => void;
        value : Internal.List<E>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: Internal.List<E>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class DragSourceEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        getX(): number
        getY(): number
        hashCode(): number
        getSource(): any
        getDragSourceContext(): Internal.DragSourceContext
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ZoneOffsetTransitionRule$TimeDefinition extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.ZoneOffsetTransitionRule$TimeDefinition
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ZoneOffsetTransitionRule$TimeDefinition[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ZoneOffsetTransitionRule$TimeDefinition): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ZoneOffsetTransitionRule$TimeDefinition>>
        notify(): void
        createDateTime(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneOffset): Internal.LocalDateTime
        getDeclaringClass(): Internal.Class<Internal.ZoneOffsetTransitionRule$TimeDefinition>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly WALL : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly UTC : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly STANDARD : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ZoneOffsetTransitionRule$TimeDefinition>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ContextMenu extends Internal.Panel {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        getContentHeight(): number
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        isDefaultScrollVertical(): boolean
        align(layout: Internal.WidgetLayout): number
        getGui(): Internal.BaseScreen
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        setOffset(flag: boolean): void
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        drawOffsetBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        updateMouseOver(mouseX: number, mouseY: number): void
        getScrollStep(): number
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget): void
        isMouseOver(): boolean
        onClosed(): void
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget
        openGui(): void
        setOnlyInteractWithWidgetsInside(value: boolean): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        setOnlyRenderWidgetsInside(value: boolean): void
        tick(): void
        setHeight(v: number): void
        addMouseOverText(list: Internal.TooltipList): void
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        refreshWidgets(): void
        isOffset(): boolean
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        alignWidgets(): void
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        drawWidget(matrixStack: Internal.PoseStack, theme: Internal.Theme, widget: dev.ftb.mods.ftblibrary.ui.Widget, index: number, x: number, y: number, w: number, h: number): void
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        notify(): void
        isMouseOverAnyWidget(): boolean
        mouseReleased(button: Internal.MouseButton): void
        getScrollX(): number
        getScrollY(): number
        getContentWidth(): number
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        clearWidgets(): void
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        setScrollStep(s: number): void
        getWidgetType(): Internal.WidgetType
        movePanelScroll(dx: number, dy: number): boolean
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        getOnlyInteractWithWidgetsInside(): boolean
        getOnlyRenderWidgetsInside(): boolean
        addWidgets(): void
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getY(): number
        addAll(list: Internal.Iterable<dev.ftb.mods.ftblibrary.ui.Widget>): void
        equals(arg0: any): boolean
        scrollPanel(scroll: number): boolean
        toString(): string
        setScrollX(scroll: number): void
        getIngredientUnderMouse(): any
        setScrollY(scroll: number): void
        posX : number;
        parent : Internal.Panel;
        posY : number;
        hasIcons : boolean;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        readonly items : Internal.List<Internal.ContextMenuItem>;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get scrollY(): number;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Executor {
        execute(arg0: Internal.Runnable): void
    }
    class RenderType$CompositeRenderType extends Internal.RenderType {
        getClass(): Internal.Class<any>
        handler$zpd000$cleanNoLighting(arg0: Internal.BufferBuilder, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        flywheel$getDrawBuffer(): Internal.DrawBuffer
        hashCode(): number
        static create_$md$204703$0(arg0: string, arg1: Internal.VertexFormat, arg2: Internal.VertexFormat$Mode, arg3: number, arg4: boolean, arg5: boolean, arg6: Internal.RenderType$CompositeState): Internal.RenderType$CompositeRenderType
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        handler$zpd000$setupNoLighting(arg0: Internal.BufferBuilder, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo): void
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AdvancementJS {
        hasDisplay(): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getParent(): Internal.AdvancementJS
        notifyAll(): void
        getId(): ResourceLocation
        getDescription(): Internal.Text
        notify(): void
        getChildren(): Internal.Set<Internal.AdvancementJS>
        getTitle(): Internal.Text
        hashCode(): number
        equals(o: any): boolean
        toString(): string
        id(): ResourceLocation
        getDisplayText(): Internal.Text
        addChild(a: Internal.AdvancementJS): void
        readonly advancement : Internal.Advancement;
        get parent(): Internal.AdvancementJS;
        get displayText(): Internal.Text;
        get children(): Internal.Set<Internal.AdvancementJS>;
        get description(): Internal.Text;
        get title(): Internal.Text;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockAndTintGetter extends Internal.BlockGetter {
    }
    class PanelScrollBar extends Internal.ScrollBar {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        setCanAlwaysScrollPlane(v: boolean): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        getGui(): Internal.BaseScreen
        canMouseScroll(): boolean
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        drawBackground(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        static isCtrlKeyDown(): boolean
        updateMouseOver(mouseX: number, mouseY: number): void
        getScrollStep(): number
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        onClosed(): void
        isMouseOver(): boolean
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        openGui(): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        getMappedValue(max: number): number
        tick(): void
        setHeight(v: number): void
        addMouseOverText(list: Internal.TooltipList): void
        setMaxValue(max: number): void
        canMouseScrollPlane(): boolean
        showValueOnMouseOver(): boolean
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        getScrollBarSize(): number
        setMinValue(min: number): void
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        getMaxValue(): number
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        drawScrollBar(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        closeContextMenu(): void
        notify(): void
        mouseReleased(button: Internal.MouseButton): void
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        setCanAlwaysScroll(v: boolean): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        setScrollStep(s: number): void
        getWidgetType(): Internal.WidgetType
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        onMoved(): void
        getValue(): number
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getMinValue(): number
        getY(): number
        equals(arg0: any): boolean
        setValue(v: number): void
        toString(): string
        getIngredientUnderMouse(): any
        readonly plane : Internal.ScrollBar$Plane;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        readonly panel : Internal.Panel;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get maxValue(): number;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get scrollBarSize(): number;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get minValue(): number;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get value(): number;
        get partialTicks(): number;
        set canAlwaysScroll(v: boolean);
        set canAlwaysScrollPlane(v: boolean);
        set minValue(min: number);
        set clipboardString(string: string);
        set maxValue(max: number);
        set x(v: number);
        set y(v: number);
        set scrollStep(s: number);
        set value(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Locale$LanguageRange {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        getWeight(): number
        getRange(): string
        notifyAll(): void
        equals(arg0: any): boolean
        static mapEquivalents(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>
        toString(): string
        static parse(arg0: string): Internal.List<Internal.Locale$LanguageRange>
        static parse(arg0: string, arg1: Internal.Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>
        notify(): void
        static readonly MAX_WEIGHT : 1.0;
        static readonly MIN_WEIGHT : 0.0;
        get weight(): number;
        get range(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Set <E> extends Internal.Collection<E> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface InputMethodRequests {
        getCommittedTextLength(): number
        getSelectedText(arg0: Internal.AttributedCharacterIterator$Attribute[]): Internal.AttributedCharacterIterator
        getInsertPositionOffset(): number
        getCommittedText(arg0: number, arg1: number, arg2: Internal.AttributedCharacterIterator$Attribute[]): Internal.AttributedCharacterIterator
        getLocationOffset(arg0: number, arg1: number): Internal.TextHitInfo
        cancelLatestCommittedText(arg0: Internal.AttributedCharacterIterator$Attribute[]): Internal.AttributedCharacterIterator
        getTextLocation(arg0: Internal.TextHitInfo): Internal.Rectangle
    }
    interface Object2CharFunction <K> extends Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        removeChar(arg0: any): string
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: K) => T_
        put(arg0: K, arg1: string): string
        put(arg0: K, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: any): string
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        apply(arg0: K): string
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getChar(arg0: any): string
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => string
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface WorldGenLevel extends Internal.ServerLevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    abstract class ImmutableCollection$Builder <E> {
        add(arg0: E[]): Internal.ImmutableCollection$Builder<E>
        add(arg0: E): Internal.ImmutableCollection$Builder<E>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableCollection$Builder<E>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableCollection$Builder<E>
        build(): Internal.ImmutableCollection<E>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LevelRenderer implements Internal.ResourceManagerReloadListener, Internal.AutoCloseable, Internal.LevelRendererAccessor, Internal.WorldRendererAccess, net.blay09.mods.kleeslabs.mixin.LevelRendererAccessor {
        handler$bgg000$preTerrainSetup(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        getClass(): Internal.Class<any>
        handler$bgg000$setSectionDirty(arg0: number, arg1: number, arg2: number, arg3: boolean, arg4: Internal.CallbackInfo): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$bgg000$endOpaque(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        handler$bjl000$renderLevel(arg0: Internal.CallbackInfo): void
        notifyAll(): void
        handler$bgg000$endTranslucent(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        localvar$bjl000$modifyPoseStack(arg0: Internal.PoseStack): Internal.PoseStack
        localvar$bjl000$modifyPartialTicks(arg0: number): number
        handler$zbn000$renderSky(arg0: Internal.PoseStack, arg1: Internal.Matrix4f, arg2: number, arg3: Internal.Runnable, arg4: Internal.CallbackInfo): void
        handler$bgg000$frameStart(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        notify(): void
        static callRenderShape_$md$204703$0(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.VoxelShape, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void
        hashCode(): number
        getDistanceSq(arg0: Internal.BlockEntity, arg1: number, arg2: number, arg3: number): number
        handler$bgg000$preOpaque(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        redirect$bbp000$renderTileEntity(arg0: Internal.BlockEntityRenderDispatcher, arg1: Internal.BlockEntity, arg2: number, arg3: Internal.PoseStack, arg4: Internal.MultiBufferSource): void
        redirect$zzg000$onRepositionCamera(arg0: Internal.ViewArea, arg1: number, arg2: number): void
        close(): void
        handler$zpn000$afterTESRRender(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        flywheel$getDestructionProgress(): (arg0: any) => any
        callRenderHitOutline(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.Entity, arg3: number, arg4: number, arg5: number, arg6: BlockPos, arg7: Internal.BlockState): void
        handler$bgg000$lightUpdated(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera, arg5: Internal.GameRenderer, arg6: Internal.LightTexture, arg7: Internal.Matrix4f, arg8: Internal.CallbackInfo): void
        equals(arg0: any): boolean
        toString(): string
        handler$bfn000$playStreamingMusic(arg0: Internal.SoundEvent, arg1: BlockPos, arg2: Internal.RecordItem, arg3: Internal.CallbackInfo): void
        playStreamingMusic(arg0: Internal.SoundEvent, arg1: BlockPos, arg2: Internal.RecordItem): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FocusEvent$Cause extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.FocusEvent$Cause
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.FocusEvent$Cause[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.FocusEvent$Cause): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FocusEvent$Cause>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.FocusEvent$Cause>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly UNEXPECTED : Internal.FocusEvent$Cause;
        static readonly CLEAR_GLOBAL_FOCUS_OWNER : Internal.FocusEvent$Cause;
        static readonly ACTIVATION : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_UP : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_FORWARD : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_DOWN : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_BACKWARD : Internal.FocusEvent$Cause;
        static readonly UNKNOWN : Internal.FocusEvent$Cause;
        static readonly MOUSE_EVENT : Internal.FocusEvent$Cause;
        static readonly ROLLBACK : Internal.FocusEvent$Cause;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FocusEvent$Cause>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2ObjectFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface WindowFocusListener extends Internal.EventListener {
        windowLostFocus(arg0: Internal.WindowEvent): void
        windowGainedFocus(arg0: Internal.WindowEvent): void
    }
    class ChannelOption <T> extends Internal.AbstractConstant<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf<T_>(arg0: string): Internal.ChannelOption<T_>
        static valueOf<T_>(arg0: Internal.Class<any>, arg1: string): Internal.ChannelOption<T_>
        notifyAll(): void
        static newInstance<T_>(arg0: string): Internal.ChannelOption<T_>
        compareTo(arg0: Internal.ChannelOption<Internal.ChannelOption<T>>): number
        compareTo(arg0: any): number
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        static exists(arg0: string): boolean
        toString(): string
        id(): number
        validate(arg0: Internal.ChannelOption<Internal.ChannelOption<T>>): void
        static readonly WRITE_BUFFER_HIGH_WATER_MARK : Internal.ChannelOption<number>;
        static readonly WRITE_BUFFER_LOW_WATER_MARK : Internal.ChannelOption<number>;
        static readonly DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION : Internal.ChannelOption<boolean>;
        static readonly IP_TOS : Internal.ChannelOption<number>;
        static readonly SINGLE_EVENTEXECUTOR_PER_GROUP : Internal.ChannelOption<boolean>;
        static readonly SO_SNDBUF : Internal.ChannelOption<number>;
        static readonly IP_MULTICAST_IF : Internal.ChannelOption<Internal.NetworkInterface>;
        static readonly WRITE_BUFFER_WATER_MARK : Internal.ChannelOption<Internal.WriteBufferWaterMark>;
        static readonly TCP_NODELAY : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN : Internal.ChannelOption<number>;
        static readonly SO_LINGER : Internal.ChannelOption<number>;
        static readonly SO_RCVBUF : Internal.ChannelOption<number>;
        static readonly SO_KEEPALIVE : Internal.ChannelOption<boolean>;
        static readonly ALLOCATOR : Internal.ChannelOption<Internal.ByteBufAllocator>;
        static readonly IP_MULTICAST_ADDR : Internal.ChannelOption<Internal.InetAddress>;
        static readonly IP_MULTICAST_LOOP_DISABLED : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN_CONNECT : Internal.ChannelOption<boolean>;
        static readonly MESSAGE_SIZE_ESTIMATOR : Internal.ChannelOption<Internal.MessageSizeEstimator>;
        static readonly WRITE_SPIN_COUNT : Internal.ChannelOption<number>;
        static readonly SO_TIMEOUT : Internal.ChannelOption<number>;
        static readonly SO_REUSEADDR : Internal.ChannelOption<boolean>;
        static readonly CONNECT_TIMEOUT_MILLIS : Internal.ChannelOption<number>;
        static readonly ALLOW_HALF_CLOSURE : Internal.ChannelOption<boolean>;
        static readonly SO_BACKLOG : Internal.ChannelOption<number>;
        static readonly MAX_MESSAGES_PER_READ : Internal.ChannelOption<number>;
        static readonly AUTO_CLOSE : Internal.ChannelOption<boolean>;
        static readonly MAX_MESSAGES_PER_WRITE : Internal.ChannelOption<number>;
        static readonly SO_BROADCAST : Internal.ChannelOption<boolean>;
        static readonly AUTO_READ : Internal.ChannelOption<boolean>;
        static readonly IP_MULTICAST_TTL : Internal.ChannelOption<number>;
        static readonly RCVBUF_ALLOCATOR : Internal.ChannelOption<Internal.RecvByteBufAllocator>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SkyRenderable {
        renderSky(arg0: Internal.PoseStack, arg1: number): void
    }
    class SoundEvent extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<Internal.SoundEvent>
        getRegistryName(): ResourceLocation
        toString(): string
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): Internal.SoundEvent
        setRegistryName(arg0: string): Internal.SoundEvent
        setRegistryName(arg0: string, arg1: string): Internal.SoundEvent
        notify(): void
        readonly delegate : () => Internal.SoundEvent;
        get registryType(): Internal.Class<Internal.SoundEvent>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractContainerMenu implements Internal.ContainerAccess, Internal.AbstractContainerMenuInvoker {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRemoteSlots(): Internal.NonNullList<any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getLastSlots(): Internal.NonNullList<any>
        toString(): string
        notify(): void
        _moveItemStackTo(arg0: Internal.ItemStack, arg1: number, arg2: number, arg3: boolean): boolean
        get remoteSlots(): Internal.NonNullList<any>;
        get lastSlots(): Internal.NonNullList<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LunarEventClientSettings {
        createClient(): Internal.LunarEventClient<any>
        getClass(): Internal.Class<any>
        codec(): Internal.Codec<Internal.LunarEventClientSettings>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMoonSize(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getMoonTextureLocation(): ResourceLocation
        getSoundTrack(): Internal.SoundEvent
        toString(): string
        getColorSettings(): Internal.ColorSettings
        notify(): void
        static readonly CODEC : Internal.Codec<Internal.LunarEventClientSettings>;
        get moonSize(): number;
        get moonTextureLocation(): ResourceLocation;
        get soundTrack(): Internal.SoundEvent;
        get colorSettings(): Internal.ColorSettings;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class VoxelShape implements Internal.VoxelShapeAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setFaces(arg0: Internal.VoxelShape[]): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getFaces(): Internal.VoxelShape[]
        getShape(): Internal.DiscreteVoxelShape
        toString(): string
        notify(): void
        setShape(arg0: Internal.DiscreteVoxelShape): void
        get shape(): Internal.DiscreteVoxelShape;
        get faces(): Internal.VoxelShape[];
        get class(): Internal.Class<any>;
        set shape(arg0: Internal.DiscreteVoxelShape);
        set faces(arg0: Internal.VoxelShape[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function11 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10, arg1: T11) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function4<T8, T9, T10, T11, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function3<T9, T10, T11, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function6<T6, T7, T8, T9, T10, T11, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function5<T7, T8, T9, T10, T11, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function8<T4, T5, T6, T7, T8, T9, T10, T11, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function7<T5, T6, T7, T8, T9, T10, T11, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function9<T3, T4, T5, T6, T7, T8, T9, T10, T11, R>
        curry(): (arg0: T1) => Internal.Function10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>
    }
    class Excluder implements Internal.TypeAdapterFactory, Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        disableInnerClassSerialization(): Internal.Excluder
        withModifiers(arg0: number[]): Internal.Excluder
        withVersion(arg0: number): Internal.Excluder
        excludeField(arg0: Internal.Field, arg1: boolean): boolean
        notify(): void
        hashCode(): number
        withExclusionStrategy(arg0: Internal.ExclusionStrategy, arg1: boolean, arg2: boolean): Internal.Excluder
        equals(arg0: any): boolean
        create<T_>(arg0: Internal.Gson, arg1: Internal.TypeToken<T_>): Internal.TypeAdapter<T_>
        toString(): string
        excludeClass(arg0: Internal.Class<any>, arg1: boolean): boolean
        excludeFieldsWithoutExposeAnnotation(): Internal.Excluder
        static readonly DEFAULT : Internal.Excluder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Vector <E> extends Internal.AbstractList<any> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        firstElement(): E
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): E
        remove(arg0: any): boolean
        capacity(): number
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<E>
        setSize(arg0: number): void
        stream(): Internal.Stream<E>
        setElementAt(arg0: E, arg1: number): void
        hashCode(): number
        get(arg0: number): E
        removeElementAt(arg0: number): void
        elementAt(arg0: number): E
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: any): number
        indexOf(arg0: any, arg1: number): number
        removeAllElements(): void
        add(arg0: E): boolean
        add(arg0: number, arg1: E): void
        subList(arg0: number, arg1: number): Internal.List<E>
        trimToSize(): void
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        copyInto(arg0: any[]): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: any, arg1: number): number
        lastIndexOf(arg0: any): number
        contains(arg0: any): boolean
        insertElementAt(arg0: E, arg1: number): void
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        lastElement(): E
        elements(): Internal.Enumeration<E>
        equals(arg0: any): boolean
        clone(): any
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        toString(): string
        addElement(arg0: E): void
        ensureCapacity(arg0: number): void
        removeElement(arg0: any): boolean
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IPlantable {
        getPlantType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.PlantType
        getPlant(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockState
    }
    interface RenderTypeExtension {
        flywheel$getDrawBuffer(): Internal.DrawBuffer
    }
    interface CompletionHandler <V, A> {
        completed(arg0: V, arg1: A): void
        failed(arg0: Internal.Throwable, arg1: A): void
    }
    class MutableColor4I extends Internal.Color4I {
        redf(): number
        getClass(): Internal.Class<any>
        rgba(): number
        static rgba(col: number): Internal.Color4I
        static rgba(r: number, g: number, b: number, a: number): Internal.Color4I
        addBrightness(b: number): Internal.Color4I
        addBrightness(percent: number): Internal.Color4I
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getChatFormattingColor(formatting: Internal.ChatFormatting): Internal.Color4I
        static getChatFormattingColor(id: number): Internal.Color4I
        withAlpha(a: number): Internal.Color4I
        lerp(col: Internal.Color4I, m: number): Internal.Color4I
        notifyAll(): void
        withTint(arg0: Internal.Color4I): Internal.Icon
        withTint(col: Internal.Color4I): Internal.Color4I
        static rgb(r: number, g: number, b: number): Internal.Color4I
        static rgb(col: number): Internal.Color4I
        rgb(): number
        static rgb(color: Vec3): Internal.Color4I
        redi(): number
        notify(): void
        createPixelBuffer(): Internal.PixelBuffer
        hashCode(): number
        bluei(): number
        mutable(): Internal.MutableColor4I
        bluef(): number
        copy(): Internal.Color4I
        copy(): Internal.Icon
        copy(): Internal.MutableColor4I
        hasPixelBuffer(): boolean
        combineWith(icon: Internal.Icon): Internal.Icon
        combineWith(icons: Internal.Icon[]): Internal.Icon
        getJson(): Internal.JsonElement
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        set(col: number, a: number): Internal.Color4I
        set(col: number): Internal.Color4I
        set(col: Internal.Color4I): Internal.Color4I
        set(r: number, g: number, b: number, a: number): Internal.Color4I
        set(col: Internal.Color4I, a: number): Internal.Color4I
        withBorder(color: Internal.Color4I, roundEdges: boolean): Internal.Icon
        alphaf(): number
        alphai(): number
        withColor(color: Internal.Color4I): Internal.Icon
        isEmpty(): boolean
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon
        setAlpha(a: number): Internal.Color4I
        draw(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        draw3D(matrixStack: Internal.PoseStack): void
        whiteIfEmpty(): Internal.Color4I
        static getIcon(id: string): Internal.Icon
        static getIcon(json: Internal.JsonElement): Internal.Icon
        static getIcon(id: ResourceLocation): Internal.Icon
        toStyle(): Internal.Style
        isMutable(): boolean
        getIngredient(): any
        static hsb(h: number, s: number, b: number): Internal.Color4I
        equals(o: any): boolean
        withPadding(padding: number): Internal.Icon
        withAlphaf(alpha: number): Internal.Color4I
        static fromJson(element: Internal.JsonElement): Internal.Color4I
        greenf(): number
        toString(): string
        static get256(id: number): Internal.Color4I
        setFromHSB(h: number, s: number, b: number): Internal.Color4I
        static fromString(s: string): Internal.Color4I
        greeni(): number
        static readonly RED : Internal.Color4I;
        static readonly GRAY : Internal.Color4I;
        static readonly WHITE : Internal.Color4I;
        static readonly LIGHT_RED : Internal.Color4I;
        static readonly TEMP : Internal.Color4I;
        static readonly BLUE : Internal.Color4I;
        static readonly LIGHT_BLUE : Internal.Color4I;
        static readonly LIGHT_GREEN : Internal.Color4I;
        static readonly BLACK : Internal.Color4I;
        static readonly DARK_GRAY : Internal.Color4I;
        static readonly GREEN : Internal.Color4I;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set alpha(a: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FieldNamingPolicy extends Internal.Enum<any> implements Internal.FieldNamingStrategy {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.FieldNamingPolicy
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.FieldNamingPolicy[]
        translateName(arg0: Internal.Field): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.FieldNamingPolicy): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FieldNamingPolicy>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.FieldNamingPolicy>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly IDENTITY : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE_WITH_SPACES : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DOTS : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_UNDERSCORES : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DASHES : Internal.FieldNamingPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FieldNamingPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class QuestShape extends Internal.Icon {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getShapePixels(): Internal.PixelBuffer
        withTint(color: Internal.Color4I): Internal.Icon
        notify(): void
        createPixelBuffer(): Internal.PixelBuffer
        static reload(list: Internal.List<string>): void
        hashCode(): number
        static get(id: string): Internal.QuestShape
        copy(): Internal.Icon
        hasPixelBuffer(): boolean
        combineWith(icon: Internal.Icon): Internal.Icon
        combineWith(icons: Internal.Icon[]): Internal.Icon
        getJson(): Internal.JsonElement
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        withBorder(color: Internal.Color4I, roundEdges: boolean): Internal.Icon
        withColor(color: Internal.Color4I): Internal.Icon
        isEmpty(): boolean
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon
        draw(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        draw3D(matrixStack: Internal.PoseStack): void
        static getIcon(id: string): Internal.Icon
        static getIcon(json: Internal.JsonElement): Internal.Icon
        static getIcon(id: ResourceLocation): Internal.Icon
        getIngredient(): any
        equals(o: any): boolean
        withPadding(padding: number): Internal.Icon
        toString(): string
        readonly outline : Internal.ImageIcon;
        static idMapWithDefault : Internal.NameMap<string>;
        readonly shape : Internal.ImageIcon;
        readonly background : Internal.ImageIcon;
        static idMap : Internal.NameMap<string>;
        readonly id : string;
        static readonly MAP : Internal.Map<string, Internal.QuestShape>;
        static readonly EMPTY : Internal.Color4I;
        get shapePixels(): Internal.PixelBuffer;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P1 <F, T1> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: (arg0: T1) => R): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, (arg0: T1) => R>): Internal.App<F, R>
        hashCode(): number
        and<T2, T3, T4, T5, T6, T7>(arg0: Internal.Products$P6<F, T2, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P7<F, T2, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T2, T3, T4, T5>(arg0: Internal.Products$P4<F, T2, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T2, T3>(arg0: Internal.Products$P2<F, T2, T3>): Internal.Products$P3<F, T1, T2, T3>
        and<T2, T3, T4>(arg0: Internal.Products$P3<F, T2, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T2>(arg0: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        and<T2, T3, T4, T5, T6>(arg0: Internal.Products$P5<F, T2, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LootContextUser {
    }
    class TextColor implements Internal.ColorAccess, Internal.Color {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRgbKJS(): number
        getColorRaw(): number
        static create_$md$204703$0(arg0: number): Internal.TextColor
        notifyAll(): void
        getSerializeKJS(): string
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        getHexKJS(): string
        createTextColorKJS(): Internal.TextColor
        getArgbKJS(): number
        toString(): string
        getFireworkColorKJS(): number
        specialEquals(o: any, shallow: boolean): boolean
        get colorRaw(): number;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockEntityRenderDispatcher implements Internal.ResourceManagerReloadListener, Internal.BlockEntityRenderDispatcherAccessor {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        flywheel$getRenderers(): Internal.Map<any, any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ByteBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ByteBuffer> {
        asIntBuffer(): Internal.IntBuffer
        getClass(): Internal.Class<any>
        compact(): Internal.ByteBuffer
        asLongBuffer(): Internal.LongBuffer
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuffer): number
        put(arg0: Internal.ByteBuffer): Internal.ByteBuffer
        put(arg0: number, arg1: number): Internal.ByteBuffer
        put(arg0: number, arg1: Internal.ByteBuffer, arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number): Internal.ByteBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        slice(): Internal.ByteBuffer
        slice(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.ByteBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        limit(arg0: number): Internal.Buffer
        limit(arg0: number): Internal.ByteBuffer
        limit(): number
        order(): Internal.ByteOrder
        order(arg0: Internal.ByteOrder): Internal.ByteBuffer
        asFloatBuffer(): Internal.FloatBuffer
        asCharBuffer(): Internal.CharBuffer
        static allocateDirect(arg0: number): Internal.ByteBuffer
        putInt(arg0: number, arg1: number): Internal.ByteBuffer
        putInt(arg0: number): Internal.ByteBuffer
        duplicate(): Internal.ByteBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        putFloat(arg0: number): Internal.ByteBuffer
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer
        getInt(): number
        getInt(arg0: number): number
        getChar(): string
        getChar(arg0: number): string
        static allocate(arg0: number): Internal.ByteBuffer
        reset(): Internal.ByteBuffer
        reset(): Internal.Buffer
        position(arg0: number): Internal.ByteBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        asShortBuffer(): Internal.ShortBuffer
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer
        putDouble(arg0: number): Internal.ByteBuffer
        getDouble(): number
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        getFloat(): number
        putLong(arg0: number, arg1: number): Internal.ByteBuffer
        putLong(arg0: number): Internal.ByteBuffer
        notify(): void
        asReadOnlyBuffer(): Internal.ByteBuffer
        capacity(): number
        isReadOnly(): boolean
        asDoubleBuffer(): Internal.DoubleBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        get(arg0: number): number
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        get(): number
        get(arg0: number, arg1: number[]): Internal.ByteBuffer
        get(arg0: number[]): Internal.ByteBuffer
        arrayOffset(): number
        putShort(arg0: number): Internal.ByteBuffer
        putShort(arg0: number, arg1: number): Internal.ByteBuffer
        flip(): Internal.Buffer
        flip(): Internal.ByteBuffer
        hasArray(): boolean
        getShort(arg0: number): number
        getShort(): number
        putChar(arg0: number, arg1: string): Internal.ByteBuffer
        putChar(arg0: string): Internal.ByteBuffer
        hasRemaining(): boolean
        clear(): Internal.ByteBuffer
        clear(): Internal.Buffer
        getLong(arg0: number): number
        getLong(): number
        alignmentOffset(arg0: number, arg1: number): number
        rewind(): Internal.Buffer
        rewind(): Internal.ByteBuffer
        mismatch(arg0: Internal.ByteBuffer): number
        equals(arg0: any): boolean
        toString(): string
        alignedSlice(arg0: number): Internal.ByteBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.ByteBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        mark(): Internal.Buffer
        mark(): Internal.ByteBuffer
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelGenerator$Face {
        getClass(): Internal.Class<any>
        uv(u0: number, v0: number, u1: number, v1: number): Internal.ModelGenerator$Face
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        hashCode(): number
        tex(t: string): Internal.ModelGenerator$Face
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        cull(): Internal.ModelGenerator$Face
        cull(d: Internal.Direction): Internal.ModelGenerator$Face
        notify(): void
        tintindex(i: number): Internal.ModelGenerator$Face
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IngredientActionFilter {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        checkFilter(index: number, stack: Internal.ItemStack): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        static filterOf(o: any): Internal.IngredientActionFilter
        notify(): void
        copyFrom(filter: Internal.IngredientActionFilter): void
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VariantBlockStateGenerator$Model {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        uvlock(): Internal.VariantBlockStateGenerator$Model
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        x(_x: number): Internal.VariantBlockStateGenerator$Model
        y(_y: number): Internal.VariantBlockStateGenerator$Model
        toString(): string
        model(s: string): Internal.VariantBlockStateGenerator$Model
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SetMultimap <K, V> extends Internal.Multimap<K, V> {
        containsEntry(arg0: any, arg1: any): boolean
        keys(): Internal.Multiset<K>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        asMap(): Internal.Map<K, Internal.Collection<V>>
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Set<V>
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<any>
        removeAll(arg0: any): Internal.Set<V>
        entries(): Internal.Set<Internal.Map$Entry<K, V>>
        entries(): Internal.Collection<any>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: any): boolean
        get(arg0: K): Internal.Set<V>
        get(arg0: any): Internal.Collection<any>
        keySet(): Internal.Set<K>
    }
    abstract class FocusTraversalPolicy {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getInitialComponent(arg0: Internal.Window): java_.awt.Component
        getComponentBefore(arg0: java_.awt.Container, arg1: java_.awt.Component): java_.awt.Component
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getFirstComponent(arg0: java_.awt.Container): java_.awt.Component
        toString(): string
        getLastComponent(arg0: java_.awt.Container): java_.awt.Component
        getComponentAfter(arg0: java_.awt.Container, arg1: java_.awt.Component): java_.awt.Component
        notify(): void
        getDefaultComponent(arg0: java_.awt.Container): java_.awt.Component
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractObjectCollection <K> extends Internal.AbstractCollection<any> implements Internal.ObjectCollection<K> {
        add(arg0: K): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: K) => void): void
        notifyAll(): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        notify(): void
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: K) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.ObjectIterator<K>
        iterator(): Internal.Iterator<any>
        size(): number
        stream(): Internal.Stream<K>
        addAll(arg0: Internal.Collection<K>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<K>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelGenerator$Element {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        face(direction: Internal.Direction, consumer: (arg0: Internal.ModelGenerator$Face) => void): void
        toJson(): Internal.JsonObject
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        box(b: Internal.AABB): Internal.ModelGenerator$Element
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IExtensibleEnum {
        init(): void
    }
    abstract class SampleModel {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        createSubsetSampleModel(arg0: number[]): Internal.SampleModel
        setPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): void
        setPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): void
        setPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): void
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): void
        notifyAll(): void
        getDataType(): number
        getSampleFloat(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer): number
        getSampleSize(arg0: number): number
        getSampleSize(): number[]
        getNumDataElements(): number
        getNumBands(): number
        getWidth(): number
        notify(): void
        getHeight(): number
        getTransferType(): number
        createDataBuffer(): Internal.DataBuffer
        hashCode(): number
        createCompatibleSampleModel(arg0: number, arg1: number): Internal.SampleModel
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): number[]
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer): number[]
        setDataElements(arg0: number, arg1: number, arg2: any, arg3: Internal.DataBuffer): void
        setDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any, arg5: Internal.DataBuffer): void
        getSampleDouble(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer): number
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): void
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): void
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): void
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): number[]
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer): number[]
        getPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): number[]
        getPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): number[]
        getPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer): number[]
        equals(arg0: any): boolean
        getDataElements(arg0: number, arg1: number, arg2: any, arg3: Internal.DataBuffer): any
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any, arg5: Internal.DataBuffer): any
        toString(): string
        getSample(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer): number
        setSample(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.DataBuffer): void
        setSample(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.DataBuffer): void
        setSample(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.DataBuffer): void
        get numDataElements(): number;
        get numBands(): number;
        get dataType(): number;
        get width(): number;
        get transferType(): number;
        get sampleSize(): number[];
        get class(): Internal.Class<any>;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContainerListener extends Internal.EventListener {
        componentRemoved(arg0: Internal.ContainerEvent): void
        componentAdded(arg0: Internal.ContainerEvent): void
    }
    class Capability <T> {
        getClass(): Internal.Class<any>
        orEmpty<R>(arg0: Internal.Capability<R>, arg1: Internal.LazyOptional<T>): Internal.LazyOptional<R>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        isRegistered(): boolean
        notify(): void
        addListener(arg0: (arg0: Internal.Capability<T>) => void): Internal.Capability<T>
        get name(): string;
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PrintWriter extends Internal.Writer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        format(arg0: string, arg1: any[]): Internal.PrintWriter
        format(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintWriter
        checkError(): boolean
        notify(): void
        printf(arg0: string, arg1: any[]): Internal.PrintWriter
        printf(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintWriter
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: string): void
        print(arg0: boolean): void
        print(arg0: any): void
        print(arg0: string): void
        print(arg0: string[]): void
        print(arg0: number): void
        println(arg0: string[]): void
        println(): void
        println(arg0: boolean): void
        println(arg0: string): void
        println(arg0: any): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: string): void
        flush(): void
        hashCode(): number
        equals(arg0: any): boolean
        static nullWriter(): Internal.Writer
        toString(): string
        close(): void
        write(arg0: string[], arg1: number, arg2: number): void
        write(arg0: string): void
        write(arg0: string, arg1: number, arg2: number): void
        write(arg0: string[]): void
        write(arg0: number): void
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintWriter
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer
        append(arg0: string): Internal.PrintWriter
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.Writer
        append(arg0: Internal.CharSequence): Internal.PrintWriter
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Writer
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
    }
    class ThreadGroup implements Internal.Thread$UncaughtExceptionHandler {
        setMaxPriority(arg0: number): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        notifyAll(): void
        notify(): void
        hashCode(): number
        isDaemon(): boolean
        interrupt(): void
        activeGroupCount(): number
        enumerate(arg0: Internal.ThreadGroup[], arg1: boolean): number
        enumerate(arg0: Internal.ThreadGroup[]): number
        enumerate(arg0: Internal.Thread[]): number
        enumerate(arg0: Internal.Thread[], arg1: boolean): number
        suspend(): void
        activeCount(): number
        resume(): void
        getParent(): Internal.ThreadGroup
        isDestroyed(): boolean
        destroy(): void
        parentOf(arg0: Internal.ThreadGroup): boolean
        list(): void
        checkAccess(): void
        setDaemon(arg0: boolean): void
        allowThreadSuspension(arg0: boolean): boolean
        getMaxPriority(): number
        stop(): void
        equals(arg0: any): boolean
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void
        toString(): string
        get parent(): Internal.ThreadGroup;
        get destroyed(): boolean;
        get maxPriority(): number;
        get name(): string;
        get class(): Internal.Class<any>;
        get daemon(): boolean;
        set maxPriority(arg0: number);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BufferLayout {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getStride(): number
        hashCode(): number
        getLayoutItems(): Internal.List<Internal.LayoutItem>
        notifyAll(): void
        equals(arg0: any): boolean
        static builder(): Internal.BufferLayout$Builder
        toString(): string
        getAttributeCount(): number
        notify(): void
        get layoutItems(): Internal.List<Internal.LayoutItem>;
        get attributeCount(): number;
        get stride(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockEntity extends Internal.CapabilityProvider<any> implements Internal.IForgeBlockEntity {
        requestModelDataUpdate(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        getTileData(): Internal.CompoundTag
        notifyAll(): void
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.BlockEntity>): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        notify(): void
        reviveCaps(): void
        getModelData(): Internal.IModelData
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        getRenderBoundingBox(): Internal.AABB
        hashCode(): number
        onChunkUnloaded(): void
        equals(arg0: any): boolean
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void
        onLoad(): void
        toString(): string
        handleUpdateTag(arg0: Internal.CompoundTag): void
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        get modelData(): Internal.IModelData;
        get renderBoundingBox(): Internal.AABB;
        get tileData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ConditionalFunction implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        survivesExplosion(): Internal.ConditionContainer
        notifyAll(): void
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        addCondition(o: Internal.JsonObject): Internal.ConditionalFunction
        notify(): void
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        hashCode(): number
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(o: Internal.JsonObject): Internal.ConditionalFunction
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        equals(arg0: any): boolean
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        toString(): string
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        function : Internal.JsonObject;
        conditions : Internal.JsonArray;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractLongCollection extends Internal.AbstractCollection<any> implements Internal.LongCollection {
        getClass(): Internal.Class<any>
        longIterator(): Internal.LongIterator
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        remove(arg0: any): boolean
        removeAll(arg0: Internal.LongCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.LongIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        longStream(): Internal.LongStream
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        longSpliterator(): Internal.LongSpliterator
        toLongArray(): number[]
        toLongArray(arg0: number[]): number[]
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.LongSpliterator
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: Internal.LongConsumer): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.LongCollection): boolean
        isEmpty(): boolean
        clear(): void
        longParallelStream(): Internal.LongStream
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.LongPredicate): boolean
        contains(arg0: any): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.Collection<number>): boolean
        addAll(arg0: Internal.LongCollection): boolean
        equals(arg0: any): boolean
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.LongCollection): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor$OfMethod <F, M> extends Internal.TypeDescriptor {
        parameterType(arg0: number): F
        parameterArray(): F[]
        dropParameterTypes(arg0: number, arg1: number): M
        parameterCount(): number
        changeReturnType(arg0: F): M
        descriptorString(): string
        parameterList(): Internal.List<F>
        insertParameterTypes(arg0: number, arg1: F[]): M
        returnType(): F
        changeParameterType(arg0: number, arg1: F): M
    }
    class FireworkRocketEntity extends Internal.Projectile implements Internal.ItemSupplier, Internal.FireworkRocketEntityKJS {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setLifetimeKJS(arg0: number): void
        isDynamicLightEnabled(): boolean
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        revive(): void
        dynamicLightTick(): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        notify(): void
        hashCode(): number
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        asKJS(): any
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set remainingFireTicks(arg0: number);
        set lifetimeKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableSet$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: any): Internal.ImmutableCollection$Builder<any>
        add(arg0: E): Internal.ImmutableSet$Builder<E>
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableSet$Builder<E>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableSet$Builder<E>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableSet$Builder<E>
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        build(): Internal.ImmutableCollection<any>
        build(): Internal.ImmutableSet<E>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ObjectArrayList <K> extends Internal.AbstractObjectList<any> implements Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>
        static toList<K_>(): Internal.Collector<K_, any, Internal.ObjectArrayList<K_>>
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ObjectArrayList<K>): number
        compareTo(arg0: Internal.List<K>): number
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<any>
        iterator(): Internal.ObjectListIterator<K>
        removeAll(arg0: Internal.Collection<any>): boolean
        trim(): void
        trim(arg0: number): void
        toArray<K_>(arg0: K_[]): K_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<K>
        indexOf(arg0: any): number
        add(arg0: number, arg1: K): void
        add(arg0: K): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        sort(arg0: Internal.Comparator<K>): void
        push(arg0: K): void
        removeIf(arg0: (arg0: K) => boolean): boolean
        contains(arg0: any): boolean
        size(): number
        size(arg0: number): void
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.ObjectListIterator<K>
        ensureCapacity(arg0: number): void
        unstableSort(arg0: Internal.Comparator<K>): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        replaceAll(arg0: (arg0: any) => any): void
        notify(): void
        remove(arg0: number): K
        remove(arg0: any): boolean
        pop(): K
        top(): K
        stream(): Internal.Stream<K>
        hashCode(): number
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        addElements(arg0: number, arg1: K[]): void
        static of<K_>(arg0: K_[]): Internal.ObjectArrayList<K_>
        static of<K_>(): Internal.ObjectArrayList<K_>
        get(arg0: number): K
        static toListWithExpectedSize<K_>(arg0: number): Internal.Collector<K_, any, Internal.ObjectArrayList<K_>>
        subList(arg0: number, arg1: number): Internal.List<any>
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        set(arg0: number, arg1: K): K
        forEach(arg0: (arg0: K) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        setElements(arg0: K[]): void
        setElements(arg0: number, arg1: K[]): void
        removeElements(arg0: number, arg1: number): void
        peek(arg0: number): K
        lastIndexOf(arg0: any): number
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean
        addAll(arg0: Internal.Collection<K>): boolean
        addAll(arg0: Internal.ObjectList<K>): boolean
        elements(): K[]
        equals(arg0: Internal.ObjectArrayList<K>): boolean
        equals(arg0: any): boolean
        clone(): any
        clone(): Internal.ObjectArrayList<K>
        toString(): string
        static wrap<K_>(arg0: K_[]): Internal.ObjectArrayList<K_>
        static wrap<K_>(arg0: K_[], arg1: number): Internal.ObjectArrayList<K_>
        retainAll(arg0: Internal.Collection<any>): boolean
        static readonly DEFAULT_INITIAL_CAPACITY : 10;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FTBQuestsKubeJSWrapper {
        getQuestObjectTypes(): Internal.Map<string, (arg0: any) => boolean>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getObject(world: Internal.LevelJS, id: any): Internal.QuestObjectBase
        getServerDataFromPlayer(player: Internal.Player): Internal.FTBQuestsKubeJSPlayerData
        getQuestShapes(): Internal.Map<string, Internal.QuestShape>
        notifyAll(): void
        getFile(world: Internal.LevelJS): Internal.QuestFile
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        getServerDataFromSource(source: Internal.CommandSourceStack): Internal.FTBQuestsKubeJSPlayerData
        toString(): string
        getData(player: Internal.PlayerJS<any>): Internal.TeamData
        getData(world: Internal.LevelJS, uuid: Internal.UUID): Internal.TeamData
        static readonly INSTANCE : Internal.FTBQuestsKubeJSWrapper;
        get questShapes(): Internal.Map<string, Internal.QuestShape>;
        get class(): Internal.Class<any>;
        get questObjectTypes(): Internal.Map<string, (arg0: any) => boolean>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        getPlayerData(player: Internal.Player): Internal.ClientPlayerDataJS
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void
        getTime(): number
        notifyAll(): void
        getSide(): Internal.ScriptType
        getGameRules(): Internal.GameRulesJS
        notify(): void
        setRainStrength(strength: number): void
        getMinecraftPlayer(): Internal.LocalPlayer
        hashCode(): number
        getDimension(): string
        isDaytime(): boolean
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        getMinecraftLevel(): Internal.ClientLevel
        getMinecraftLevel(): net.minecraft.world.level.Level
        getServer(): Internal.ServerJS
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS
        getBlock(pos: BlockPos): Internal.BlockContainerJS
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS
        isOverworld(): boolean
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS
        getEntity(e: Internal.Entity): Internal.EntityJS
        getMinecraft(): Internal.Minecraft
        createEntity(id: ResourceLocation): Internal.EntityJS
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void
        getLocalTime(): number
        equals(arg0: any): boolean
        isThundering(): boolean
        getEntities(): Internal.EntityArrayList
        toString(): string
        static getInstance(): Internal.ClientLevelJS
        isRaining(): boolean
        static setInstance(instance: Internal.ClientLevelJS): void
        readonly clientPlayerData : Internal.ClientPlayerDataJS;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get minecraft(): Internal.Minecraft;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get instance(): Internal.ClientLevelJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.LocalPlayer;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set instance(instance: Internal.ClientLevelJS);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataFlavor implements Internal.Externalizable, Internal.Cloneable {
        isFlavorJavaFileListType(): boolean
        getClass(): Internal.Class<any>
        static getTextPlainUnicodeFlavor(): Internal.DataFlavor
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getDefaultRepresentationClass(): Internal.Class<any>
        getPrimaryType(): string
        notifyAll(): void
        getSubType(): string
        isMimeTypeEqual(arg0: string): boolean
        isMimeTypeEqual(arg0: Internal.DataFlavor): boolean
        notify(): void
        hashCode(): number
        isRepresentationClassSerializable(): boolean
        getDefaultRepresentationClassAsString(): string
        isRepresentationClassCharBuffer(): boolean
        isRepresentationClassByteBuffer(): boolean
        getParameter(arg0: string): string
        writeExternal(arg0: Internal.ObjectOutput): void
        static selectBestTextFlavor(arg0: Internal.DataFlavor[]): Internal.DataFlavor
        setHumanPresentableName(arg0: string): void
        isMimeTypeSerializedObject(): boolean
        getMimeType(): string
        getReaderForText(arg0: Internal.Transferable): Internal.Reader
        match(arg0: Internal.DataFlavor): boolean
        isFlavorTextType(): boolean
        isFlavorSerializedObjectType(): boolean
        getHumanPresentableName(): string
        getRepresentationClass(): Internal.Class<any>
        isRepresentationClassInputStream(): boolean
        equals(arg0: Internal.DataFlavor): boolean
        equals(arg0: any): boolean
        equals(arg0: string): boolean
        isFlavorRemoteObjectType(): boolean
        isRepresentationClassReader(): boolean
        readExternal(arg0: Internal.ObjectInput): void
        clone(): any
        toString(): string
        isRepresentationClassRemote(): boolean
        static readonly javaJVMLocalObjectMimeType : "application/x-java-jvm-local-objectref";
        static readonly stringFlavor : Internal.DataFlavor;
        static readonly javaFileListFlavor : Internal.DataFlavor;
        static readonly javaSerializedObjectMimeType : "application/x-java-serialized-object";
        static readonly plainTextFlavor : Internal.DataFlavor;
        static readonly javaRemoteObjectMimeType : "application/x-java-remote-object";
        static readonly imageFlavor : Internal.DataFlavor;
        static readonly selectionHtmlFlavor : Internal.DataFlavor;
        static readonly allHtmlFlavor : Internal.DataFlavor;
        static readonly fragmentHtmlFlavor : Internal.DataFlavor;
        get representationClass(): Internal.Class<any>;
        get flavorRemoteObjectType(): boolean;
        get representationClassSerializable(): boolean;
        get mimeTypeSerializedObject(): boolean;
        get humanPresentableName(): string;
        get mimeType(): string;
        get representationClassInputStream(): boolean;
        get defaultRepresentationClassAsString(): string;
        get flavorSerializedObjectType(): boolean;
        get representationClassReader(): boolean;
        get representationClassRemote(): boolean;
        get representationClassByteBuffer(): boolean;
        get primaryType(): string;
        get textPlainUnicodeFlavor(): Internal.DataFlavor;
        get subType(): string;
        get defaultRepresentationClass(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get flavorTextType(): boolean;
        get flavorJavaFileListType(): boolean;
        get representationClassCharBuffer(): boolean;
        set humanPresentableName(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FeatureAccess {
    }
    interface ClientLevelExtension {
        flywheel$getAllLoadedEntities(): Internal.Iterable<Internal.Entity>
    }
    class StringProperty extends Internal.TeamProperty<any> {
        getClass(): Internal.Class<any>
        readValue(buf: Internal.FriendlyByteBuf): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        fromNBT(tag: Internal.Tag): Internal.Optional<string>
        notifyAll(): void
        notify(): void
        toNBT(value: string): Internal.Tag
        getType(): Internal.TeamPropertyType<string>
        hashCode(): number
        equals(o: any): boolean
        toString(): string
        toString(value: string): string
        fromString(string: string): Internal.Optional<string>
        writeValue(buf: Internal.FriendlyByteBuf, value: string): void
        write(buf: Internal.FriendlyByteBuf): void
        config(config: Internal.ConfigGroup, value: Internal.TeamPropertyValue<string>): void
        readonly defaultValue : string;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getValue(): V
        getKey(): number
        getKey(): any
        hashCode(): number
        setValue(arg0: V): V
        equals(arg0: any): boolean
        getLongKey(): number
    }
    interface AccessorIngredient {
    }
    class CraftingContainer implements Internal.Container, Internal.StackedContentsCompatible {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchService extends Internal.Closeable {
        take(): Internal.WatchKey
        poll(arg0: number, arg1: Internal.TimeUnit): Internal.WatchKey
        poll(): Internal.WatchKey
        close(): void
    }
    class JobAttributes$DialogType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly NATIVE : Internal.JobAttributes$DialogType;
        static readonly COMMON : Internal.JobAttributes$DialogType;
        static readonly NONE : Internal.JobAttributes$DialogType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VertexFormat$Mode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.VertexFormat$Mode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.VertexFormat$Mode[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.VertexFormat$Mode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.VertexFormat$Mode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.VertexFormat$Mode>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly QUADS : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_FAN : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLES : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_STRIP : Internal.VertexFormat$Mode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.VertexFormat$Mode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongUnaryOperator {
        applyAsLong(arg0: number): number
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
    }
    interface ObjectIterator <K> extends Internal.Iterator<K> {
        next(): K
        hasNext(): boolean
        skip(arg0: number): number
        forEachRemaining(arg0: (arg0: K) => void): void
        remove(): void
    }
    interface GeneratedClassLoader {
        defineClass(arg0: string, arg1: number[]): Internal.Class<any>
        linkClass(arg0: Internal.Class<any>): void
    }
    interface Float2IntFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface EventLoop extends Internal.OrderedEventExecutor, Internal.EventLoopGroup {
        next(): Internal.EventExecutor
        next(): Internal.EventLoop
        terminationFuture(): Internal.Future<any>
        parent(): Internal.EventLoopGroup
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>
        submit(arg0: Internal.Runnable): Internal.Future<any>
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>
        shutdownGracefully(): Internal.Future<any>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>
        isTerminated(): boolean
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        shutdownNow(): Internal.List<Internal.Runnable>
        newPromise<V_>(): Internal.Promise<V_>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        spliterator(): Internal.Spliterator<Internal.EventExecutor>
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_
        shutdown(): void
        register(arg0: io.netty.channel.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: io.netty.channel.Channel): Internal.ChannelFuture
        isShutdown(): boolean
    }
    class BlockRegistryEventJS extends Internal.StartupEventJS {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        post(id: string): boolean
        post(id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        create(name: string, callback: (arg0: Internal.BlockBuilder) => void): void
        toString(): string
        notify(): void
        canCancel(): boolean
        addDetector(id: string): void
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class UserPrincipalLookupService {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        lookupPrincipalByGroupName(arg0: string): Internal.GroupPrincipal
        lookupPrincipalByName(arg0: string): Internal.UserPrincipal
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WeightedEntry {
    }
    interface Float2ShortFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class Registry <T> implements Internal.Keyable, Internal.IdMap<T>, Internal.ForgeAccessorRegistry, Internal.RegistryAccess {
        getClass(): Internal.Class<any>
        iterator(): Internal.Iterator<T>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        hashCode(): number
        keys<U_>(arg0: Internal.DynamicOps<U_>): Internal.Stream<U_>
        notifyAll(): void
        equals(arg0: any): boolean
        static invokeRegisterSimple_$md$204703$1(arg0: Internal.ResourceKey<any>, arg1: () => any)): Internal.Registry<any>
        static callRegisterDefaulted_$md$204703$0(arg0: Internal.ResourceKey<any>, arg1: string, arg2: () => any)): Internal.DefaultedRegistry<any>
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AccessibleRelationSet {
        add(arg0: Internal.AccessibleRelation): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        clear(): void
        notify(): void
        remove(arg0: Internal.AccessibleRelation): boolean
        contains(arg0: string): boolean
        size(): number
        addAll(arg0: Internal.AccessibleRelation[]): void
        hashCode(): number
        equals(arg0: any): boolean
        get(arg0: string): Internal.AccessibleRelation
        toArray(): Internal.AccessibleRelation[]
        toString(): string
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ITeleporter {
        getPortalInfo(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: (arg0: Internal.ServerLevel) => Internal.PortalInfo): Internal.PortalInfo
        isVanilla(): boolean
        playTeleportSound(arg0: Internal.ServerPlayer, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel): boolean
        placeEntity(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel, arg3: number, arg4: (arg0: boolean) => Internal.Entity): Internal.Entity
    }
    class WindowEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>
        setSource(arg0: any): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getWindow(): Internal.Window
        notifyAll(): void
        getID(): number
        getOldState(): number
        notify(): void
        getNewState(): number
        paramString(): string
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        getOppositeWindow(): Internal.Window
        toString(): string
        getComponent(): java_.awt.Component
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly WINDOW_CLOSED : 202;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly WINDOW_ICONIFIED : 203;
        static readonly WINDOW_GAINED_FOCUS : 207;
        static readonly WINDOW_DEICONIFIED : 204;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly WINDOW_CLOSING : 201;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly WINDOW_OPENED : 200;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly WINDOW_LOST_FOCUS : 208;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly WINDOW_STATE_CHANGED : 209;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly WINDOW_ACTIVATED : 205;
        static readonly WINDOW_DEACTIVATED : 206;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly WINDOW_LAST : 209;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly WINDOW_FIRST : 200;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get component(): java_.awt.Component;
        get oldState(): number;
        get window(): Internal.Window;
        get iD(): number;
        get source(): any;
        get oppositeWindow(): Internal.Window;
        get class(): Internal.Class<any>;
        get newState(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractReferenceCountedByteBuf extends Internal.AbstractByteBuf {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        release(): boolean
        release(arg0: number): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        nioBufferCount(): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(arg0: number): boolean
        isReadable(): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(arg0: number): Internal.ByteBuf
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        isWritable(arg0: number): boolean
        isWritable(): boolean
        notify(): void
        readChar(): string
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        hasMemoryAddress(): boolean
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readDouble(): number
        readUnsignedShortLE(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        copy(arg0: number, arg1: number): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        writeInt(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        readFloatLE(): number
        hasArray(): boolean
        getDoubleLE(arg0: number): number
        memoryAddress(): number
        maxFastWritableBytes(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: any): boolean
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBoolean(): boolean
        toString(): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        isDirect(): boolean
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getClass(): Internal.Class<any>
        getFloatLE(arg0: number): number
        readerIndex(): number
        readerIndex(arg0: number): Internal.ByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ByteBuf): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(): Internal.ByteBuffer
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        discardSomeReadBytes(): Internal.ByteBuf
        touch(arg0: any): Internal.ByteBuf
        touch(arg0: any): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
        touch(): Internal.ReferenceCounted
        duplicate(): Internal.ByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(): number
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        getChar(arg0: number): string
        retainedDuplicate(): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        readMedium(): number
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        readUnsignedShort(): number
        getMedium(arg0: number): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        notifyAll(): void
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        hashCode(): number
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readLongLE(): number
        readUnsignedMediumLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        isContiguous(): boolean
        writeDoubleLE(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MapCodec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>, arg2: Internal.DataResult<A>): Internal.DataResult<A>
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
    }
    interface Long2LongFunction extends Internal.Function<number, number>, Internal.LongUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: any): number
        remove(arg0: any): any
        remove(arg0: number): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: any): number
        get(arg0: any): any
        get(arg0: number): number
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsLong(arg0: number): number
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class LootCrate {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        readData(nbt: Internal.CompoundTag): void
        readNetData(data: Internal.FriendlyByteBuf): void
        notifyAll(): void
        createStack(): Internal.ItemStack
        writeData(nbt: Internal.CompoundTag): void
        notify(): void
        writeNetData(data: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getStringID(): string
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static LOOT_CRATES : Internal.Map<string, Internal.LootCrate>;
        stringID : string;
        itemName : string;
        drops : Internal.EntityWeight;
        color : Internal.Color4I;
        glow : boolean;
        readonly table : Internal.RewardTable;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockEntityTypeExtension <T> {
        flywheel$setInstancingController(arg0: Internal.BlockEntityInstancingController<T>): void
        flywheel$getInstancingController(): Internal.BlockEntityInstancingController<T>
    }
    class ProtectionDomain {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getPermissions(): Internal.PermissionCollection
        getClassLoader(): Internal.ClassLoader
        toString(): string
        getPrincipals(): Internal.Principal[]
        implies(arg0: Internal.Permission): boolean
        staticPermissionsOnly(): boolean
        getCodeSource(): Internal.CodeSource
        notify(): void
        get classLoader(): Internal.ClassLoader;
        get permissions(): Internal.PermissionCollection;
        get principals(): Internal.Principal[];
        get codeSource(): Internal.CodeSource;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockStateFTBC {
        getFTBCIsWater(): boolean
    }
    interface EntityTargetKJS {
        getNameKJS(): string
    }
    interface LongSet extends Internal.LongCollection, Internal.Set<number> {
        longIterator(): Internal.LongIterator
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        removeAll(arg0: Internal.LongCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.LongIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toArray(arg0: number[]): number[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        longStream(): Internal.LongStream
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        add(arg0: number): boolean
        longSpliterator(): Internal.LongSpliterator
        toLongArray(arg0: number[]): number[]
        toLongArray(): number[]
        spliterator(): Internal.LongSpliterator
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: Internal.LongConsumer): void
        forEach(arg0: (arg0: any) => void): void
        containsAll(arg0: Internal.LongCollection): boolean
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: java_.util.function_.LongPredicate): boolean
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        longParallelStream(): Internal.LongStream
        contains(arg0: any): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.LongCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        retainAll(arg0: Internal.LongCollection): boolean
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    class OffsetDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetDateTime>, Internal.Serializable {
        getClass(): Internal.Class<any>
        plusHours(arg0: number): Internal.OffsetDateTime
        isEqual(arg0: Internal.OffsetDateTime): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: any): number
        compareTo(arg0: Internal.OffsetDateTime): number
        withOffsetSameLocal(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        getDayOfWeek(): Internal.DayOfWeek
        plusSeconds(arg0: number): Internal.OffsetDateTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.OffsetDateTime
        plusNanos(arg0: number): Internal.OffsetDateTime
        getMonth(): Internal.Month
        atZoneSameInstant(arg0: Internal.ZoneId): Internal.ZonedDateTime
        withHour(arg0: number): Internal.OffsetDateTime
        plusMonths(arg0: number): Internal.OffsetDateTime
        plusYears(arg0: number): Internal.OffsetDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.OffsetDateTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.OffsetDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetDateTime
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.OffsetDateTime
        getYear(): number
        toEpochSecond(): number
        toLocalDateTime(): Internal.LocalDateTime
        withDayOfMonth(arg0: number): Internal.OffsetDateTime
        isAfter(arg0: Internal.OffsetDateTime): boolean
        withMonth(arg0: number): Internal.OffsetDateTime
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.OffsetDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetDateTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.OffsetDateTime
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toOffsetTime(): Internal.OffsetTime
        minusHours(arg0: number): Internal.OffsetDateTime
        notifyAll(): void
        getOffset(): Internal.ZoneOffset
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        plusMinutes(arg0: number): Internal.OffsetDateTime
        withYear(arg0: number): Internal.OffsetDateTime
        notify(): void
        plusDays(arg0: number): Internal.OffsetDateTime
        minusMinutes(arg0: number): Internal.OffsetDateTime
        atZoneSimilarLocal(arg0: Internal.ZoneId): Internal.ZonedDateTime
        hashCode(): number
        static now(arg0: Internal.ZoneId): Internal.OffsetDateTime
        static now(arg0: Internal.Clock): Internal.OffsetDateTime
        static now(): Internal.OffsetDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime, arg2: Internal.ZoneOffset): Internal.OffsetDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): Internal.OffsetDateTime
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset): Internal.OffsetDateTime
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.OffsetDateTime
        getHour(): number
        withMinute(arg0: number): Internal.OffsetDateTime
        getMonthValue(): number
        toZonedDateTime(): Internal.ZonedDateTime
        minusYears(arg0: number): Internal.OffsetDateTime
        minusWeeks(arg0: number): Internal.OffsetDateTime
        withDayOfYear(arg0: number): Internal.OffsetDateTime
        static parse(arg0: Internal.CharSequence): Internal.OffsetDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.OffsetDateTime
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.OffsetDateTime): boolean
        minusDays(arg0: number): Internal.OffsetDateTime
        withNano(arg0: number): Internal.OffsetDateTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.OffsetDateTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.OffsetDateTime
        minusMonths(arg0: number): Internal.OffsetDateTime
        toLocalDate(): Internal.LocalDate
        withOffsetSameInstant(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        equals(arg0: any): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        static timeLineOrder(): Internal.Comparator<Internal.OffsetDateTime>
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.OffsetDateTime
        withSecond(arg0: number): Internal.OffsetDateTime
        static readonly MIN : Internal.OffsetDateTime;
        static readonly MAX : Internal.OffsetDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get offset(): Internal.ZoneOffset;
        get hour(): number;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Multiset <E> extends Internal.Collection<E> {
        add(arg0: E): boolean
        add(arg0: E, arg1: number): number
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void
        entrySet(): Internal.Set<Internal.Multiset$Entry<E>>
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        count(arg0: any): number
        remove(arg0: any): boolean
        remove(arg0: any, arg1: number): number
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        elementSet(): Internal.Set<E>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        setCount(arg0: E, arg1: number, arg2: number): boolean
        setCount(arg0: E, arg1: number): number
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    class File implements Internal.Serializable, Internal.Comparable<Internal.File> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getUsableSpace(): number
        static listRoots(): Internal.File[]
        renameTo(arg0: Internal.File): boolean
        getName(): string
        setExecutable(arg0: boolean, arg1: boolean): boolean
        setExecutable(arg0: boolean): boolean
        canRead(): boolean
        notifyAll(): void
        getCanonicalFile(): Internal.File
        compareTo(arg0: Internal.File): number
        compareTo(arg0: any): number
        delete(): boolean
        notify(): void
        setReadable(arg0: boolean): boolean
        setReadable(arg0: boolean, arg1: boolean): boolean
        getTotalSpace(): number
        hashCode(): number
        getParentFile(): Internal.File
        getPath(): string
        getAbsoluteFile(): Internal.File
        listFiles(arg0: Internal.FilenameFilter): Internal.File[]
        listFiles(arg0: Internal.FileFilter): Internal.File[]
        listFiles(): Internal.File[]
        mkdir(): boolean
        deleteOnExit(): void
        canExecute(): boolean
        getCanonicalPath(): string
        toURL(): Internal.URL
        getParent(): string
        setWritable(arg0: boolean): boolean
        setWritable(arg0: boolean, arg1: boolean): boolean
        isFile(): boolean
        getAbsolutePath(): string
        toURI(): Internal.URI
        getFreeSpace(): number
        length(): number
        canWrite(): boolean
        static createTempFile(arg0: string, arg1: string, arg2: Internal.File): Internal.File
        static createTempFile(arg0: string, arg1: string): Internal.File
        list(): string[]
        list(arg0: Internal.FilenameFilter): string[]
        isHidden(): boolean
        toPath(): Internal.Path
        mkdirs(): boolean
        equals(arg0: any): boolean
        exists(): boolean
        isAbsolute(): boolean
        toString(): string
        lastModified(): number
        createNewFile(): boolean
        setLastModified(arg0: number): boolean
        isDirectory(): boolean
        setReadOnly(): boolean
        static readonly pathSeparator : ";";
        static readonly pathSeparatorChar : ";";
        static readonly separatorChar : "\\";
        static readonly separator : "\\";
        get parent(): string;
        get parentFile(): Internal.File;
        get hidden(): boolean;
        get freeSpace(): number;
        get usableSpace(): number;
        get totalSpace(): number;
        get canonicalFile(): Internal.File;
        get directory(): boolean;
        get path(): string;
        get absoluteFile(): Internal.File;
        get file(): boolean;
        get absolute(): boolean;
        get name(): string;
        get canonicalPath(): string;
        get absolutePath(): string;
        get class(): Internal.Class<any>;
        set readable(arg0: boolean);
        set executable(arg0: boolean);
        set writable(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PausedPartialTickAccessor {
        flywheel$getPartialTicksPaused(): number
    }
    interface IModBusEvent {
    }
    interface TriPredicate <T, U, V> {
        or(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>
        test(arg0: T, arg1: U, arg2: V): boolean
        and(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>
        negate(): Internal.TriPredicate<T, U, V>
    }
    interface PreparableReloadListener {
    }
    class MobEffectInstance implements Internal.Comparable<Internal.MobEffectInstance>, Internal.IForgeMobEffectInstance, Internal.AccessorMobEffectInstance, Internal.EffectInstanceAccess, Internal.EffectInstanceWithSource {
        setDuration(arg0: number): void
        getClass(): Internal.Class<any>
        setSource(arg0: ResourceLocation): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addCurativeItem(arg0: Internal.ItemStack): void
        removeEffect(): void
        notifyAll(): void
        compareTo(arg0: Internal.MobEffectInstance): number
        compareTo(arg0: any): number
        bookshelf$getHiddenEffect(): Internal.MobEffectInstance
        notify(): void
        writeCurativeItems(arg0: Internal.CompoundTag): void
        bookshelf$setHiddenEffect(arg0: Internal.MobEffectInstance): void
        hasSource(): boolean
        bookshelf$tickDownDuration(): number
        getSource(): ResourceLocation
        hashCode(): number
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void
        equals(arg0: any): boolean
        getHiddenEffect(): Internal.MobEffectInstance
        toString(): string
        getEffect(): Internal.MobEffect
        isCurativeItem(arg0: Internal.ItemStack): boolean
        getCurativeItems(): Internal.List<Internal.ItemStack>
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effect(): Internal.MobEffect;
        get hiddenEffect(): Internal.MobEffectInstance;
        get source(): ResourceLocation;
        get class(): Internal.Class<any>;
        set duration(arg0: number);
        set curativeItems(arg0: Internal.List<Internal.ItemStack>);
        set source(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerPlayerDataJS extends Internal.PlayerDataJS<any, any> {
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPlayer(): Internal.ServerPlayerJS
        getPlayer(): Internal.PlayerJS<any>
        getName(): string
        notifyAll(): void
        getProfile(): Internal.GameProfile
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        notify(): void
        getMinecraftPlayer(): Internal.ServerPlayer
        getMinecraftPlayer(): Internal.Player
        hashCode(): number
        equals(arg0: any): boolean
        hasClientMod(): boolean
        toString(): string
        getData(): Internal.AttachedData
        get server(): Internal.ServerJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.Player;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TeamManager {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getInternalPlayerTeam(uuid: Internal.UUID): Internal.PlayerTeam
        getName(id: Internal.UUID): Internal.Component
        notifyAll(): void
        save(): void
        getKnownPlayers(): Internal.Map<Internal.UUID, Internal.PlayerTeam>
        getId(): Internal.UUID
        getTeamMap(): Internal.Map<Internal.UUID, Internal.Team>
        notify(): void
        serializeNBT(): Internal.SNBTCompoundTag
        load(): void
        hashCode(): number
        getServer(): Internal.MinecraftServer
        getTeamNameMap(): Internal.Map<string, Internal.Team>
        syncAll(): void
        createServerTeam(player: Internal.ServerPlayer, name: string): Internal.ServerTeam
        arePlayersInSameTeam(player1: Internal.ServerPlayer, player2: Internal.ServerPlayer): boolean
        createServer(source: Internal.CommandSourceStack, name: string): Internal.Pair<number, Internal.ServerTeam>
        getExtraData(): Internal.CompoundTag
        getPlayerTeamID(id: Internal.UUID): Internal.UUID
        sync(player: Internal.ServerPlayer, self: Internal.Team): void
        sync(player: Internal.ServerPlayer): void
        createClientTeamManager(): Internal.ClientTeamManager
        getTeams(): Internal.Collection<Internal.Team>
        createPartyTeam(player: Internal.ServerPlayer, name: string): Internal.PartyTeam
        createParty(player: Internal.ServerPlayer, name: string): Internal.Pair<number, Internal.PartyTeam>
        equals(arg0: any): boolean
        getTeamByID(uuid: Internal.UUID): Internal.Team
        getPlayerTeam(player: Internal.ServerPlayer): Internal.Team
        getPlayerTeam(uuid: Internal.UUID): Internal.Team
        saveNow(): void
        toString(): string
        playerLoggedOut(player: Internal.ServerPlayer): void
        playerLoggedIn(player: Internal.ServerPlayer, id: Internal.UUID, name: string): void
        readonly server : Internal.MinecraftServer;
        static readonly FOLDER_NAME : Internal.LevelResource;
        static INSTANCE : Internal.TeamManager;
        get teamNameMap(): Internal.Map<string, Internal.Team>;
        get knownPlayers(): Internal.Map<Internal.UUID, Internal.PlayerTeam>;
        get teams(): Internal.Collection<Internal.Team>;
        get extraData(): Internal.CompoundTag;
        get teamMap(): Internal.Map<Internal.UUID, Internal.Team>;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DropTargetDropEvent extends Internal.DropTargetEvent {
        getDropTargetContext(): Internal.DropTargetContext
        getDropAction(): number
        getClass(): Internal.Class<any>
        acceptDrop(arg0: number): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getLocation(): Internal.Point
        notifyAll(): void
        dropComplete(arg0: boolean): void
        notify(): void
        getSourceActions(): number
        isLocalTransfer(): boolean
        getTransferable(): Internal.Transferable
        getCurrentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>
        isDataFlavorSupported(arg0: Internal.DataFlavor): boolean
        hashCode(): number
        getSource(): any
        equals(arg0: any): boolean
        rejectDrop(): void
        toString(): string
        getCurrentDataFlavors(): Internal.DataFlavor[]
        get sourceActions(): number;
        get localTransfer(): boolean;
        get transferable(): Internal.Transferable;
        get location(): Internal.Point;
        get currentDataFlavors(): Internal.DataFlavor[];
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        get currentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StringBuilderAppendable {
        appendString(arg0: Internal.StringBuilder): void
    }
    class JsonReader implements Internal.Closeable {
        skipValue(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isLenient(): boolean
        notifyAll(): void
        hasNext(): boolean
        nextInt(): number
        nextString(): string
        endArray(): void
        nextLong(): number
        setLenient(arg0: boolean): void
        notify(): void
        nextDouble(): number
        peek(): Internal.JsonToken
        endObject(): void
        beginArray(): void
        beginObject(): void
        hashCode(): number
        equals(arg0: any): boolean
        getPath(): string
        toString(): string
        nextBoolean(): boolean
        close(): void
        nextName(): string
        nextNull(): void
        get path(): string;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        set lenient(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BufferBuilderExtension {
        flywheel$getVertices(): number
        flywheel$injectForRender(arg0: Internal.ByteBuffer, arg1: Internal.VertexFormat, arg2: number): void
        flywheel$freeBuffer(): void
        flywheel$appendBufferUnsafe(arg0: Internal.ByteBuffer): void
    }
    interface IForgeMinecraft {
        popGuiLayer(): void
        pushGuiLayer(arg0: Internal.Screen): void
    }
    class ChronoField extends Internal.Enum<any> implements Internal.TemporalField {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        resolve(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.TemporalAccessor, arg2: Internal.ResolverStyle): Internal.TemporalAccessor
        notifyAll(): void
        static values(): Internal.ChronoField[]
        adjustInto<R_>(arg0: R_, arg1: number): R_
        range(): Internal.ValueRange
        getRangeUnit(): Internal.TemporalUnit
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ChronoField): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChronoField>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ChronoField>
        getBaseUnit(): Internal.TemporalUnit
        hashCode(): number
        isTimeBased(): boolean
        checkValidIntValue(arg0: number): number
        isDateBased(): boolean
        getFrom(arg0: Internal.TemporalAccessor): number
        static valueOf(arg0: string): Internal.ChronoField
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        rangeRefinedBy(arg0: Internal.TemporalAccessor): Internal.ValueRange
        getDisplayName(arg0: Internal.Locale): string
        equals(arg0: any): boolean
        name(): string
        checkValidValue(arg0: number): number
        toString(): string
        ordinal(): number
        isSupportedBy(arg0: Internal.TemporalAccessor): boolean
        static readonly CLOCK_HOUR_OF_AMPM : Internal.ChronoField;
        static readonly DAY_OF_YEAR : Internal.ChronoField;
        static readonly MICRO_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_MONTH : Internal.ChronoField;
        static readonly DAY_OF_MONTH : Internal.ChronoField;
        static readonly SECOND_OF_MINUTE : Internal.ChronoField;
        static readonly PROLEPTIC_MONTH : Internal.ChronoField;
        static readonly MILLI_OF_SECOND : Internal.ChronoField;
        static readonly NANO_OF_DAY : Internal.ChronoField;
        static readonly CLOCK_HOUR_OF_DAY : Internal.ChronoField;
        static readonly MINUTE_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_MONTH : Internal.ChronoField;
        static readonly YEAR : Internal.ChronoField;
        static readonly HOUR_OF_DAY : Internal.ChronoField;
        static readonly MILLI_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_YEAR : Internal.ChronoField;
        static readonly YEAR_OF_ERA : Internal.ChronoField;
        static readonly AMPM_OF_DAY : Internal.ChronoField;
        static readonly NANO_OF_SECOND : Internal.ChronoField;
        static readonly SECOND_OF_DAY : Internal.ChronoField;
        static readonly MICRO_OF_SECOND : Internal.ChronoField;
        static readonly MONTH_OF_YEAR : Internal.ChronoField;
        static readonly EPOCH_DAY : Internal.ChronoField;
        static readonly ERA : Internal.ChronoField;
        static readonly OFFSET_SECONDS : Internal.ChronoField;
        static readonly HOUR_OF_AMPM : Internal.ChronoField;
        static readonly MINUTE_OF_HOUR : Internal.ChronoField;
        static readonly INSTANT_SECONDS : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_YEAR : Internal.ChronoField;
        static readonly DAY_OF_WEEK : Internal.ChronoField;
        get baseUnit(): Internal.TemporalUnit;
        get rangeUnit(): Internal.TemporalUnit;
        get timeBased(): boolean;
        get dateBased(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChronoField>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IngredientWithCustomPredicateJS implements Internal.IngredientJS {
        getItemIds(): Internal.Set<string>
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        anyStackMatches(ingredient: string): boolean
        anyStackMatches(ingredient: object): boolean
        anyStackMatches(ingredient: Internal.ItemStackJS): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        notifyAll(): void
        isInvalidRecipeIngredient(): boolean
        notify(): void
        not(): Internal.IngredientJS
        hashCode(): number
        getFirst(): Internal.ItemStackJS
        copy(): Internal.Copyable
        copy(): Internal.IngredientJS
        getCount(): number
        test(stack: object): boolean
        test(stack: Internal.ItemStackJS): boolean
        test(stack: string): boolean
        testVanillaItem(i: Internal.Item): boolean
        isEmpty(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: object): Internal.IngredientJS
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        filter(filter: Internal.ItemStackJS): Internal.IngredientJS
        filter(filter: string): Internal.IngredientJS
        createVanillaIngredient(): (arg0: any) => boolean
        toJson(): Internal.JsonElement
        withCount(count: number): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        equals(arg0: any): boolean
        testVanilla(stack: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        toString(): string
        readonly predicate : (arg0: Internal.ItemStack) => boolean;
        readonly ingredient : Internal.IngredientJS;
        readonly uuid : Internal.UUID;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Temporal extends Internal.TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        get(arg0: Internal.TemporalField): number
        range(arg0: Internal.TemporalField): Internal.ValueRange
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
    }
    class FluidState extends Internal.StateHolder<any, any> implements Internal.IForgeFluidState {
        getNeighborTable(): Internal.Table<any, any, any>
        getStateIndex(): number
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        redirect$zlm000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any
        setNeighborTable(table: Internal.Table<any, any, any>): void
        notifyAll(): void
        setStateMap(newValue: Internal.FastMap<any>): void
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean
        getStateMap(): Internal.FastMap<any>
        notify(): void
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void
        hashCode(): number
        equals(arg0: any): boolean
        setStateIndex(newValue: number): void
        toString(): string
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ResourceKey <T> implements Internal.Comparable<Internal.ResourceKey<any>>, Internal.SpecialEquality {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getNamespace(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getPath(): string
        getRegistryName(): ResourceLocation
        toString(): string
        compareTo(arg0: Internal.ResourceKey<any>): number
        compareTo(arg0: any): number
        notify(): void
        specialEquals(o: any, shallow: boolean): boolean
        get path(): string;
        get namespace(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecvByteBufAllocator$Handle {
        continueReading(): boolean
        incMessagesRead(arg0: number): void
        allocate(arg0: Internal.ByteBufAllocator): Internal.ByteBuf
        guess(): number
        reset(arg0: Internal.ChannelConfig): void
        readComplete(): void
        attemptedBytesRead(): number
        attemptedBytesRead(arg0: number): void
        lastBytesRead(): number
        lastBytesRead(arg0: number): void
    }
    class ModelBakery implements Internal.AccessorModelBakery, Internal.ForgeAccessorModelBakery {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zpc000$injectProcessLoading(arg0: Internal.ProfilerFiller, arg1: number, arg2: Internal.CallbackInfo): void
        notifyAll(): void
        static getMaterials_$md$204703$0(): Internal.Set<any>
        getSpecialModels(): Internal.Set<ResourceLocation>
        getResourceManager(): Internal.ResourceManager
        notify(): void
        getSpriteMap(): Internal.AtlasSet
        getSpriteAtlasManager(): Internal.AtlasSet
        hashCode(): number
        equals(arg0: any): boolean
        bake(arg0: ResourceLocation, arg1: Internal.ModelState, arg2: (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite): Internal.BakedModel
        toString(): string
        handler$zpc000$injectLoadModel(arg0: ResourceLocation, arg1: Internal.CallbackInfo): void
        get spriteMap(): Internal.AtlasSet;
        get specialModels(): Internal.Set<ResourceLocation>;
        get materials_$md$204703$0(): Internal.Set<any>;
        get spriteAtlasManager(): Internal.AtlasSet;
        get class(): Internal.Class<any>;
        get resourceManager(): Internal.ResourceManager;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PageAttributes$OriginType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly PRINTABLE : Internal.PageAttributes$OriginType;
        static readonly PHYSICAL : Internal.PageAttributes$OriginType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CharSequence {
        isEmpty(): boolean
        length(): number
        toString(): string
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        chars(): Internal.IntStream
        charAt(arg0: number): string
        codePoints(): Internal.IntStream
    }
    interface DynamicOps <T> {
        createLong(arg0: number): T
        createIntList(arg0: Internal.IntStream): T
        updateGeneric(arg0: T, arg1: T, arg2: (arg0: T) => T): T
        listBuilder(): Internal.ListBuilder<T>
        createDouble(arg0: number): T
        createLongList(arg0: Internal.LongStream): T
        createShort(arg0: number): T
        mergeToList(arg0: T, arg1: T): Internal.DataResult<T>
        mergeToList(arg0: T, arg1: Internal.List<T>): Internal.DataResult<T>
        update(arg0: T, arg1: string, arg2: (arg0: T) => T): T
        getByteBuffer(arg0: T): Internal.DataResult<Internal.ByteBuffer>
        createByteList(arg0: Internal.ByteBuffer): T
        withDecoder<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<com.mojang.datafixers.util.Pair<E, T>>
        remove(arg0: T, arg1: string): T
        createBoolean(arg0: boolean): T
        empty(): T
        getMapValues(arg0: T): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>>
        mergeToMap(arg0: T, arg1: Internal.Map<T, T>): Internal.DataResult<T>
        mergeToMap(arg0: T, arg1: Internal.MapLike<T>): Internal.DataResult<T>
        mergeToMap(arg0: T, arg1: T, arg2: T): Internal.DataResult<T>
        withParser<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<E>
        convertList<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        emptyList(): T
        getIntStream(arg0: T): Internal.DataResult<Internal.IntStream>
        getList(arg0: T): Internal.DataResult<(arg0: (arg0: T) => void) => void>
        get(arg0: T, arg1: string): Internal.DataResult<T>
        getLongStream(arg0: T): Internal.DataResult<Internal.LongStream>
        emptyMap(): T
        getMapEntries(arg0: T): Internal.DataResult<(arg0: (arg0: T, arg1: T) => void) => void>
        getBooleanValue(arg0: T): Internal.DataResult<boolean>
        createNumeric(arg0: Internal.Number): T
        getStream(arg0: T): Internal.DataResult<Internal.Stream<T>>
        convertMap<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        mergeToPrimitive(arg0: T, arg1: T): Internal.DataResult<T>
        createList(arg0: Internal.Stream<T>): T
        getStringValue(arg0: T): Internal.DataResult<string>
        set(arg0: T, arg1: string, arg2: T): T
        withEncoder<E>(arg0: Internal.Encoder<E>): (arg0: E) => Internal.DataResult<T>
        createString(arg0: string): T
        getGeneric(arg0: T, arg1: T): Internal.DataResult<T>
        convertTo<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        createMap(arg0: Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>): T
        createMap(arg0: Internal.Map<T, T>): T
        mapBuilder(): Internal.RecordBuilder<T>
        getMap(arg0: T): Internal.DataResult<Internal.MapLike<T>>
        createByte(arg0: number): T
        createFloat(arg0: number): T
        createInt(arg0: number): T
        compressMaps(): boolean
        getNumberValue(arg0: T, arg1: Internal.Number): Internal.Number
        getNumberValue(arg0: T): Internal.DataResult<Internal.Number>
    }
    abstract class ChannelHandlerAdapter implements Internal.ChannelHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        toString(): string
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        isSharable(): boolean
        notify(): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchEvent$Kind <T> {
        name(): string
        type(): Internal.Class<T>
    }
    class DataJsonGenerator extends Internal.JsonGenerator {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        json(id: ResourceLocation, json: Internal.JsonElement): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityPotionEffectsJS {
        add(mobEffect: Internal.MobEffect): void
        add(mobEffect: Internal.MobEffect, duration: number): void
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number): void
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number, ambient: boolean, showParticles: boolean): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        clear(): void
        isApplicable(effect: Internal.MobEffectInstance): boolean
        isActive(mobEffect: Internal.MobEffect): boolean
        notify(): void
        getMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>
        getDuration(mobEffect: Internal.MobEffect): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getActive(mobEffect: Internal.MobEffect): Internal.MobEffectInstance
        getActive(): Internal.Collection<Internal.MobEffectInstance>
        get active(): Internal.Collection<Internal.MobEffectInstance>;
        get class(): Internal.Class<any>;
        get map(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LongBuffer extends Internal.Buffer implements Internal.Comparable<Internal.LongBuffer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.LongBuffer
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LongBuffer): number
        notify(): void
        asReadOnlyBuffer(): Internal.LongBuffer
        put(arg0: number[]): Internal.LongBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer
        put(arg0: number, arg1: number[]): Internal.LongBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        put(arg0: number, arg1: Internal.LongBuffer, arg2: number, arg3: number): Internal.LongBuffer
        put(arg0: Internal.LongBuffer): Internal.LongBuffer
        put(arg0: number, arg1: number): Internal.LongBuffer
        put(arg0: number): Internal.LongBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.Buffer
        slice(): Internal.LongBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.LongBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(): number
        get(arg0: number, arg1: number[]): Internal.LongBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        get(arg0: number[]): Internal.LongBuffer
        limit(arg0: number): Internal.LongBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.Buffer
        flip(): Internal.LongBuffer
        order(): Internal.ByteOrder
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.LongBuffer
        duplicate(): Internal.LongBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        static allocate(arg0: number): Internal.LongBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.LongBuffer
        mismatch(arg0: Internal.LongBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.Buffer
        reset(): Internal.LongBuffer
        toString(): string
        position(arg0: number): Internal.LongBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.LongBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        mark(): Internal.Buffer
        mark(): Internal.LongBuffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Codec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: T, arg2: Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.DataResult<T>): Internal.DataResult<T>
    }
    interface BufferedImageOp {
        getPoint2D(arg0: Internal.Point2D, arg1: Internal.Point2D): Internal.Point2D
        filter(arg0: Internal.BufferedImage, arg1: Internal.BufferedImage): Internal.BufferedImage
        getBounds2D(arg0: Internal.BufferedImage): Internal.Rectangle2D
        getRenderingHints(): Internal.RenderingHints
        createCompatibleDestImage(arg0: Internal.BufferedImage, arg1: Internal.ColorModel): Internal.BufferedImage
    }
    interface IEntityWithHome {
        setHomeArea(arg0: BlockPos, arg1: number): void
        isWithinHomeDistance(arg0: number, arg1: number, arg2: number): boolean
        isWithinHomeDistance(arg0: BlockPos): boolean
        getHome(): Internal.AABB
        getHomePosition(): BlockPos
        setHome(arg0: Internal.AABB): void
    }
    interface AccessorPlayer {
        darkutils$setEnchantmentSeed(arg0: number): void
        darkutils$setSleepTimer(arg0: number): void
    }
    interface MouseListener extends Internal.EventListener {
        mouseReleased(arg0: Internal.MouseEvent): void
        mouseExited(arg0: Internal.MouseEvent): void
        mouseEntered(arg0: Internal.MouseEvent): void
        mouseClicked(arg0: Internal.MouseEvent): void
        mousePressed(arg0: Internal.MouseEvent): void
    }
    interface ResourceManager extends Internal.ResourceProvider {
    }
    interface ProgressivePromise <V> extends Internal.Promise<V>, Internal.ProgressiveFuture<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressivePromise<V>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>
        getNow(): V
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<V>
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ProgressivePromise<V>
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(): Internal.Future<V>
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressivePromise<V>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ProgressivePromise<V>
        sync(): Internal.Promise<V>
        sync(): Internal.Future<V>
        sync(): Internal.ProgressiveFuture<V>
        setSuccess(arg0: V): Internal.ProgressivePromise<V>
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<V>
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        trySuccess(arg0: V): boolean
        tryProgress(arg0: number, arg1: number): boolean
        syncUninterruptibly(): Internal.ProgressivePromise<V>
        syncUninterruptibly(): Internal.Promise<V>
        syncUninterruptibly(): Internal.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isCancellable(): boolean
        await(): Internal.ProgressivePromise<V>
        await(): Internal.Promise<V>
        await(): Internal.Future<V>
        await(): Internal.ProgressiveFuture<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressivePromise<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>
        isSuccess(): boolean
        setUncancellable(): boolean
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressivePromise<V>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>
    }
    interface RenderTypeAccess {
        getName(): string
    }
    interface GuiEventListener {
    }
    interface FileFilter {
        accept(arg0: Internal.File): boolean
    }
    abstract class AbstractContainerEventHandler extends Internal.GuiComponent implements Internal.ContainerEventHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Constructor <T> extends Internal.Executable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getParameterCount(): number
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        notifyAll(): void
        isSynthetic(): boolean
        getAnnotatedParameterTypes(): Internal.AnnotatedType[]
        getParameterTypes(): Internal.Class<any>[]
        getGenericExceptionTypes(): Internal.Type[]
        notify(): void
        getAnnotatedReceiverType(): Internal.AnnotatedType
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaringClass(): Internal.Class<T>
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        hashCode(): number
        canAccess(arg0: any): boolean
        toGenericString(): string
        getTypeParameters(): any[]
        getModifiers(): number
        trySetAccessible(): boolean
        isAccessible(): boolean
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        isVarArgs(): boolean
        newInstance(arg0: any[]): T
        getAnnotations(): Internal.Annotation[]
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[]
        getExceptionTypes(): Internal.Class<any>[]
        getGenericParameterTypes(): Internal.Type[]
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        equals(arg0: any): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getParameters(): any[]
        toString(): string
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<T>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): Internal.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): Internal.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MethodHandle implements Internal.Constable {
        asCollector(arg0: Internal.Class<any>, arg1: number): Internal.MethodHandle
        asCollector(arg0: number, arg1: Internal.Class<any>, arg2: number): Internal.MethodHandle
        asSpreader(arg0: number, arg1: Internal.Class<any>, arg2: number): Internal.MethodHandle
        asSpreader(arg0: Internal.Class<any>, arg1: number): Internal.MethodHandle
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        withVarargs(arg0: boolean): Internal.MethodHandle
        invokeExact(arg0: any[]): any
        notifyAll(): void
        invoke(arg0: any[]): any
        type(): Internal.MethodType
        describeConstable(): Internal.Optional<Internal.MethodHandleDesc>
        notify(): void
        bindTo(arg0: any): Internal.MethodHandle
        asVarargsCollector(arg0: Internal.Class<any>): Internal.MethodHandle
        asType(arg0: Internal.MethodType): Internal.MethodHandle
        invokeWithArguments(arg0: any[]): any
        invokeWithArguments(arg0: Internal.List<any>): any
        hashCode(): number
        equals(arg0: any): boolean
        isVarargsCollector(): boolean
        asFixedArity(): Internal.MethodHandle
        toString(): string
        get varargsCollector(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MaterialManager {
        defaultCutout(): Internal.MaterialGroup
        solid(arg0: Internal.RenderType): Internal.MaterialGroup
        defaultSolid(): Internal.MaterialGroup
        defaultTransparent(): Internal.MaterialGroup
        cutout(arg0: Internal.RenderType): Internal.MaterialGroup
        state(arg0: Internal.RenderLayer, arg1: Internal.RenderType): Internal.MaterialGroup
        transparent(arg0: Internal.RenderType): Internal.MaterialGroup
        getOriginCoordinate(): Vec3i
    }
    abstract class Clock implements Internal.InstantSource {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        withZone(arg0: Internal.ZoneId): Internal.Clock
        static offset(arg0: Internal.Clock, arg1: Internal.Duration): Internal.Clock
        static tickMinutes(arg0: Internal.ZoneId): Internal.Clock
        static tickMillis(arg0: Internal.ZoneId): Internal.Clock
        notifyAll(): void
        getZone(): Internal.ZoneId
        static tick(arg0: Internal.Clock, arg1: Internal.Duration): Internal.Clock
        notify(): void
        instant(): Internal.Instant
        static system(arg0: Internal.ZoneId): Internal.Clock
        hashCode(): number
        equals(arg0: any): boolean
        static systemDefaultZone(): Internal.Clock
        static tickSeconds(arg0: Internal.ZoneId): Internal.Clock
        static systemUTC(): Internal.Clock
        toString(): string
        static fixed(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.Clock
        millis(): number
        get zone(): Internal.ZoneId;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LevelChunk extends Internal.ChunkAccess implements Internal.ICapabilityProviderImpl<Internal.LevelChunk>, corgitaco.enhancedcelestials.mixin.access.ChunkAccess {
        getClass(): Internal.Class<any>
        getWorldForge(): net.minecraft.world.level.Level
        getWorldForge(): Internal.LevelAccessor
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        notifyAll(): void
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.LevelChunk>): boolean
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        handler$zol000$onBlockEntityRemove_HammerLib(arg0: BlockPos, arg1: Internal.CallbackInfo): void
        writeCapsToNBT(): Internal.CompoundTag
        notify(): void
        reviveCaps(): void
        readCapsFromNBT(arg0: Internal.CompoundTag): void
        getLevel(): net.minecraft.world.level.Level
        invalidateCaps(): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        localvar$bja000$modifyHeightmapType(arg0: Internal.Heightmap$Types): Internal.Heightmap$Types
        get level(): net.minecraft.world.level.Level;
        get worldForge(): Internal.LevelAccessor;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ShortFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    abstract class ImmutableMultimap <K, V> extends Internal.BaseImmutableMultimap<any, any> implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        keys(): Internal.ImmutableMultiset<K>
        keys(): Internal.Multiset<any>
        asMap(): Internal.Map<any, any>
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>
        notifyAll(): void
        values(): Internal.ImmutableCollection<V>
        values(): Internal.Collection<any>
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: any, arg1: any): boolean
        removeAll(arg0: any): Internal.Collection<any>
        removeAll(arg0: any): Internal.ImmutableCollection<V>
        hashCode(): number
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        putAll(arg0: Internal.Multimap<K, V>): boolean
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>
        get(arg0: any): Internal.Collection<any>
        get(arg0: K): Internal.ImmutableCollection<V>
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>
        keySet(): Internal.Set<any>
        keySet(): Internal.ImmutableSet<K>
        containsEntry(arg0: any, arg1: any): boolean
        inverse(): Internal.ImmutableMultimap<V, K>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMultimap<K_, V_>
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableMultimap<K_, V_>
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableCollection<V>
        entries(): Internal.Collection<any>
        entries(): Internal.ImmutableCollection<Internal.Map$Entry<K, V>>
        size(): number
        equals(arg0: any): boolean
        toString(): string
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjLongConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    abstract class AbstractContainerScreen <T> extends Internal.Screen implements Internal.MenuAccess<T>, net.blay09.mods.balm.mixin.AbstractContainerScreenAccessor, Internal.AccessorAbstractContainerScreen, Internal.AbstractContainerScreenAccessor {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getHoveredSlot(): Internal.Slot
        notifyAll(): void
        getYSize(): number
        getIsQuickCrafting(): boolean
        getLeftPos(): number
        notify(): void
        getImageHeight(): number
        balm_getNarratables(): Internal.List<any>
        static renderSlotHighlight(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot
        hashCode(): number
        setIsQuickCrafting(arg0: boolean): void
        getQuickCraftingButton(): number
        getSlotColor(arg0: number): number
        getNarratables(): Internal.List<any>
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void
        setSkipNextRelease(arg0: boolean): void
        handler$zcd000$getTooltipFromItem(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void
        getRenderables(): Internal.List<any>
        getImageWidth(): number
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void
        getMinecraft(): Internal.Minecraft
        getGuiTop(): number
        getTopPos(): number
        getGuiLeft(): number
        balm_getChildren(): Internal.List<any>
        balm_getRenderables(): Internal.List<any>
        equals(arg0: any): boolean
        getSlotUnderMouse(): Internal.Slot
        toString(): string
        getXSize(): number
        tooltipFont : Internal.Font;
        get leftPos(): number;
        get imageWidth(): number;
        get minecraft(): Internal.Minecraft;
        get quickCraftingButton(): number;
        get isQuickCrafting(): boolean;
        get ySize(): number;
        get imageHeight(): number;
        get renderables(): Internal.List<any>;
        get hoveredSlot(): Internal.Slot;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get narratables(): Internal.List<any>;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get topPos(): number;
        get guiTop(): number;
        set isQuickCrafting(arg0: boolean);
        set skipNextRelease(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Goal {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SymbolScriptable {
        get(arg0: Internal.Symbol, arg1: Internal.Scriptable): any
        has(arg0: Internal.Symbol, arg1: Internal.Scriptable): boolean
        delete(arg0: Internal.Symbol): void
        put(arg0: Internal.Symbol, arg1: Internal.Scriptable, arg2: any): void
    }
    class Context {
        getClass(): Internal.Class<any>
        static throwAsScriptRuntimeEx(e: Internal.Throwable): Internal.RuntimeException
        isSealed(): boolean
        callFunctionWithContinuations(function_: Internal.Callable, scope: Internal.Scriptable, args: any[]): any
        getClassShutterSetter(): Internal.Context$ClassShutterSetter
        executeScriptWithContinuations(script: Internal.Script, scope: Internal.Scriptable): any
        createClassLoader(parent: Internal.ClassLoader): Internal.GeneratedClassLoader
        getApplicationClassLoader(): Internal.ClassLoader
        evaluateReader(scope: Internal.Scriptable, in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: any): any
        getTypeWrappers(): Internal.TypeWrappers
        static toBoolean(value: any): boolean
        compileReader(in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: any): Internal.Script
        static javaToJS(value: any, scope: Internal.Scriptable): any
        captureContinuation(): Internal.ContinuationPending
        resumeContinuation(continuation: any, scope: Internal.Scriptable, functionResult: any): any
        static enter(): Internal.Context
        static reportRuntimeError0(messageId: string): Internal.EvaluatorException
        static reportRuntimeError1(messageId: string, arg1: any): Internal.EvaluatorException
        static reportRuntimeError2(messageId: string, arg1: any, arg2: any): Internal.EvaluatorException
        static reportRuntimeError3(messageId: string, arg1: any, arg2: any, arg3: any): Internal.EvaluatorException
        getInstructionObserverThreshold(): number
        hasTypeWrappers(): boolean
        static reportRuntimeError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): Internal.EvaluatorException
        static reportRuntimeError(message: string): Internal.EvaluatorException
        getThreadLocal(key: any): any
        removePropertyChangeListener(l: Internal.PropertyChangeListener): void
        static getUndefinedValue(): any
        putThreadLocal(key: any, value: any): void
        setClassShutter(shutter: Internal.ClassShutter): void
        static exit(): void
        setInstructionObserverThreshold(threshold: number): void
        getElements(object: Internal.Scriptable): any[]
        static reportRuntimeError4(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any): Internal.EvaluatorException
        hasFeature(featureIndex: number): boolean
        initSafeStandardObjects(): Internal.ScriptableObject
        initSafeStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable
        initSafeStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject
        static toNumber(value: any): number
        setLocale(loc: Internal.Locale): Internal.Locale
        initStandardObjects(): Internal.ScriptableObject
        initStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject
        initStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable
        isStrictMode(): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setApplicationClassLoader(loader: Internal.ClassLoader): void
        getWrapFactory(): Internal.WrapFactory
        notifyAll(): void
        setGenerateObserverCount(generateObserverCount: boolean): void
        seal(sealKey: any): void
        setWrapFactory(wrapFactory: Internal.WrapFactory): void
        evaluateString(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: any): any
        notify(): void
        compileFunction(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: any): dev.latvian.mods.rhino.Function
        getClassShutter(): Internal.ClassShutter
        setErrorReporter(reporter: Internal.ErrorReporter): Internal.ErrorReporter
        hashCode(): number
        newObject(scope: Internal.Scriptable, constructorName: string, args: any[]): Internal.Scriptable
        newObject(scope: Internal.Scriptable, constructorName: string): Internal.Scriptable
        newObject(scope: Internal.Scriptable): Internal.Scriptable
        static jsToJava(value: any, desiredType: Internal.Class<any>): any
        static toObject(value: any, scope: Internal.Scriptable): Internal.Scriptable
        addPropertyChangeListener(l: Internal.PropertyChangeListener): void
        static getSourcePositionFromStack(linep: number[]): string
        static reportWarning(message: string, t: Internal.Throwable): void
        static reportWarning(message: string): void
        static reportWarning(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void
        setLanguageVersion(version: number): void
        stringIsCompilableUnit(source: string): boolean
        removeThreadLocal(key: any): void
        static getCurrentContext(): Internal.Context
        newArray(scope: Internal.Scriptable, length: number): Internal.Scriptable
        newArray(scope: Internal.Scriptable, elements: any[]): Internal.Scriptable
        static reportError(message: string): void
        static reportError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void
        getFactory(): Internal.ContextFactory
        getErrorReporter(): Internal.ErrorReporter
        static call(factory: Internal.ContextFactory, callable: Internal.Callable, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        getMaximumInterpreterStackDepth(): number
        setMaximumInterpreterStackDepth(max: number): void
        equals(arg0: any): boolean
        compileString(source: string, sourceName: string, lineno: number, securityDomain: any): Internal.Script
        static toString(value: any): string
        toString(): string
        unseal(sealKey: any): void
        static getContext(): Internal.Context
        getLocale(): Internal.Locale
        static enterWithNewFactory(): Internal.Context
        getImplementationVersion(): string
        static readonly FEATURE_INTEGER_WITHOUT_DECIMAL_PLACE : 18;
        static readonly FEATURE_ENHANCED_JAVA_ACCESS : 13;
        static readonly FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER : 3;
        static readonly FEATURE_DYNAMIC_SCOPE : 7;
        static readonly FEATURE_LITTLE_ENDIAN : 19;
        static readonly FEATURE_THREAD_SAFE_OBJECTS : 17;
        generateObserverCount : boolean;
        static readonly FEATURE_STRICT_MODE : 11;
        static readonly FEATURE_WARNING_AS_ERROR : 12;
        static readonly FEATURE_STRICT_EVAL : 9;
        static readonly FEATURE_LOCATION_INFORMATION_IN_ERROR : 10;
        static readonly errorReporterProperty : "error reporter";
        static readonly FEATURE_V8_EXTENSIONS : 14;
        static readonly FEATURE_STRICT_VARS : 8;
        static readonly FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME : 2;
        static readonly FEATURE_PARENT_PROTO_PROPERTIES : 5;
        static readonly languageVersionProperty : "language version";
        static readonly emptyArgs : any[];
        get factory(): Internal.ContextFactory;
        get undefinedValue(): any;
        get implementationVersion(): string;
        get currentContext(): Internal.Context;
        get sealed(): boolean;
        get strictMode(): boolean;
        get maximumInterpreterStackDepth(): number;
        get locale(): Internal.Locale;
        get typeWrappers(): Internal.TypeWrappers;
        get classShutterSetter(): Internal.Context$ClassShutterSetter;
        get errorReporter(): Internal.ErrorReporter;
        get applicationClassLoader(): Internal.ClassLoader;
        get wrapFactory(): Internal.WrapFactory;
        get context(): Internal.Context;
        get class(): Internal.Class<any>;
        get instructionObserverThreshold(): number;
        get classShutter(): Internal.ClassShutter;
        set errorReporter(reporter: Internal.ErrorReporter);
        set languageVersion(version: number);
        set applicationClassLoader(loader: Internal.ClassLoader);
        set wrapFactory(wrapFactory: Internal.WrapFactory);
        set maximumInterpreterStackDepth(max: number);
        set locale(loc: Internal.Locale);
        set instructionObserverThreshold(threshold: number);
        set classShutter(shutter: Internal.ClassShutter);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class VolatileImage extends Internal.Image implements Internal.Transparency {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        contentsLost(): boolean
        getProperty(arg0: string, arg1: Internal.ImageObserver): any
        notifyAll(): void
        getWidth(): number
        getWidth(arg0: Internal.ImageObserver): number
        getCapabilities(): Internal.ImageCapabilities
        getCapabilities(arg0: Internal.GraphicsConfiguration): Internal.ImageCapabilities
        notify(): void
        getSnapshot(): Internal.BufferedImage
        getTransparency(): number
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image
        setAccelerationPriority(arg0: number): void
        getHeight(): number
        getHeight(arg0: Internal.ImageObserver): number
        flush(): void
        hashCode(): number
        getSource(): Internal.ImageProducer
        equals(arg0: any): boolean
        getAccelerationPriority(): number
        toString(): string
        createGraphics(): Internal.Graphics2D
        getGraphics(): Internal.Graphics
        validate(arg0: Internal.GraphicsConfiguration): number
        static readonly OPAQUE : 1;
        static readonly SCALE_DEFAULT : 1;
        static readonly TRANSLUCENT : 3;
        static readonly UndefinedProperty : any;
        static readonly IMAGE_OK : 0;
        static readonly BITMASK : 2;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly IMAGE_RESTORED : 1;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        static readonly IMAGE_INCOMPATIBLE : 2;
        get capabilities(): Internal.ImageCapabilities;
        get accelerationPriority(): number;
        get transparency(): number;
        get width(): number;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        get snapshot(): Internal.BufferedImage;
        get height(): number;
        set accelerationPriority(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FilenameFilter {
        accept(arg0: Internal.File, arg1: string): boolean
    }
    class ModuleDescriptor$Provides implements Internal.Comparable<Internal.ModuleDescriptor$Provides> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        service(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ModuleDescriptor$Provides): number
        notify(): void
        providers(): Internal.List<string>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IPlaceableItem {
        addPlaceable(arg0: Internal.Block): void
        getBlockItemOverride(): Internal.BlockItem
    }
    interface Spliterator$OfPrimitive <T, T_CONS, T_SPLITR> extends Internal.Spliterator<T> {
        trySplit(): Internal.Spliterator<any>
        trySplit(): T_SPLITR
        characteristics(): number
        tryAdvance(arg0: T_CONS): boolean
        tryAdvance(arg0: (arg0: T) => void): boolean
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: T_CONS): void
        forEachRemaining(arg0: (arg0: T) => void): void
    }
    interface ImageObserver {
        imageUpdate(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
    }
    class RecordCodecBuilder <O, F> implements Internal.App<Internal.RecordCodecBuilder$Mu<O>, F> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static instance<O_>(): Internal.RecordCodecBuilder$Instance<O_>
        static mapCodec<O_>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.MapCodec<O_>
        notifyAll(): void
        static deprecated<O_, F_>(arg0: F_, arg1: number): Internal.RecordCodecBuilder<O_, F_>
        notify(): void
        static point<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>
        static point<O_, F_>(arg0: F_, arg1: Internal.Lifecycle): Internal.RecordCodecBuilder<O_, F_>
        static build<O_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.MapCodec<O_>
        hashCode(): number
        static unbox<O_, F_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O_>, F_>): Internal.RecordCodecBuilder<O_, F_>
        static stable<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>
        equals(arg0: any): boolean
        static of<O_, F_>(arg0: (arg0: O_) => F_, arg1: Internal.MapCodec<F_>): Internal.RecordCodecBuilder<O_, F_>
        static of<O_, F_>(arg0: (arg0: O_) => F_, arg1: string, arg2: Internal.Codec<F_>): Internal.RecordCodecBuilder<O_, F_>
        static create<O_>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.Codec<O_>
        toString(): string
        dependent<E_>(arg0: (arg0: O) => E_, arg1: Internal.MapEncoder<E_>, arg2: (arg0: Internal.RecordCodecBuilder$Mu<O>) => Internal.MapDecoder<E_>): Internal.RecordCodecBuilder<O, E_>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JsonNull extends Internal.JsonElement {
        getAsFloat(): number
        getClass(): Internal.Class<any>
        getAsByte(): number
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAsBigDecimal(): Internal.BigDecimal
        notifyAll(): void
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        notify(): void
        getAsInt(): number
        isJsonPrimitive(): boolean
        getAsLong(): number
        isJsonObject(): boolean
        hashCode(): number
        getAsBigInteger(): Internal.BigInteger
        getAsJsonObject(): Internal.JsonObject
        getAsJsonNull(): Internal.JsonNull
        isJsonNull(): boolean
        getAsDouble(): number
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonNull
        getAsJsonArray(): Internal.JsonArray
        getAsJsonPrimitive(): Internal.JsonPrimitive
        getAsBoolean(): boolean
        equals(arg0: any): boolean
        toString(): string
        getAsShort(): number
        static readonly INSTANCE : Internal.JsonNull;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarMobSpawnInfo {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isForceSurfaceSpawning(): boolean
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        useBiomeSpawnSettings(): boolean
        toString(): string
        notify(): void
        getSpawnInfo(): Internal.MobSpawnSettings
        static readonly CODEC : Internal.Codec<Internal.LunarMobSpawnInfo>;
        get spawnInfo(): Internal.MobSpawnSettings;
        get forceSurfaceSpawning(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Polygon implements Internal.Shape, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        intersects(arg0: Internal.Rectangle2D): boolean
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        notifyAll(): void
        invalidate(): void
        inside(arg0: number, arg1: number): boolean
        getBoundingBox(): Internal.Rectangle
        notify(): void
        addPoint(arg0: number, arg1: number): void
        getBounds(): Internal.Rectangle
        translate(arg0: number, arg1: number): void
        contains(arg0: Internal.Point2D): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point): boolean
        contains(arg0: number, arg1: number): boolean
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        hashCode(): number
        equals(arg0: any): boolean
        getBounds2D(): Internal.Rectangle2D
        reset(): void
        toString(): string
        ypoints : number[];
        xpoints : number[];
        npoints : number;
        get boundingBox(): Internal.Rectangle;
        get bounds(): Internal.Rectangle;
        get bounds2D(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ZoneOffsetTransitionRule implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getOffsetBefore(): Internal.ZoneOffset
        getOffsetAfter(): Internal.ZoneOffset
        notify(): void
        getDayOfWeek(): Internal.DayOfWeek
        isMidnightEndOfDay(): boolean
        getLocalTime(): Internal.LocalTime
        hashCode(): number
        static of(arg0: Internal.Month, arg1: number, arg2: Internal.DayOfWeek, arg3: Internal.LocalTime, arg4: boolean, arg5: Internal.ZoneOffsetTransitionRule$TimeDefinition, arg6: Internal.ZoneOffset, arg7: Internal.ZoneOffset, arg8: Internal.ZoneOffset): Internal.ZoneOffsetTransitionRule
        equals(arg0: any): boolean
        getStandardOffset(): Internal.ZoneOffset
        toString(): string
        getMonth(): Internal.Month
        getTimeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition
        createTransition(arg0: number): Internal.ZoneOffsetTransition
        getDayOfMonthIndicator(): number
        get localTime(): Internal.LocalTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get dayOfMonthIndicator(): number;
        get midnightEndOfDay(): boolean;
        get standardOffset(): Internal.ZoneOffset;
        get month(): Internal.Month;
        get timeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get offsetAfter(): Internal.ZoneOffset;
        get class(): Internal.Class<any>;
        get offsetBefore(): Internal.ZoneOffset;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientboundBlockEntityDataPacket implements Internal.Packet<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GenericDeclaration extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[]
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_
        getTypeParameters(): any[]
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
    }
    abstract class ImmutableMultisetGwtSerializationDependencies <E> extends Internal.ImmutableCollection<any> {
        add(arg0: E): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        notifyAll(): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        notify(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray(): any[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContextFactory$Listener {
        contextReleased(arg0: Internal.Context): void
        contextCreated(arg0: Internal.Context): void
    }
    interface UnbakedModel {
    }
    interface AccessorItemRenderer {
        callRenderQuadList(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.List<Internal.BakedQuad>, arg3: Internal.ItemStack, arg4: number, arg5: number): void
    }
    class ChannelInboundHandlerAdapter extends Internal.ChannelHandlerAdapter implements Internal.ChannelInboundHandler {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        notifyAll(): void
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        isSharable(): boolean
        notify(): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectOutput extends Internal.DataOutput, Internal.AutoCloseable {
        writeInt(arg0: number): void
        writeByte(arg0: number): void
        writeObject(arg0: any): void
        writeFloat(arg0: number): void
        writeChar(arg0: number): void
        writeLong(arg0: number): void
        writeBytes(arg0: string): void
        flush(): void
        writeUTF(arg0: string): void
        writeShort(arg0: number): void
        writeChars(arg0: string): void
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number[]): void
        write(arg0: number): void
        writeBoolean(arg0: boolean): void
        writeDouble(arg0: number): void
    }
    class IngredientStackJS implements Internal.IngredientJS {
        getItemIds(): Internal.Set<string>
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        anyStackMatches(ingredient: string): boolean
        anyStackMatches(ingredient: object): boolean
        anyStackMatches(ingredient: Internal.ItemStackJS): boolean
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        notifyAll(): void
        isInvalidRecipeIngredient(): boolean
        notify(): void
        not(): Internal.IngredientJS
        hashCode(): number
        getFirst(): Internal.ItemStackJS
        copy(): Internal.Copyable
        copy(): Internal.IngredientJS
        static stackOf(in_: Internal.ItemStackJS): Internal.IngredientStackJS
        static stackOf(in_: object): Internal.IngredientStackJS
        static stackOf(in_: string): Internal.IngredientStackJS
        static stackOf(in_: Internal.IngredientJS): Internal.IngredientStackJS
        getCount(): number
        test(stack: object): boolean
        test(stack: Internal.ItemStackJS): boolean
        test(stack: string): boolean
        testVanillaItem(item: Internal.Item): boolean
        isEmpty(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: object): Internal.IngredientJS
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        filter(filter: Internal.ItemStackJS): Internal.IngredientJS
        filter(filter: string): Internal.IngredientJS
        createVanillaIngredient(): (arg0: any) => boolean
        toJson(): Internal.JsonElement
        withCount(count: number): Internal.IngredientJS
        getIngredient(): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        equals(arg0: any): boolean
        testVanilla(stack: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        toString(): string
        ingredientKey : string;
        ingredient : Internal.IngredientJS;
        countKey : string;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StructType <S> {
        getLayout(): Internal.BufferLayout
        create(): S
    }
    interface Reference2DoubleFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        getDouble(arg0: any): number
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        removeDouble(arg0: any): number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IdMap <T> extends Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
    }
    class IsoEra extends Internal.Enum<any> implements Internal.Era {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.IsoEra
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        notifyAll(): void
        static values(): Internal.IsoEra[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.IsoEra): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IsoEra>>
        notify(): void
        getLong(arg0: Internal.TemporalField): number
        getDeclaringClass(): Internal.Class<Internal.IsoEra>
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        equals(arg0: any): boolean
        static of(arg0: number): Internal.IsoEra
        name(): string
        toString(): string
        ordinal(): number
        static readonly CE : Internal.IsoEra;
        static readonly BCE : Internal.IsoEra;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.IsoEra>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Scale <Self> {
        scale(arg0: number, arg1: number, arg2: number): Self
        scale(arg0: number): Self
    }
    interface FlavorMap {
        getNativesForFlavors(arg0: Internal.DataFlavor[]): Internal.Map<Internal.DataFlavor, string>
        getFlavorsForNatives(arg0: string[]): Internal.Map<string, Internal.DataFlavor>
    }
    interface Accessible {
        getAccessibleContext(): Internal.AccessibleContext
    }
    class CapabilityDispatcher implements Internal.INBTSerializable<Internal.CompoundTag>, Internal.ICapabilityProvider {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        deserializeNBT(arg0: Internal.CompoundTag): void
        deserializeNBT(arg0: Internal.Tag): void
        toString(): string
        invalidate(): void
        areCompatible(arg0: Internal.CapabilityDispatcher): boolean
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ClassDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfField<Internal.ClassDesc> {
        componentType(): Internal.ClassDesc
        componentType(): Internal.TypeDescriptor$OfField<any>
        arrayType(): Internal.TypeDescriptor$OfField<any>
        arrayType(): Internal.ClassDesc
        arrayType(arg0: number): Internal.ClassDesc
        displayName(): string
        equals(arg0: any): boolean
        descriptorString(): string
        isArray(): boolean
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any
        packageName(): string
        isClassOrInterface(): boolean
        isPrimitive(): boolean
        nested(arg0: string): Internal.ClassDesc
        nested(arg0: string, arg1: string[]): Internal.ClassDesc
    }
    interface Spliterator$OfLong extends Internal.Spliterator$OfPrimitive<number, Internal.LongConsumer, Internal.Spliterator$OfLong> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfLong
        characteristics(): number
        tryAdvance(arg0: any): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: Internal.LongConsumer): boolean
        getComparator(): Internal.Comparator<number>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: Internal.LongConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
    }
    interface IItemFilter {
        filter(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        resetFilterData(filter: Internal.ItemStack): void
        getItems(filter: Internal.ItemStack, set: Internal.Set<Internal.Item>): void
        filterItem(filter: Internal.ItemStack, item: Internal.Item): boolean
        getDisplayItemStacks(filter: Internal.ItemStack, list: Internal.List<Internal.ItemStack>): void
        addInfo(filter: Internal.ItemStack, info: Internal.FilterInfo, expanded: boolean): void
        clearFilterCache(filter: Internal.ItemStack): void
    }
    interface ByteChannel extends Internal.ReadableByteChannel, Internal.WritableByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        write(arg0: Internal.ByteBuffer): number
        close(): void
    }
    class InventoryJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getBlock(level: Internal.LevelJS): Internal.BlockContainerJS
        countNonEmpty(): number
        countNonEmpty(ingredient: Internal.IngredientJS): number
        countNonEmpty(ingredient: string): number
        countNonEmpty(ingredient: object): number
        countNonEmpty(ingredient: Internal.ItemStackJS): number
        set(slot: number, item: Internal.ItemStack): void
        markDirty(): void
        notifyAll(): void
        count(): number
        count(ingredient: Internal.IngredientJS): number
        count(ingredient: string): number
        count(ingredient: object): number
        count(ingredient: Internal.ItemStackJS): number
        isEmpty(): boolean
        clear(ingredient: Internal.IngredientJS): void
        clear(ingredient: string): void
        clear(ingredient: object): void
        clear(ingredient: Internal.ItemStackJS): void
        clear(): void
        insert(slot: number, item: Internal.ItemStack, simulate: boolean): Internal.ItemStackJS
        isItemValid(slot: number, item: Internal.ItemStack): boolean
        getWidth(): number
        notify(): void
        getSize(): number
        getHeight(): number
        extract(slot: number, amount: number, simulate: boolean): Internal.ItemStackJS
        hashCode(): number
        find(ingredient: Internal.IngredientJS): number
        find(ingredient: string): number
        find(ingredient: object): number
        find(ingredient: Internal.ItemStackJS): number
        find(): number
        equals(arg0: any): boolean
        get(slot: number): Internal.ItemStackJS
        getSlotLimit(slot: number): number
        toString(): string
        readonly minecraftInventory : Internal.ItemHandler;
        get size(): number;
        get width(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Hash {
    }
    interface Long2ByteFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: number): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): number
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface TaskType$Provider {
        create(arg0: Internal.Quest): Internal.Task
    }
    abstract class ScriptableObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Serializable, Internal.ConstProperties {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        getAllIds(): any[]
        put(index: number, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(name: string, start: Internal.Scriptable, value: any): void
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getExternalArrayLength(): any
        getAttributes(index: number): number
        getAttributes(name: string): number
        getAttributes(sym: Internal.Symbol): number
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: any): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        defineOwnProperty(cx: Internal.Context, id: any, desc: Internal.ScriptableObject): void
        getClassName(): string
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        notifyAll(): void
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        delete(index: number): void
        delete(key: Internal.Symbol): void
        delete(name: string): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        hashCode(): number
        isConst(name: string): boolean
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IPlayableFaction <T> extends Internal.IFaction<T> {
        getName(): Internal.Component
        getHighestReachableLevel(): number
        getChatColor(): Internal.TextColor
        renderLevel(): boolean
        getLordTitle(arg0: number, arg1: boolean): Internal.Component
        getFactionPlayerInterface(): Internal.Class<T>
        getHighestLordLevel(): number
        isEntityOfFaction(arg0: Internal.PathfinderMob): boolean
        getColor(): number
        getID(): ResourceLocation
        setRenderLevel(arg0: boolean): Internal.IPlayableFaction<T>
        getVillageData(): Internal.IFactionVillage
        isHostileTowardsNeutral(): boolean
        hasRefinements(): boolean
        getRefinementItem<Z_>(arg0: Internal.IRefinementItem$AccessorySlotType): Z_
        getPlayerCapability(arg0: Internal.Player): Internal.LazyOptional<T>
        getNamePlural(): Internal.Component
        getFactionEntityInterface(): Internal.Class<T>
    }
    interface IntComparator extends Internal.Comparator<number> {
        compare(arg0: any, arg1: any): number
        compare(arg0: number, arg1: number): number
        compare(arg0: number, arg1: number): number
        thenComparingLong(arg0: Internal.ToLongFunction<number>): Internal.Comparator<number>
        thenComparingInt(arg0: Internal.ToIntFunction<number>): Internal.Comparator<number>
        thenComparing(arg0: Internal.Comparator<number>): Internal.Comparator<number>
        thenComparing(arg0: Internal.IntComparator): Internal.IntComparator
        thenComparing<U_>(arg0: (arg0: number) => U_, arg1: Internal.Comparator<U_>): Internal.Comparator<number>
        thenComparing<U_>(arg0: (arg0: number) => U_): Internal.Comparator<number>
        thenComparingDouble(arg0: Internal.ToDoubleFunction<number>): Internal.Comparator<number>
        equals(arg0: any): boolean
        reversed(): Internal.IntComparator
        reversed(): Internal.Comparator<any>
    }
    interface Char2FloatFunction extends Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: string, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: string): number
        remove(arg0: any): any
        remove(arg0: any): number
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: string): number
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: string): number
        containsKey(arg0: string): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface IForgePackResources {
        isHidden(): boolean
    }
    class ScrollBar$Plane extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.ScrollBar$Plane
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.ScrollBar$Plane[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.ScrollBar$Plane): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ScrollBar$Plane>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.ScrollBar$Plane>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly VERTICAL : Internal.ScrollBar$Plane;
        readonly isVertical : boolean;
        static readonly HORIZONTAL : Internal.ScrollBar$Plane;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ScrollBar$Plane>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CallbackInfoReturnable <R> extends Internal.CallbackInfo {
        cancel(): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCancelled(): boolean
        setReturnValue(arg0: R): void
        getReturnValueB(): number
        notifyAll(): void
        getId(): string
        getReturnValueI(): number
        getReturnValueJ(): number
        getReturnValueC(): string
        getReturnValueD(): number
        notify(): void
        getReturnValueF(): number
        static getCallInfoClassName(arg0: org.objectweb.asm.Type): string
        getReturnValue(): R
        hashCode(): number
        equals(arg0: any): boolean
        isCancellable(): boolean
        toString(): string
        getReturnValueZ(): boolean
        getReturnValueS(): number
        get returnValueC(): string;
        get returnValueD(): number;
        get returnValueB(): number;
        get returnValue(): R;
        get returnValueF(): number;
        get returnValueI(): number;
        get returnValueJ(): number;
        get cancellable(): boolean;
        get returnValueS(): number;
        get cancelled(): boolean;
        get id(): string;
        get returnValueZ(): boolean;
        get class(): Internal.Class<any>;
        set returnValue(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableMap$Builder <K, V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        build(): Internal.ImmutableMap<K, V>
        buildOrThrow(): Internal.ImmutableMap<K, V>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMap$Builder<K, V>
        putAll(arg0: Internal.Map<K, V>): Internal.ImmutableMap$Builder<K, V>
        toString(): string
        orderEntriesByValue(arg0: Internal.Comparator<V>): Internal.ImmutableMap$Builder<K, V>
        notify(): void
        put(arg0: K, arg1: V): Internal.ImmutableMap$Builder<K, V>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMap$Builder<K, V>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WorldRendererAccess {
        callRenderHitOutline(arg0: Internal.PoseStack, arg1: Internal.VertexConsumer, arg2: Internal.Entity, arg3: number, arg4: number, arg5: number, arg6: BlockPos, arg7: Internal.BlockState): void
    }
    class ScheduledEvent {
        getServer(): Internal.ServerJS
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        isUsingTicks(): boolean
        notify(): void
        getTimerDuration(): number
        reschedule(): void
        reschedule(timer: number): Internal.ScheduledEvent
        getEndTime(): number
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        getData(): any
        getTimer(): number
        get server(): Internal.ServerJS;
        get timer(): number;
        get timerDuration(): number;
        get data(): any;
        get usingTicks(): boolean;
        get endTime(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Dictionary <K, V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        keys(): Internal.Enumeration<K>
        notifyAll(): void
        isEmpty(): boolean
        notify(): void
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        size(): number
        hashCode(): number
        equals(arg0: any): boolean
        elements(): Internal.Enumeration<V>
        get(arg0: any): V
        toString(): string
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FileLock implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        release(): void
        notifyAll(): void
        isValid(): boolean
        channel(): Internal.FileChannel
        notify(): void
        acquiredBy(): Internal.Channel
        size(): number
        hashCode(): number
        equals(arg0: any): boolean
        overlaps(arg0: number, arg1: number): boolean
        toString(): string
        position(): number
        close(): void
        isShared(): boolean
        get valid(): boolean;
        get shared(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AccessibleBundle {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toDisplayString(arg0: Internal.Locale): string
        toDisplayString(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PrivacyMode extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(name: string): Internal.PrivacyMode
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.PrivacyMode[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.PrivacyMode): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PrivacyMode>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.PrivacyMode>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly NAME_MAP : Internal.NameMap<Internal.PrivacyMode>;
        static readonly PUBLIC : Internal.PrivacyMode;
        static readonly VALUES : Internal.PrivacyMode[];
        static readonly ALLIES : Internal.PrivacyMode;
        static readonly PRIVATE : Internal.PrivacyMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PrivacyMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AABB {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface OpSupplier {
        create(arg0: Internal.Unit, arg1: Internal.Unit): Internal.Unit
    }
    interface Map <K, V> {
        getOrDefault(arg0: any, arg1: V): V
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Internal.Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: any): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: any): boolean
        putIfAbsent(arg0: K, arg1: V): V
    }
    class DoubleConfig extends Internal.NumberConfig<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<number>
        notifyAll(): void
        isEqual(v1: number, v2: number): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<number>): number
        notify(): void
        getCanEdit(): boolean
        getStringFromValue(arg0: any): string
        getStringFromValue(v: number): string
        getTooltip(): string
        hashCode(): number
        getStringForGUI(arg0: any): Internal.Component
        getStringForGUI(v: number): Internal.Component
        getPath(): string
        copy(value: number): number
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: number, c: (arg0: number) => void, def: number): Internal.ConfigValue<number>
        getColor(arg0: any): Internal.Color4I
        getColor(v: number): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        parse(callback: (arg0: number) => void, string: string): boolean
        getIcon(v: number): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<number>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<number>
        setNameKey(key: string): Internal.ConfigValue<number>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: number): boolean
        fader(v: boolean): Internal.NumberConfig<number>
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: number) => void;
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Annotation {
        hashCode(): number
        equals(arg0: any): boolean
        annotationType(): Internal.Class<Internal.Annotation>
        toString(): string
    }
    interface MouseMotionListener extends Internal.EventListener {
        mouseDragged(arg0: Internal.MouseEvent): void
        mouseMoved(arg0: Internal.MouseEvent): void
    }
    abstract class QuestObjectBase {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deleteChildren(): void
        readNetData(buffer: Internal.FriendlyByteBuf): void
        notifyAll(): void
        getMutableTitle(): Internal.MutableComponent
        getTags(): Internal.Set<string>
        getCodeString(): string
        static getCodeString(object: Internal.QuestObjectBase): string
        static getCodeString(id: number): string
        writeData(nbt: Internal.CompoundTag): void
        editedFromGUIOnServer(): void
        createSubGroup(group: Internal.ConfigGroup): Internal.ConfigGroup
        notify(): void
        forceProgress(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getTitle(): Internal.Component
        hashCode(): number
        getAltIcon(): Internal.Icon
        getObjectType(): (arg0: any) => boolean
        getPath(): string
        clearCachedData(): void
        getParentID(): number
        refreshJEI(): number
        editedFromGUI(): void
        static parseCodeString(id: string): number
        readData(nbt: Internal.CompoundTag): void
        hasTag(tag: string): boolean
        getQuestChapter(): Internal.Chapter
        static getID(object: Internal.QuestObjectBase): number
        getQuestFile(): Internal.QuestFile
        onEditButtonClicked(gui: Internal.Runnable): void
        writeNetData(buffer: Internal.FriendlyByteBuf): void
        getConfig(config: Internal.ConfigGroup): void
        getIcon(): Internal.Icon
        forceProgressRaw(teamData: Internal.TeamData, progressChange: Internal.ProgressChange): void
        getAltTitle(): Internal.Component
        static isNull(object: Internal.QuestObjectBase): boolean
        equals(object: any): boolean
        toString(): string
        deleteSelf(): void
        static titleToID(s: string): Internal.Optional<string>
        onCreated(): void
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        get path(): string;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): (arg0: any) => boolean;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CompoundTag implements Internal.Tag, Internal.CustomJavaObjectWrapper$AsMap {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        merge(arg0: Internal.CompoundTag): Internal.CompoundTag
        toString(): string
        wrapAsJavaMap(): Internal.Map<any, any>
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractMap <K, V> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getOrDefault(arg0: any, arg1: V): V
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        notifyAll(): void
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        notify(): void
        containsValue(arg0: any): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        putAll(arg0: Internal.Map<K, V>): void
        get(arg0: any): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        forEach(arg0: (arg0: K, arg1: V) => void): void
        containsKey(arg0: any): boolean
        isEmpty(): boolean
        clear(): void
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: any): boolean
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChronoPeriod extends Internal.TemporalAmount {
        minus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        isNegative(): boolean
        negated(): Internal.ChronoPeriod
        normalized(): Internal.ChronoPeriod
        plus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        multipliedBy(arg0: number): Internal.ChronoPeriod
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        hashCode(): number
        equals(arg0: any): boolean
        get(arg0: Internal.TemporalUnit): number
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        isZero(): boolean
        toString(): string
        getChronology(): Internal.Chronology
    }
    abstract class Projectile extends Internal.Entity {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        isDynamicLightEnabled(): boolean
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        revive(): void
        dynamicLightTick(): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        notify(): void
        hashCode(): number
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        asKJS(): any
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set remainingFireTicks(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveCodec <A> extends Internal.Codec<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>
        flatComapMap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>
        dispatch<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        deprecated(arg0: number): Internal.Codec<A>
        simple(): Internal.Decoder$Simple<A>
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>
        dispatchMap<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>
        comapFlatMap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => A): Internal.Codec<S_>
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T_>>
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T_>>
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>
        comap<B_>(arg0: (arg0: B_) => A): Internal.Encoder<B_>
        fieldOf(arg0: string): Internal.MapCodec<A>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.Codec<S_>
        listOf(): Internal.Codec<Internal.List<A>>
        map<B_>(arg0: (arg0: A) => B_): Internal.Decoder<B_>
        write<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): T_
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): Internal.DataResult<T_>
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.Encoder<B_>
        read<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<A>
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>
        terminal(): Internal.Decoder$Terminal<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>
        orElse(arg0: A): Internal.Codec<A>
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.Codec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.Decoder<B_>
        boxed(): Internal.Decoder$Boxed<A>
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.Codec<A>
        orElseGet(arg0: () => A): Internal.Codec<A>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>
        dispatchStable<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>
        stable(): Internal.Codec<A>
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>
    }
    interface InputMethodListener extends Internal.EventListener {
        inputMethodTextChanged(arg0: Internal.InputMethodEvent): void
        caretPositionChanged(arg0: Internal.InputMethodEvent): void
    }
    class BlockIDPredicate$PropertyObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: any, arg1: V): V
        getOrDefault(arg0: number, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    interface Functor <F, Mu> extends Internal.Kind1<F, Mu> {
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Mu, T_>): Internal.App<Mu, R_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>
    }
    interface ContextAwareComponent {
    }
    class Products$P3 <F, T1, T2, T3> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function3<T1, T2, T3, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.App<F, R>
        hashCode(): number
        and<T4, T5, T6, T7>(arg0: Internal.Products$P4<F, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T4>(arg0: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T4, T5>(arg0: Internal.Products$P2<F, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T4, T5, T6>(arg0: Internal.Products$P3<F, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        and<T4, T5, T6, T7, T8>(arg0: Internal.Products$P5<F, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        t1(): Internal.App<F, T1>
        notify(): void
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelResourceLocation extends ResourceLocation {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        setPath(arg0: string): void
        compareTo(arg0: ResourceLocation): number
        compareTo(arg0: any): number
        notify(): void
        getNamespace(): string
        hashCode(): number
        compareNamespaced(arg0: ResourceLocation): number
        equals(arg0: any): boolean
        getPath(): string
        toString(): string
        setNamespace(arg0: string): void
        specialEquals(o: any, shallow: boolean): boolean
        get path(): string;
        get namespace(): string;
        get class(): Internal.Class<any>;
        set path(arg0: string);
        set namespace(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IVampirismPlayer {
        getVampAtts(): Internal.VampirismPlayerAttributes
    }
    interface LevelKJS extends Internal.AsKJS {
        asKJS(): any
    }
    interface ArmorMaterial {
    }
    class Ingredient implements Internal.Predicate<Internal.ItemStack>, Internal.AccessorIngredient, Internal.IngredientKJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: Internal.ItemStack) => boolean): (arg0: Internal.ItemStack) => boolean
        test(arg0: Internal.ItemStack): boolean
        test(arg0: any): boolean
        checkInvalidation(): boolean
        notifyAll(): void
        isVanilla(): boolean
        static callFromValues_$md$204703$0(arg0: Internal.Stream<any>): (arg0: any) => boolean
        asKJS(): any
        notify(): void
        getSerializer(): Internal.IIngredientSerializer<(arg0: any) => boolean>
        static invalidateAll(): void
        and(arg0: (arg0: Internal.ItemStack) => boolean): (arg0: Internal.ItemStack) => boolean
        negate(): (arg0: Internal.ItemStack) => boolean
        hashCode(): number
        equals(arg0: any): boolean
        static merge(arg0: Internal.Collection<(arg0: any) => boolean>): (arg0: any) => boolean
        isSimple(): boolean
        toString(): string
        getItemsKJS(): Internal.ItemStack[]
        get serializer(): Internal.IIngredientSerializer<(arg0: any) => boolean>;
        get itemsKJS(): Internal.ItemStack[];
        get simple(): boolean;
        get class(): Internal.Class<any>;
        get vanilla(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function15 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function3<T13, T14, T15, R>>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function6<T10, T11, T12, T13, T14, T15, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15): R
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14, arg1: T15) => R>
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15) => R>
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function8<T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function7<T9, T10, T11, T12, T13, T14, T15, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function5<T11, T12, T13, T14, T15, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function4<T12, T13, T14, T15, R>>
        curry(): (arg0: T1) => Internal.Function14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function10<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function9<T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function12<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function11<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function13<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>
    }
    interface MessageSender {
        setStatusMessage(message: Internal.Component): void
        getName(): Internal.Text
        getDisplayName(): Internal.Text
        tell(arg0: Internal.Component): void
        runCommand(arg0: string): number
        runCommandSilent(command: string): number
    }
    interface DoubleConsumer {
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        accept(arg0: number): void
    }
    abstract class ForwardingObject {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EventsJS {
        getClass(): Internal.Class<any>
        postToHandlers(id: string, list: Internal.List<Internal.EventsJS$ScriptEventHandler>, event: Internal.EventJS): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        handlers(id: string): Internal.List<Internal.EventsJS$ScriptEventHandler>
        notifyAll(): void
        equals(arg0: any): boolean
        clear(): void
        toString(): string
        notify(): void
        listen(id: string, handler: Internal.IEventHandler): void
        readonly scriptManager : Internal.ScriptManager;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TeamMessage {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        write(now: number, buffer: Internal.FriendlyByteBuf): void
        notify(): void
        readonly date : number;
        readonly sender : Internal.UUID;
        readonly text : Internal.Component;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor implements Internal.Comparable<Internal.ModuleDescriptor> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toNameAndVersion(): string
        mainClass(): Internal.Optional<string>
        exports(): Internal.Set<Internal.ModuleDescriptor$Exports>
        notifyAll(): void
        compareTo(arg0: Internal.ModuleDescriptor): number
        compareTo(arg0: any): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Modifier>
        notify(): void
        provides(): Internal.Set<Internal.ModuleDescriptor$Provides>
        hashCode(): number
        static newOpenModule(arg0: string): Internal.ModuleDescriptor$Builder
        static newModule(arg0: string, arg1: Internal.Set<Internal.ModuleDescriptor$Modifier>): Internal.ModuleDescriptor$Builder
        static newModule(arg0: string): Internal.ModuleDescriptor$Builder
        isAutomatic(): boolean
        static read(arg0: Internal.InputStream): Internal.ModuleDescriptor
        static read(arg0: Internal.InputStream, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor
        static read(arg0: Internal.ByteBuffer): Internal.ModuleDescriptor
        static read(arg0: Internal.ByteBuffer, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor
        rawVersion(): Internal.Optional<string>
        packages(): Internal.Set<string>
        version(): Internal.Optional<Internal.ModuleDescriptor$Version>
        static newAutomaticModule(arg0: string): Internal.ModuleDescriptor$Builder
        isOpen(): boolean
        equals(arg0: any): boolean
        name(): string
        opens(): Internal.Set<Internal.ModuleDescriptor$Opens>
        uses(): Internal.Set<string>
        toString(): string
        requires(): Internal.Set<Internal.ModuleDescriptor$Requires>
        get automatic(): boolean;
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelWriter {
    }
    class JsonGenerator {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        json(id: ResourceLocation, json: Internal.JsonElement): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RuleTest {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Charset implements Internal.Comparable<Internal.Charset> {
        encode(arg0: string): Internal.ByteBuffer
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        aliases(): Internal.Set<string>
        static forName(arg0: string): Internal.Charset
        displayName(): string
        displayName(arg0: Internal.Locale): string
        newDecoder(): Internal.CharsetDecoder
        notifyAll(): void
        static defaultCharset(): Internal.Charset
        static isSupported(arg0: string): boolean
        compareTo(arg0: any): number
        compareTo(arg0: Internal.Charset): number
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer
        notify(): void
        contains(arg0: Internal.Charset): boolean
        hashCode(): number
        canEncode(): boolean
        equals(arg0: any): boolean
        newEncoder(): Internal.CharsetEncoder
        name(): string
        isRegistered(): boolean
        toString(): string
        static availableCharsets(): Internal.SortedMap<string, Internal.Charset>
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MessageSupplier {
        get(): org.apache.logging.log4j.message.Message
    }
    interface Compressable extends Internal.Keyable {
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>
    }
    interface ExclusionStrategy {
        shouldSkipClass(arg0: Internal.Class<any>): boolean
        shouldSkipField(arg0: Internal.FieldAttributes): boolean
    }
    abstract class Icon implements Internal.Drawable {
        drawStatic(matrixStack: Internal.PoseStack, x: number, y: number, w: number, h: number): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        withBorder(color: Internal.Color4I, roundEdges: boolean): Internal.Icon
        notifyAll(): void
        withColor(color: Internal.Color4I): Internal.Icon
        isEmpty(): boolean
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon
        draw(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void
        withTint(color: Internal.Color4I): Internal.Icon
        draw3D(matrixStack: Internal.PoseStack): void
        notify(): void
        static getIcon(id: string): Internal.Icon
        static getIcon(json: Internal.JsonElement): Internal.Icon
        static getIcon(id: ResourceLocation): Internal.Icon
        createPixelBuffer(): Internal.PixelBuffer
        getIngredient(): any
        hashCode(): number
        equals(o: any): boolean
        withPadding(padding: number): Internal.Icon
        toString(): string
        copy(): Internal.Icon
        hasPixelBuffer(): boolean
        combineWith(icon: Internal.Icon): Internal.Icon
        combineWith(icons: Internal.Icon[]): Internal.Icon
        getJson(): Internal.JsonElement
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IFluidHandler$FluidAction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.IFluidHandler$FluidAction
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.IFluidHandler$FluidAction[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.IFluidHandler$FluidAction): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IFluidHandler$FluidAction>>
        execute(): boolean
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.IFluidHandler$FluidAction>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        simulate(): boolean
        ordinal(): number
        static readonly EXECUTE : Internal.IFluidHandler$FluidAction;
        static readonly SIMULATE : Internal.IFluidHandler$FluidAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IFluidHandler$FluidAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IModelData {
        setData<T>(arg0: (arg0: T) => boolean, arg1: T): T
        hasProperty(arg0: (arg0: any) => boolean): boolean
        getData<T>(arg0: (arg0: T) => boolean): T
    }
    interface TypeAdapterFactory {
        create<T>(arg0: Internal.Gson, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>
    }
    abstract class PainterObject implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(o: any): boolean
        update(tag: Internal.CompoundTag): void
        toString(): string
        id(i: string): Internal.PainterObject
        notify(): void
        specialEquals(o: any, shallow: boolean): boolean
        parent : Internal.PainterObjectStorage;
        visible : boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ITaskMasterEntity extends Internal.IEntityWithHome {
        setHomeArea(arg0: BlockPos, arg1: number): void
        isWithinHomeDistance(arg0: number, arg1: number, arg2: number): boolean
        isWithinHomeDistance(arg0: BlockPos): boolean
        getHome(): Internal.AABB
        getHomePosition(): BlockPos
        setHome(arg0: Internal.AABB): void
    }
    interface Closeable extends Internal.AutoCloseable {
        close(): void
    }
    class PlayMessages$SpawnEntity {
        static encode(arg0: Internal.PlayMessages$SpawnEntity, arg1: Internal.FriendlyByteBuf): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getAdditionalData(): Internal.FriendlyByteBuf
        notifyAll(): void
        static handle(arg0: Internal.PlayMessages$SpawnEntity, arg1: () => Internal.NetworkEvent$Context): void
        static decode(arg0: Internal.FriendlyByteBuf): Internal.PlayMessages$SpawnEntity
        getEntity(): Internal.Entity
        getHeadYaw(): number
        getTypeId(): number
        notify(): void
        getYaw(): number
        getPitch(): number
        getVelY(): number
        getVelZ(): number
        hashCode(): number
        equals(arg0: any): boolean
        getVelX(): number
        getUuid(): Internal.UUID
        getPosZ(): number
        toString(): string
        getEntityId(): number
        getPosX(): number
        getPosY(): number
        get headYaw(): number;
        get velZ(): number;
        get entityId(): number;
        get velY(): number;
        get velX(): number;
        get uuid(): Internal.UUID;
        get yaw(): number;
        get posX(): number;
        get posY(): number;
        get posZ(): number;
        get typeId(): number;
        get additionalData(): Internal.FriendlyByteBuf;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get entity(): Internal.Entity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MultipartBlockStateGenerator {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        toJson(): Internal.JsonObject
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        part(when: string, consumer: (arg0: Internal.MultipartBlockStateGenerator$Part) => void): void
        part(when: string, model: string): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Externalizable extends Internal.Serializable {
        writeExternal(arg0: Internal.ObjectOutput): void
        readExternal(arg0: Internal.ObjectInput): void
    }
    interface IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement
        getRecipeManager(): Internal.RecipeManager
        getUnsidedLevel(): net.minecraft.world.level.Level
        getScoreboard(): Internal.Scoreboard
    }
    interface CoordinateConsumer {
        consume(arg0: number, arg1: number, arg2: number): void
    }
    class Vector3d {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NameMap <E> implements Internal.Iterable<E> {
        getPrevious(value: E): E
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(value: E): string
        getIndex(e: E): number
        notifyAll(): void
        notify(): void
        iterator(): Internal.Iterator<E>
        getRandom(rand: Internal.Random): E
        hashCode(): number
        static of<T_>(defaultValue: T_, values: Internal.List<T_>): Internal.NameMap$Builder<T_>
        static of<T_>(defaultValue: T_, values: T_[]): Internal.NameMap$Builder<T_>
        get(index: number): E
        get(s: string): E
        getStringIndex(s: string): number
        write(data: Internal.FriendlyByteBuf, object: E): void
        read(data: Internal.FriendlyByteBuf): E
        offset(value: E, index: number): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        getNullable(s: string): E
        getColor(value: E): Internal.Color4I
        getNext(value: E): E
        withDefault(def: E): Internal.NameMap<E>
        getIcon(v: E): Internal.Icon
        size(): number
        getDisplayName(value: E): Internal.Component
        equals(arg0: any): boolean
        toString(): string
        readonly defaultValue : E;
        readonly keys : Internal.List<string>;
        readonly values : Internal.List<E>;
        readonly map : Internal.Map<string, E>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkEvent$PacketDispatcher {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        sendPacket(arg0: ResourceLocation, arg1: Internal.FriendlyByteBuf): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Serializable {
    }
    class EnderMan extends Internal.Monster implements Internal.NeutralMob {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        setLootTable(arg0: ResourceLocation): void
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        dynamicLightTick(): void
        getGoalSelector(): Internal.GoalSelector
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        botania_getAmbientSound(): Internal.SoundEvent
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getClassification(arg0: boolean): Internal.MobCategory
        getTargetSelector(): Internal.GoalSelector
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        handler$zjc000$curio$isLookingAtMe(arg0: Internal.Player, arg1: Internal.CallbackInfoReturnable<any>): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get isInsidePortal(): boolean;
        get goalSelector(): Internal.GoalSelector;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get targetSelector(): Internal.GoalSelector;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set lootTable(arg0: ResourceLocation);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeBlockEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        requestModelDataUpdate(): void
        getModelData(): Internal.IModelData
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        getTileData(): Internal.CompoundTag
        onChunkUnloaded(): void
        getRenderBoundingBox(): Internal.AABB
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        onLoad(): void
        handleUpdateTag(arg0: Internal.CompoundTag): void
    }
    interface ItemEntityAccess {
        setAge(arg0: number): void
    }
    class FireworksJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        static of(o: any): Internal.FireworksJS
        toString(): string
        createFireworkRocket(w: net.minecraft.world.level.Level, x: number, y: number, z: number): Internal.FireworkRocketEntity
        notify(): void
        flight : number;
        lifetime : number;
        readonly explosions : Internal.List<Internal.FireworksJS$Explosion>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExplosionAccess {
    }
    interface K1 {
    }
    class OreConfiguration$TargetBlockState {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ColorAccess {
        getColorRaw(): number
    }
    interface RenderableImage {
        createRendering(arg0: Internal.RenderContext): Internal.RenderedImage
        getHeight(): number
        getProperty(arg0: string): any
        isDynamic(): boolean
        createScaledRendering(arg0: number, arg1: number, arg2: Internal.RenderingHints): Internal.RenderedImage
        getPropertyNames(): string[]
        createDefaultRendering(): Internal.RenderedImage
        getSources(): Internal.Vector<Internal.RenderableImage>
        getWidth(): number
        getMinX(): number
        getMinY(): number
    }
    class JsonWriter implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setSerializeNulls(arg0: boolean): void
        setHtmlSafe(arg0: boolean): void
        jsonValue(arg0: string): Internal.JsonWriter
        isLenient(): boolean
        notifyAll(): void
        endArray(): Internal.JsonWriter
        nullValue(): Internal.JsonWriter
        setLenient(arg0: boolean): void
        notify(): void
        endObject(): Internal.JsonWriter
        beginArray(): Internal.JsonWriter
        flush(): void
        beginObject(): Internal.JsonWriter
        hashCode(): number
        equals(arg0: any): boolean
        getSerializeNulls(): boolean
        name(arg0: string): Internal.JsonWriter
        setIndent(arg0: string): void
        toString(): string
        isHtmlSafe(): boolean
        close(): void
        value(arg0: boolean): Internal.JsonWriter
        value(arg0: number): Internal.JsonWriter
        value(arg0: number): Internal.JsonWriter
        value(arg0: string): Internal.JsonWriter
        value(arg0: boolean): Internal.JsonWriter
        value(arg0: Internal.Number): Internal.JsonWriter
        get serializeNulls(): boolean;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        get htmlSafe(): boolean;
        set serializeNulls(arg0: boolean);
        set indent(arg0: string);
        set lenient(arg0: boolean);
        set htmlSafe(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2IntFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: number): number
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: any, arg1: any): any
        remove(arg0: any): number
        remove(arg0: any): any
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        get(arg0: any): number
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: K): number
        removeInt(arg0: any): number
        apply(arg0: K): number
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        getInt(arg0: any): number
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class ShapedRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        noShrink(): Internal.ShapedRecipeJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        noMirror(): Internal.ShapedRecipeJS
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AccessibleRelation extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>
        getKey(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getTarget(): any[]
        toDisplayString(arg0: Internal.Locale): string
        toDisplayString(): string
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        setTarget(arg0: any): void
        setTarget(arg0: any[]): void
        toString(): string
        notify(): void
        static readonly EMBEDS : "embeds";
        static readonly EMBEDDED_BY : "embeddedBy";
        static readonly FLOWS_FROM_PROPERTY : "flowsFromProperty";
        static readonly LABELED_BY : "labeledBy";
        static readonly MEMBER_OF : "memberOf";
        static readonly SUBWINDOW_OF : "subwindowOf";
        static readonly LABELED_BY_PROPERTY : "labeledByProperty";
        static readonly CHILD_NODE_OF : "childNodeOf";
        static readonly SUBWINDOW_OF_PROPERTY : "subwindowOfProperty";
        static readonly CONTROLLED_BY : "controlledBy";
        static readonly EMBEDDED_BY_PROPERTY : "embeddedByProperty";
        static readonly LABEL_FOR : "labelFor";
        static readonly CONTROLLER_FOR : "controllerFor";
        static readonly PARENT_WINDOW_OF : "parentWindowOf";
        static readonly EMBEDS_PROPERTY : "embedsProperty";
        static readonly CONTROLLER_FOR_PROPERTY : "controllerForProperty";
        static readonly FLOWS_TO_PROPERTY : "flowsToProperty";
        static readonly CONTROLLED_BY_PROPERTY : "controlledByProperty";
        static readonly FLOWS_FROM : "flowsFrom";
        static readonly LABEL_FOR_PROPERTY : "labelForProperty";
        static readonly CHILD_NODE_OF_PROPERTY : "childNodeOfProperty";
        static readonly PARENT_WINDOW_OF_PROPERTY : "parentWindowOfProperty";
        static readonly FLOWS_TO : "flowsTo";
        static readonly MEMBER_OF_PROPERTY : "memberOfProperty";
        get class(): Internal.Class<any>;
        get key(): string;
        get target(): any[];
        set target(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExternalArrayData {
        setArrayElement(arg0: number, arg1: any): void
        getArrayLength(): number
        getArrayElement(arg0: number): any
    }
    interface RecordBuilder <T> {
        add(arg0: string, arg1: T): Internal.RecordBuilder<T>
        add(arg0: string, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        add(arg0: T, arg1: T): Internal.RecordBuilder<T>
        add(arg0: T, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        add(arg0: Internal.DataResult<T>, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        add<E>(arg0: string, arg1: E, arg2: Internal.Encoder<E>): Internal.RecordBuilder<T>
        withErrorsFrom(arg0: Internal.DataResult<any>): Internal.RecordBuilder<T>
        mapError(arg0: (arg0: any) => any): Internal.RecordBuilder<T>
        ops(): Internal.DynamicOps<T>
        setLifecycle(arg0: Internal.Lifecycle): Internal.RecordBuilder<T>
        build(arg0: T): Internal.DataResult<T>
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>
    }
    interface IForgeMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag): void
        addCurativeItem(arg0: Internal.ItemStack): void
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void
        isCurativeItem(arg0: Internal.ItemStack): boolean
        getCurativeItems(): Internal.List<Internal.ItemStack>
    }
    class DirectMethodHandleDesc$Kind extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: number, arg1: boolean): Internal.DirectMethodHandleDesc$Kind
        static valueOf(arg0: string): Internal.DirectMethodHandleDesc$Kind
        static valueOf(arg0: number): Internal.DirectMethodHandleDesc$Kind
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.DirectMethodHandleDesc$Kind[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DirectMethodHandleDesc$Kind): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DirectMethodHandleDesc$Kind>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly INTERFACE_SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        readonly refKind : number;
        static readonly SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly INTERFACE_VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly CONSTRUCTOR : Internal.DirectMethodHandleDesc$Kind;
        readonly isInterface : boolean;
        static readonly INTERFACE_STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function5 <T1, T2, T3, T4, T5, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5): R
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4, arg1: T5) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5) => R>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function3<T3, T4, T5, R>
        curry(): (arg0: T1) => Internal.Function4<T2, T3, T4, T5, R>
    }
    class KeyModifiers {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        capsLock(): boolean
        onlyControl(): boolean
        notifyAll(): void
        shift(): boolean
        start(): boolean
        alt(): boolean
        numLock(): boolean
        control(): boolean
        notify(): void
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        static readonly NONE : Internal.KeyModifiers;
        readonly modifiers : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DiscreteVSAccess {
        getZSize(): number
        getYSize(): number
        getXSize(): number
    }
    abstract class ZoneId implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        normalized(): Internal.ZoneId
        notifyAll(): void
        getId(): string
        notify(): void
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset): Internal.ZoneId
        static systemDefault(): Internal.ZoneId
        static getAvailableZoneIds(): Internal.Set<string>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        hashCode(): number
        static of(arg0: string, arg1: Internal.Map<string, string>): Internal.ZoneId
        static of(arg0: string): Internal.ZoneId
        equals(arg0: any): boolean
        static from(arg0: Internal.TemporalAccessor): Internal.ZoneId
        toString(): string
        getRules(): Internal.ZoneRules
        static readonly SHORT_IDS : Internal.Map<string, string>;
        get availableZoneIds(): Internal.Set<string>;
        get rules(): Internal.ZoneRules;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractClientPlayer extends Internal.Player {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        botania$setCritTarget(arg0: Internal.LivingEntity): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number
        dynamicLightTick(): void
        handler$zib000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getSuffixes(): Internal.Collection<Internal.MutableComponent>
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        setForcedPose(arg0: Internal.Pose): void
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        getPrefixes(): Internal.Collection<Internal.MutableComponent>
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        getVampAtts(): Internal.VampirismPlayerAttributes
        getClassification(arg0: boolean): Internal.MobCategory
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zjf000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable<any>): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        getStagesRawKJS(): Internal.Stages
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        getStages(): Internal.Stages
        handler$zho000$onGetFieldOfViewModifier(arg0: Internal.CallbackInfoReturnable<any>): void
        hashCode(): number
        getLastPos(): BlockPos
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        darkutils$setSleepTimer(arg0: number): void
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        darkutils$setEnchantmentSeed(arg0: number): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        redirect$zcm001$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        refreshDisplayName(): void
        getForcedPose(): Internal.Pose
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get isInsidePortal(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get stagesRawKJS(): Internal.Stages;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get vampAtts(): Internal.VampirismPlayerAttributes;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get persistentDataKJS(): Internal.CompoundTag;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LunarEventClient <T> implements Internal.SkyRenderable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMoonSize(): number
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getMoonTextureLocation(): ResourceLocation
        getSoundTrack(): Internal.SoundEvent
        toString(): string
        getColorSettings(): Internal.ColorSettings
        renderSky(arg0: Internal.PoseStack, arg1: number): void
        notify(): void
        get moonSize(): number;
        get moonTextureLocation(): ResourceLocation;
        get soundTrack(): Internal.SoundEvent;
        get colorSettings(): Internal.ColorSettings;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FuncSupplier$Func1 extends Internal.FuncSupplier {
        create(args: Internal.List<Internal.Unit>): Internal.Unit
        create1(arg0: Internal.Unit): Internal.Unit
    }
    interface Spliterator$OfInt extends Internal.Spliterator$OfPrimitive<number, java_.util.function_.IntConsumer, Internal.Spliterator$OfInt> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfInt
        characteristics(): number
        tryAdvance(arg0: any): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean
        getComparator(): Internal.Comparator<number>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
    }
    class GsonBuilder {
        setFieldNamingPolicy(arg0: Internal.FieldNamingPolicy): Internal.GsonBuilder
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        enableComplexMapKeySerialization(): Internal.GsonBuilder
        notifyAll(): void
        disableInnerClassSerialization(): Internal.GsonBuilder
        excludeFieldsWithModifiers(arg0: number[]): Internal.GsonBuilder
        setLenient(): Internal.GsonBuilder
        notify(): void
        serializeNulls(): Internal.GsonBuilder
        addSerializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder
        generateNonExecutableJson(): Internal.GsonBuilder
        registerTypeHierarchyAdapter(arg0: Internal.Class<any>, arg1: any): Internal.GsonBuilder
        addDeserializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder
        hashCode(): number
        setLongSerializationPolicy(arg0: Internal.LongSerializationPolicy): Internal.GsonBuilder
        registerTypeAdapterFactory(arg0: Internal.TypeAdapterFactory): Internal.GsonBuilder
        create(): Internal.Gson
        disableHtmlEscaping(): Internal.GsonBuilder
        setDateFormat(arg0: number, arg1: number): Internal.GsonBuilder
        setDateFormat(arg0: number): Internal.GsonBuilder
        setDateFormat(arg0: string): Internal.GsonBuilder
        setVersion(arg0: number): Internal.GsonBuilder
        setFieldNamingStrategy(arg0: Internal.FieldNamingStrategy): Internal.GsonBuilder
        serializeSpecialFloatingPointValues(): Internal.GsonBuilder
        registerTypeAdapter(arg0: Internal.Type, arg1: any): Internal.GsonBuilder
        setPrettyPrinting(): Internal.GsonBuilder
        equals(arg0: any): boolean
        toString(): string
        excludeFieldsWithoutExposeAnnotation(): Internal.GsonBuilder
        setExclusionStrategies(arg0: Internal.ExclusionStrategy[]): Internal.GsonBuilder
        get class(): Internal.Class<any>;
        set exclusionStrategies(arg0: Internal.ExclusionStrategy[]);
        set fieldNamingStrategy(arg0: Internal.FieldNamingStrategy);
        set fieldNamingPolicy(arg0: Internal.FieldNamingPolicy);
        set dateFormat(arg0: number);
        set longSerializationPolicy(arg0: Internal.LongSerializationPolicy);
        set version(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoubleUnaryOperator {
        applyAsDouble(arg0: number): number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
    }
    interface LongSpliterator extends Internal.Spliterator$OfLong {
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.LongSpliterator
        trySplit(): Internal.Spliterator$OfLong
        characteristics(): number
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: (arg0: any) => void): boolean
        tryAdvance(arg0: any): boolean
        tryAdvance(arg0: Internal.LongConsumer): boolean
        getComparator(): Internal.Comparator<any>
        getComparator(): Internal.LongComparator
        getExactSizeIfKnown(): number
        estimateSize(): number
        skip(arg0: number): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: any) => void): void
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: any): void
        forEachRemaining(arg0: Internal.LongConsumer): void
    }
    class SequencedAssemblyRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>
        getClass(): Internal.Class<any>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: string, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: Internal.ItemStackJS, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: object): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: string): Internal.IngredientJS
        convertReplacedInput(index: number, oldIngredient: object, newIngredient: Internal.ItemStackJS): Internal.IngredientJS
        getUniqueId(): string
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        replaceOutput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: string, with_: string, exact: boolean): boolean
        replaceOutput(i: string, with_: object, exact: boolean): boolean
        replaceOutput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: object, with_: string, exact: boolean): boolean
        replaceOutput(i: object, with_: object, exact: boolean): boolean
        replaceOutput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceOutput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        merge(data: any): Internal.RecipeJS
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>
        getPath(): string
        create(args: Internal.ListJS): void
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>
        id(_id: ResourceLocation): Internal.RecipeJS
        parseIngredientItem(o: any): Internal.IngredientJS
        parseIngredientItem(o: any, key: string): Internal.IngredientJS
        group(g: string): Internal.RecipeJS
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getInputIndex(ingredient: string, exact: boolean): number
        getInputIndex(ingredient: object, exact: boolean): number
        getInputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        setGroup(g: string): void
        transitionalItem(item: string): Internal.SequencedAssemblyRecipeJS
        transitionalItem(item: Internal.ItemStackJS): Internal.SequencedAssemblyRecipeJS
        transitionalItem(item: object): Internal.SequencedAssemblyRecipeJS
        serialize(): void
        getType(): string
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: string, with_: string, exact: boolean): boolean
        replaceInput(i: string, with_: object, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: string, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: object, with_: string, exact: boolean): boolean
        replaceInput(i: object, with_: object, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: object, with_: Internal.IngredientJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: string, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: object, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceInput(i: Internal.ItemStackJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getGroup(): string
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasOutput(ingredient: string, exact: boolean): boolean
        hasOutput(ingredient: object, exact: boolean): boolean
        hasOutput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMod(): string
        notifyAll(): void
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: object, newStack: object): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: string): Internal.ItemStackJS
        convertReplacedOutput(index: number, oldStack: string, newStack: object): Internal.ItemStackJS
        save(): void
        getId(): string
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        dontAdd(): void
        notify(): void
        serializeJson(): void
        createRecipe(): Internal.Recipe<any>
        getFromToString(): string
        hashCode(): number
        deserializeJson(): void
        getOrCreateId(): ResourceLocation
        deserialize(): void
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOutputIndex(ingredient: string, exact: boolean): number
        getOutputIndex(ingredient: object, exact: boolean): number
        getOutputIndex(ingredient: Internal.ItemStackJS, exact: boolean): number
        loops(loops: number): Internal.SequencedAssemblyRecipeJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        equals(arg0: any): boolean
        serializeItemStack(stack: object): Internal.JsonElement
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        serializeItemStack(stack: string): Internal.JsonElement
        toString(): string
        parseResultItem(o: any): Internal.ItemStackJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        hasInput(ingredient: string, exact: boolean): boolean
        hasInput(ingredient: object, exact: boolean): boolean
        hasInput(ingredient: Internal.ItemStackJS, exact: boolean): boolean
        replaceIngredient(filter: Internal.IngredientActionFilter, item: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: object): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootContext$EntityTarget extends Internal.Enum<any> implements Internal.EntityTargetKJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): Internal.LootContext$EntityTarget
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): Internal.LootContext$EntityTarget[]
        compareTo(arg0: any): number
        compareTo(arg0: Internal.LootContext$EntityTarget): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LootContext$EntityTarget>>
        notify(): void
        getDeclaringClass(): Internal.Class<Internal.LootContext$EntityTarget>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        getNameKJS(): string
        ordinal(): number
        static readonly DIRECT_KILLER : Internal.LootContext$EntityTarget;
        static readonly KILLER_PLAYER : Internal.LootContext$EntityTarget;
        static readonly KILLER : Internal.LootContext$EntityTarget;
        static readonly THIS : Internal.LootContext$EntityTarget;
        get nameKJS(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LootContext$EntityTarget>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function12 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function3<T10, T11, T12, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function5<T8, T9, T10, T11, T12, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function4<T9, T10, T11, T12, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function7<T6, T7, T8, T9, T10, T11, T12, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function6<T7, T8, T9, T10, T11, T12, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11, arg1: T12) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function9<T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function8<T5, T6, T7, T8, T9, T10, T11, T12, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function10<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>
        curry(): (arg0: T1) => Internal.Function11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>
    }
    interface Position {
    }
    abstract class Direction$Axis extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.Predicate<Internal.Direction> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        or(arg0: (arg0: Internal.Direction) => boolean): (arg0: Internal.Direction) => boolean
        test(arg0: Internal.Direction): boolean
        test(arg0: any): boolean
        static valueOf(arg0: string): (arg0: any) => boolean
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): (arg0: any) => boolean[]
        compareTo(arg0: any): number
        compareTo(arg0: (arg0: any) => boolean): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<(arg0: any) => boolean>>
        notify(): void
        getDeclaringClass(): Internal.Class<(arg0: any) => boolean>
        and(arg0: (arg0: Internal.Direction) => boolean): (arg0: Internal.Direction) => boolean
        negate(): (arg0: Internal.Direction) => boolean
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly X : (arg0: any) => boolean;
        static readonly Y : (arg0: any) => boolean;
        static readonly Z : (arg0: any) => boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<(arg0: any) => boolean>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Instant implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.Instant>, Internal.Serializable {
        static ofEpochSecond(arg0: number): Internal.Instant
        static ofEpochSecond(arg0: number, arg1: number): Internal.Instant
        getClass(): Internal.Class<any>
        minus(arg0: Internal.TemporalAmount): Internal.Instant
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Instant
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        static ofEpochMilli(arg0: number): Internal.Instant
        range(arg0: Internal.TemporalField): Internal.ValueRange
        minusMillis(arg0: number): Internal.Instant
        compareTo(arg0: Internal.Instant): number
        compareTo(arg0: any): number
        notify(): void
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.Instant
        static now(): Internal.Instant
        get(arg0: Internal.TemporalField): number
        plusSeconds(arg0: number): Internal.Instant
        static from(arg0: Internal.TemporalAccessor): Internal.Instant
        plusNanos(arg0: number): Internal.Instant
        truncatedTo(arg0: Internal.TemporalUnit): Internal.Instant
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_
        minusNanos(arg0: number): Internal.Instant
        getNano(): number
        toEpochMilli(): number
        static parse(arg0: Internal.CharSequence): Internal.Instant
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        atZone(arg0: Internal.ZoneId): Internal.ZonedDateTime
        isBefore(arg0: Internal.Instant): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Instant
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.Instant
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.Instant
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.Instant
        plusMillis(arg0: number): Internal.Instant
        equals(arg0: any): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.Instant
        getEpochSecond(): number
        isAfter(arg0: Internal.Instant): boolean
        static readonly MIN : Internal.Instant;
        static readonly MAX : Internal.Instant;
        static readonly EPOCH : Internal.Instant;
        get nano(): number;
        get epochSecond(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface HeadedModel {
    }
    abstract class StringValueData <T> {
        getClass(): Internal.Class<any>
        getValue(): T
        getValueAsComponent(): Internal.Component
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        setValueFromString(v: string): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        setValue(v: T): void
        toString(): string
        getValueAsString(): string
        notify(): void
        readonly filter : Internal.ItemStack;
        get valueAsComponent(): Internal.Component;
        get valueAsString(): string;
        get class(): Internal.Class<any>;
        get value(): T;
        set valueFromString(v: string);
        set value(v: T);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ColorProperty extends Internal.TeamProperty<any> {
        getClass(): Internal.Class<any>
        readValue(buf: Internal.FriendlyByteBuf): Internal.Color4I
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        fromNBT(tag: Internal.Tag): Internal.Optional<Internal.Color4I>
        notifyAll(): void
        notify(): void
        toNBT(value: Internal.Color4I): Internal.Tag
        getType(): Internal.TeamPropertyType<Internal.Color4I>
        hashCode(): number
        equals(o: any): boolean
        toString(value: Internal.Color4I): string
        toString(arg0: any): string
        toString(): string
        fromString(string: string): Internal.Optional<Internal.Color4I>
        writeValue(buf: Internal.FriendlyByteBuf, value: Internal.Color4I): void
        write(buf: Internal.FriendlyByteBuf): void
        config(config: Internal.ConfigGroup, value: Internal.TeamPropertyValue<Internal.Color4I>): void
        readonly defaultValue : Internal.Color4I;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<Internal.Color4I>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableList$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: any): Internal.ImmutableCollection$Builder<any>
        add(arg0: E): Internal.ImmutableList$Builder<E>
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableList$Builder<E>
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableList$Builder<E>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableList$Builder<E>
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        build(): Internal.ImmutableList<E>
        build(): Internal.ImmutableCollection<any>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AssetJsonGenerator extends Internal.JsonGenerator {
        multipartState(id: ResourceLocation, consumer: (arg0: Internal.MultipartBlockStateGenerator) => void): void
        getClass(): Internal.Class<any>
        blockState(id: ResourceLocation, consumer: (arg0: Internal.VariantBlockStateGenerator) => void): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        blockModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void
        hashCode(): number
        itemModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void
        notifyAll(): void
        equals(arg0: any): boolean
        json(id: ResourceLocation, json: Internal.JsonElement): void
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelHandlerContext extends Internal.AttributeMap, Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker {
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        disconnect(): Internal.ChannelFuture
        handler(): Internal.ChannelHandler
        newProgressivePromise(): Internal.ChannelProgressivePromise
        fireChannelWritabilityChanged(): Internal.ChannelHandlerContext
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        channel(): io.netty.channel.Channel
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelHandlerContext
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelHandlerContext
        fireChannelActive(): Internal.ChannelInboundInvoker
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        writeAndFlush(arg0: any): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        isRemoved(): boolean
        flush(): Internal.ChannelHandlerContext
        flush(): Internal.ChannelOutboundInvoker
        executor(): Internal.EventExecutor
        attr<T_>(arg0: Internal.AttributeKey<T_>): Internal.Attribute<T_>
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: any): Internal.ChannelFuture
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
        read(): Internal.ChannelHandlerContext
        read(): Internal.ChannelOutboundInvoker
        fireChannelInactive(): Internal.ChannelHandlerContext
        fireChannelInactive(): Internal.ChannelInboundInvoker
        fireChannelReadComplete(): Internal.ChannelHandlerContext
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        hasAttr<T_>(arg0: Internal.AttributeKey<T_>): boolean
        fireChannelRegistered(): Internal.ChannelHandlerContext
        fireChannelRegistered(): Internal.ChannelInboundInvoker
        pipeline(): Internal.ChannelPipeline
        fireChannelRead(arg0: any): Internal.ChannelHandlerContext
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        name(): string
        fireUserEventTriggered(arg0: any): Internal.ChannelHandlerContext
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker
        alloc(): Internal.ByteBufAllocator
        fireChannelUnregistered(): Internal.ChannelHandlerContext
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
    }
    interface Long2CharFunction extends Internal.Function<number, string>, Internal.LongToIntFunction {
        getOrDefault(arg0: number, arg1: string): string
        getOrDefault(arg0: any, arg1: any): any
        getOrDefault(arg0: any, arg1: string): string
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        put(arg0: any, arg1: any): any
        remove(arg0: number): string
        remove(arg0: any): any
        remove(arg0: any): string
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        get(arg0: number): string
        get(arg0: any): string
        get(arg0: any): any
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        applyAsInt(arg0: number): number
        apply(arg0: number): string
        containsKey(arg0: number): boolean
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class LocalPlayer extends Internal.AbstractClientPlayer {
        getClass(): Internal.Class<any>
        callUnsetRemoved(): void
        resetDynamicLight(): void
        handler$zda000$removed(arg0: Internal.CallbackInfo): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        botania$setCritTarget(arg0: Internal.LivingEntity): void
        handler$zia000$onIsUsingItem(arg0: Internal.CallbackInfoReturnable<any>): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        isDynamicLightEnabled(): boolean
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
        serializeNBT(): Internal.Tag
        serializeNBT(): Internal.CompoundTag
        invalidateCaps(): void
        redirect$zcn002$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setDynamicLightEnabled(arg0: boolean): void
        shouldUpdateDynamicLight(): boolean
        foodEatenKJS(is: Internal.ItemStack): void
        revive(): void
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number
        dynamicLightTick(): void
        handler$zib000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void
        getPersistentDataKJS(): Internal.CompoundTag
        getDynamicLightY(): number
        canUpdate(): boolean
        canUpdate(arg0: boolean): void
        handler$zpe000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void
        getSuffixes(): Internal.Collection<Internal.MutableComponent>
        getDynamicLightZ(): number
        getDynamicLightX(): number
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        reviveCaps(): void
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer): boolean
        setForcedPose(arg0: Internal.Pose): void
        canRiderInteract(): boolean
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer): void
        onAddedToWorld(): void
        getPrefixes(): Internal.Collection<Internal.MutableComponent>
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        getCitadelEntityData(): Internal.CompoundTag
        localvar$zhk000$caelus$affixEmptyStack(arg0: Internal.ItemStack): Internal.ItemStack
        getVampAtts(): Internal.VampirismPlayerAttributes
        getClassification(arg0: boolean): Internal.MobCategory
        an_shouldDropExperience(): boolean
        shouldRiderSit(): boolean
        getIsInsidePortal(): boolean
        bookshelf$createHoverEvent(): Internal.HoverEvent
        static getDataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        handler$zjf000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable<any>): void
        notifyAll(): void
        an_getExperienceReward(arg0: Internal.Player): number
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        getStagesRawKJS(): Internal.Stages
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource): Internal.LootContext$Builder
        notify(): void
        getStages(): Internal.Stages
        handler$zho000$onGetFieldOfViewModifier(arg0: Internal.CallbackInfoReturnable<any>): void
        redirect$zcl000$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        hashCode(): number
        getLastPos(): BlockPos
        updateSyncFields(arg0: Internal.LocalPlayer): void
        handler$zda000$onRemove(arg0: Internal.CallbackInfo): void
        isAddedToWorld(): boolean
        darkutils$setSleepTimer(arg0: number): void
        handler$bim000$isPoseClear(arg0: Internal.Pose, arg1: Internal.CallbackInfoReturnable<any>): void
        getParts(): any[]
        handler$zpe000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void
        getDynamicLightWorld(): net.minecraft.world.level.Level
        handler$zhk000$caelus$checkFlight(arg0: Internal.CallbackInfo): void
        static getDataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>
        redirect$zcn000$eytraValidOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        onRemovedFromWorld(): void
        darkutils$setEnchantmentSeed(arg0: number): void
        getLuminance(): number
        isMultipartEntity(): boolean
        setUseItemRemaining(arg0: number): void
        deserializeNBT(arg0: Internal.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        asKJS(): any
        redirect$zcm001$elytraOverride(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        equals(arg0: any): boolean
        handler$zda000$onTick(arg0: Internal.CallbackInfo): void
        toString(): string
        setRemainingFireTicks(arg0: number): void
        refreshDisplayName(): void
        getForcedPose(): Internal.Pose
        handler$cah000$noSwimmingWithHeavyBootsOn(arg0: Internal.CallbackInfoReturnable<any>): void
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get isInsidePortal(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get dataEffectColorId_$md$204703$1(): Internal.EntityDataAccessor<any>;
        get stagesRawKJS(): Internal.Stages;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dataEffectAmbienceId_$md$204703$0(): Internal.EntityDataAccessor<any>;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get lastPos(): BlockPos;
        get vampAtts(): Internal.VampirismPlayerAttributes;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get persistentDataKJS(): Internal.CompoundTag;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): net.minecraft.world.level.Level;
        set dynamicLightEnabled(arg0: boolean);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set useItemRemaining(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TextAttribute extends Internal.AttributedCharacterIterator$Attribute {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly WEIGHT_BOLD : 2.0;
        static readonly UNDERLINE_LOW_GRAY : 4;
        static readonly NUMERIC_SHAPING : Internal.TextAttribute;
        static readonly WIDTH_SEMI_CONDENSED : 0.875;
        static readonly WIDTH_REGULAR : 1.0;
        static readonly SWAP_COLORS : Internal.TextAttribute;
        static readonly WIDTH_SEMI_EXTENDED : 1.25;
        static readonly RUN_DIRECTION : Internal.TextAttribute;
        static readonly WIDTH_EXTENDED : 1.5;
        static readonly CHAR_REPLACEMENT : Internal.TextAttribute;
        static readonly BIDI_EMBEDDING : Internal.TextAttribute;
        static readonly UNDERLINE_LOW_DASHED : 5;
        static readonly INPUT_METHOD_HIGHLIGHT : Internal.TextAttribute;
        static readonly STRIKETHROUGH_ON : true;
        static readonly TRANSFORM : Internal.TextAttribute;
        static readonly WEIGHT : Internal.TextAttribute;
        static readonly SWAP_COLORS_ON : true;
        static readonly JUSTIFICATION_FULL : 1.0;
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly WEIGHT_HEAVY : 2.25;
        static readonly SIZE : Internal.TextAttribute;
        static readonly POSTURE_REGULAR : 0.0;
        static readonly KERNING_ON : 1;
        static readonly BACKGROUND : Internal.TextAttribute;
        static readonly RUN_DIRECTION_LTR : false;
        static readonly RUN_DIRECTION_RTL : true;
        static readonly WIDTH_CONDENSED : 0.75;
        static readonly LIGATURES_ON : 1;
        static readonly SUPERSCRIPT : Internal.TextAttribute;
        static readonly JUSTIFICATION : Internal.TextAttribute;
        static readonly KERNING : Internal.TextAttribute;
        static readonly WEIGHT_SEMIBOLD : 1.25;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly LIGATURES : Internal.TextAttribute;
        static readonly WEIGHT_DEMILIGHT : 0.875;
        static readonly WEIGHT_ULTRABOLD : 2.75;
        static readonly JUSTIFICATION_NONE : 0.0;
        static readonly UNDERLINE_LOW_ONE_PIXEL : 1;
        static readonly UNDERLINE_ON : 0;
        static readonly POSTURE_OBLIQUE : 0.2;
        static readonly WEIGHT_REGULAR : 1.0;
        static readonly WIDTH : Internal.TextAttribute;
        static readonly SUPERSCRIPT_SUPER : 1;
        static readonly UNDERLINE : Internal.TextAttribute;
        static readonly FAMILY : Internal.TextAttribute;
        static readonly WEIGHT_LIGHT : 0.75;
        static readonly POSTURE : Internal.TextAttribute;
        static readonly TRACKING_LOOSE : 0.04;
        static readonly WEIGHT_EXTRA_LIGHT : 0.5;
        static readonly TRACKING : Internal.TextAttribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_UNDERLINE : Internal.TextAttribute;
        static readonly TRACKING_TIGHT : -0.04;
        static readonly UNDERLINE_LOW_DOTTED : 3;
        static readonly SUPERSCRIPT_SUB : -1;
        static readonly FONT : Internal.TextAttribute;
        static readonly FOREGROUND : Internal.TextAttribute;
        static readonly STRIKETHROUGH : Internal.TextAttribute;
        static readonly WEIGHT_DEMIBOLD : 1.75;
        static readonly WEIGHT_EXTRABOLD : 2.5;
        static readonly WEIGHT_MEDIUM : 1.5;
        static readonly UNDERLINE_LOW_TWO_PIXEL : 2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Buffer {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hasArray(): boolean
        notifyAll(): void
        hasRemaining(): boolean
        clear(): Internal.Buffer
        duplicate(): Internal.Buffer
        notify(): void
        remaining(): number
        capacity(): number
        isReadOnly(): boolean
        rewind(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(): Internal.Buffer
        array(): any
        hashCode(): number
        equals(arg0: any): boolean
        limit(arg0: number): Internal.Buffer
        limit(): number
        reset(): Internal.Buffer
        arrayOffset(): number
        toString(): string
        position(): number
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        isDirect(): boolean
        mark(): Internal.Buffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LongOpenHashSet extends Internal.AbstractLongSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>
        longIterator(): Internal.LongIterator
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        notify(): void
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        removeAll(arg0: Internal.LongCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.LongIterator
        trim(): boolean
        trim(arg0: number): boolean
        stream(): Internal.Stream<number>
        hashCode(): number
        static of(): Internal.LongOpenHashSet
        static of(arg0: number[]): Internal.LongOpenHashSet
        static of(arg0: number, arg1: number, arg2: number): Internal.LongOpenHashSet
        static of(arg0: number, arg1: number): Internal.LongOpenHashSet
        static of(arg0: number): Internal.LongOpenHashSet
        toArray(arg0: number[]): number[]
        toArray(): any[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        longStream(): Internal.LongStream
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        longSpliterator(): Internal.LongSpliterator
        toLongArray(): number[]
        toLongArray(arg0: number[]): number[]
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.LongSpliterator
        forEach(arg0: Internal.LongConsumer): void
        forEach(arg0: (arg0: any) => void): void
        forEach(arg0: (arg0: number) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        containsAll(arg0: Internal.LongCollection): boolean
        isEmpty(): boolean
        clear(): void
        static toSetWithExpectedSize(arg0: Internal.LongStream, arg1: number): Internal.LongOpenHashSet
        longParallelStream(): Internal.LongStream
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: java_.util.function_.LongPredicate): boolean
        static toSet(arg0: Internal.LongStream): Internal.LongOpenHashSet
        contains(arg0: number): boolean
        contains(arg0: any): boolean
        size(): number
        addAll(arg0: Internal.LongCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        clone(): any
        clone(): Internal.LongOpenHashSet
        toString(): string
        retainAll(arg0: Internal.Collection<any>): boolean
        retainAll(arg0: Internal.LongCollection): boolean
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ObjectMap <V> extends Internal.Int2ObjectFunction<V>, Internal.Map<number, V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: any, arg1: V): V
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): V
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction<V>): V
        computeIfAbsent(arg0: number, arg1: (arg0: number) => V): V
        values(): Internal.Collection<any>
        values(): Internal.ObjectCollection<V>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): V
        replaceAll(arg0: (arg0: number, arg1: V) => V): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        containsValue(arg0: any): boolean
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number, arg1: any): boolean
        remove(arg0: any): V
        remove(arg0: number): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        int2ObjectEntrySet(): Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>>
        hashCode(): number
        putAll(arg0: Internal.Map<number, V>): void
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        forEach(arg0: (arg0: number, arg1: V) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        equals(arg0: any): boolean
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        putIfAbsent(arg0: number, arg1: V): V
        putIfAbsent(arg0: number, arg1: V): V
    }
    abstract class RectangularShape implements Internal.Shape, Internal.Cloneable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        intersects(arg0: Internal.Rectangle2D): boolean
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        notifyAll(): void
        getFrame(): Internal.Rectangle2D
        getWidth(): number
        notify(): void
        getBounds(): Internal.Rectangle
        setFrameFromCenter(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void
        getHeight(): number
        getPathIterator(arg0: Internal.AffineTransform, arg1: number): Internal.PathIterator
        getPathIterator(arg0: Internal.AffineTransform): Internal.PathIterator
        setFrame(arg0: Internal.Point2D, arg1: Internal.Dimension2D): void
        setFrame(arg0: Internal.Rectangle2D): void
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void
        hashCode(): number
        getCenterY(): number
        getCenterX(): number
        isEmpty(): boolean
        getMaxX(): number
        getMaxY(): number
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void
        setFrameFromDiagonal(arg0: Internal.Point2D, arg1: Internal.Point2D): void
        contains(arg0: Internal.Point2D): boolean
        contains(arg0: Internal.Rectangle2D): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean
        getX(): number
        getY(): number
        equals(arg0: any): boolean
        getBounds2D(): Internal.Rectangle2D
        clone(): any
        toString(): string
        getMinX(): number
        getMinY(): number
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        get height(): number;
        set frame(arg0: Internal.Rectangle2D);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CustomJavaObjectWrapper$AsMap extends Internal.CustomJavaObjectWrapper {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable
        wrapAsJavaMap(): Internal.Map<any, any>
    }
    class StringBuilder extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuilder>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        deleteCharAt(arg0: number): Internal.StringBuilder
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        codePointAt(arg0: number): number
        notifyAll(): void
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuilder
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: any): Internal.StringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.StringBuilder
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.StringBuilder
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        compareTo(arg0: any): number
        compareTo(arg0: Internal.StringBuilder): number
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.StringBuilder
        notify(): void
        substring(arg0: number, arg1: number): string
        substring(arg0: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.StringBuilder
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        hashCode(): number
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        isEmpty(): boolean
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.StringBuilder
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string, arg1: number): number
        lastIndexOf(arg0: string): number
        setLength(arg0: number): void
        equals(arg0: any): boolean
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.StringBuilder
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.StringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuilder
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: string[]): Internal.StringBuilder
        append(arg0: any): Internal.AbstractStringBuilder
        append(arg0: any): Internal.StringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.StringBuilder
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: boolean): Internal.StringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuilder
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Instance {
        getWorldPosition(): BlockPos
    }
    class Format$Field extends Internal.AttributedCharacterIterator$Attribute {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeTransformation {
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation
        blockCornerToCenter(): Internal.Transformation
        isIdentity(): boolean
        rotateTransform(arg0: Internal.Direction): Internal.Direction
        transformPosition(arg0: Internal.Vector4f): void
        transformNormal(arg0: Internal.Vector3f): void
        push(arg0: Internal.PoseStack): void
        blockCenterToCorner(): Internal.Transformation
    }
    interface LongStream extends Internal.BaseStream<number, Internal.LongStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.LongStream
        takeWhile(arg0: java_.util.function_.LongPredicate): Internal.LongStream
        distinct(): Internal.LongStream
        findFirst(): Internal.OptionalLong
        sum(): number
        skip(arg0: number): Internal.LongStream
        allMatch(arg0: java_.util.function_.LongPredicate): boolean
        mapToObj<U_>(arg0: Internal.LongFunction<U_>): Internal.Stream<U_>
        mapMulti(arg0: Internal.LongStream$LongMapMultiConsumer): Internal.LongStream
        iterator(): Internal.Iterator<any>
        iterator(): Internal.PrimitiveIterator$OfLong
        asDoubleStream(): Internal.DoubleStream
        min(): Internal.OptionalLong
        parallel(): Internal.LongStream
        parallel(): Internal.BaseStream<any, any>
        noneMatch(arg0: java_.util.function_.LongPredicate): boolean
        findAny(): Internal.OptionalLong
        isParallel(): boolean
        limit(arg0: number): Internal.LongStream
        toArray(): number[]
        forEachOrdered(arg0: Internal.LongConsumer): void
        close(): void
        anyMatch(arg0: java_.util.function_.LongPredicate): boolean
        map(arg0: Internal.LongUnaryOperator): Internal.LongStream
        mapToDouble(arg0: Internal.LongToDoubleFunction): Internal.DoubleStream
        unordered(): Internal.LongStream
        reduce(arg0: Internal.LongBinaryOperator): Internal.OptionalLong
        reduce(arg0: number, arg1: Internal.LongBinaryOperator): number
        spliterator(): Internal.Spliterator$OfLong
        spliterator(): Internal.Spliterator<any>
        max(): Internal.OptionalLong
        forEach(arg0: Internal.LongConsumer): void
        count(): number
        dropWhile(arg0: java_.util.function_.LongPredicate): Internal.LongStream
        peek(arg0: Internal.LongConsumer): Internal.LongStream
        flatMap(arg0: Internal.LongFunction<Internal.LongStream>): Internal.LongStream
        filter(arg0: java_.util.function_.LongPredicate): Internal.LongStream
        onClose(arg0: Internal.Runnable): Internal.LongStream
        sorted(): Internal.LongStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.LongSummaryStatistics
        mapToInt(arg0: Internal.LongToIntFunction): Internal.IntStream
        collect<R_>(arg0: () => R_, arg1: Internal.ObjLongConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_
    }
    class Explosion implements Internal.ExplosionAccess {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getPosition(): Vec3
        hashCode(): number
        getExploder(): Internal.Entity
        notifyAll(): void
        equals(arg0: any): boolean
        static callAddBlockDrops_$md$204703$0(arg0: Internal.ObjectArrayList<any>, arg1: Internal.ItemStack, arg2: BlockPos): void
        toString(): string
        notify(): void
        readonly position : Vec3;
        get exploder(): Internal.Entity;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InetAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isMCOrgLocal(): boolean
        notifyAll(): void
        notify(): void
        isLoopbackAddress(): boolean
        isMCLinkLocal(): boolean
        isSiteLocalAddress(): boolean
        isMulticastAddress(): boolean
        hashCode(): number
        static getByName(arg0: string): Internal.InetAddress
        static getLoopbackAddress(): Internal.InetAddress
        getAddress(): number[]
        getHostAddress(): string
        isMCNodeLocal(): boolean
        isMCSiteLocal(): boolean
        isReachable(arg0: number): boolean
        isReachable(arg0: Internal.NetworkInterface, arg1: number, arg2: number): boolean
        getHostName(): string
        isMCGlobal(): boolean
        static getAllByName(arg0: string): Internal.InetAddress[]
        isLinkLocalAddress(): boolean
        getCanonicalHostName(): string
        isAnyLocalAddress(): boolean
        static getLocalHost(): Internal.InetAddress
        equals(arg0: any): boolean
        static getByAddress(arg0: string, arg1: number[]): Internal.InetAddress
        static getByAddress(arg0: number[]): Internal.InetAddress
        toString(): string
        get linkLocalAddress(): boolean;
        get loopbackAddress(): Internal.InetAddress;
        get hostName(): string;
        get address(): number[];
        get canonicalHostName(): string;
        get mCOrgLocal(): boolean;
        get siteLocalAddress(): boolean;
        get mCNodeLocal(): boolean;
        get mCGlobal(): boolean;
        get mCLinkLocal(): boolean;
        get multicastAddress(): boolean;
        get localHost(): Internal.InetAddress;
        get hostAddress(): string;
        get class(): Internal.Class<any>;
        get mCSiteLocal(): boolean;
        get anyLocalAddress(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DoubleBuffer extends Internal.Buffer implements Internal.Comparable<Internal.DoubleBuffer> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        compact(): Internal.DoubleBuffer
        notifyAll(): void
        compareTo(arg0: any): number
        compareTo(arg0: Internal.DoubleBuffer): number
        notify(): void
        asReadOnlyBuffer(): Internal.DoubleBuffer
        put(arg0: number[]): Internal.DoubleBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer
        put(arg0: number, arg1: number[]): Internal.DoubleBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        put(arg0: number, arg1: Internal.DoubleBuffer, arg2: number, arg3: number): Internal.DoubleBuffer
        put(arg0: Internal.DoubleBuffer): Internal.DoubleBuffer
        put(arg0: number, arg1: number): Internal.DoubleBuffer
        put(arg0: number): Internal.DoubleBuffer
        capacity(): number
        isReadOnly(): boolean
        slice(): Internal.Buffer
        slice(): Internal.DoubleBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.DoubleBuffer
        array(): number[]
        array(): any
        hashCode(): number
        get(): number
        get(arg0: number, arg1: number[]): Internal.DoubleBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        get(arg0: number[]): Internal.DoubleBuffer
        limit(arg0: number): Internal.DoubleBuffer
        limit(arg0: number): Internal.Buffer
        limit(): number
        arrayOffset(): number
        flip(): Internal.Buffer
        flip(): Internal.DoubleBuffer
        order(): Internal.ByteOrder
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        clear(): Internal.DoubleBuffer
        duplicate(): Internal.DoubleBuffer
        duplicate(): Internal.Buffer
        remaining(): number
        static allocate(arg0: number): Internal.DoubleBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.DoubleBuffer
        mismatch(arg0: Internal.DoubleBuffer): number
        equals(arg0: any): boolean
        reset(): Internal.Buffer
        reset(): Internal.DoubleBuffer
        toString(): string
        position(arg0: number): Internal.DoubleBuffer
        position(arg0: number): Internal.Buffer
        position(): number
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.DoubleBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        mark(): Internal.Buffer
        mark(): Internal.DoubleBuffer
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P11 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>): Internal.App<F, R>
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StringRepresentable {
    }
    interface Object2ReferenceFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_
        put(arg0: K, arg1: V): V
        remove(arg0: any): V
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        get(arg0: any): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: K): V
        containsKey(arg0: any): boolean
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V
        size(): number
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
    }
    class BooleanConfig extends Internal.ConfigWithVariants<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        setCanEdit(e: boolean): Internal.ConfigValue<boolean>
        notifyAll(): void
        isEqual(v1: boolean, v2: boolean): boolean
        compareTo(arg0: any): number
        compareTo(o: Internal.ConfigValue<boolean>): number
        notify(): void
        getCanEdit(): boolean
        getTooltip(): string
        getIteration(v: boolean, next: boolean): boolean
        getIteration(arg0: any, arg1: boolean): any
        hashCode(): number
        getStringForGUI(v: boolean): Internal.Component
        getStringForGUI(arg0: any): Internal.Component
        getPath(): string
        copy(value: boolean): boolean
        static info(key: string, value: any): Internal.Component
        init(g: Internal.ConfigGroup, i: string, v: boolean, c: (arg0: boolean) => void, def: boolean): Internal.ConfigValue<boolean>
        getColor(arg0: any): Internal.Color4I
        getColor(v: boolean): Internal.Color4I
        addInfo(list: Internal.TooltipList): void
        getIcon(arg0: any): Internal.Icon
        getIcon(v: boolean): Internal.Icon
        setIcon(i: Internal.Icon): Internal.ConfigValue<boolean>
        getNameKey(): string
        setOrder(o: number): Internal.ConfigValue<boolean>
        setNameKey(key: string): Internal.ConfigValue<boolean>
        equals(arg0: any): boolean
        onClicked(button: Internal.MouseButton, callback: Internal.ConfigCallback): void
        toString(): string
        setCurrentValue(v: boolean): boolean
        defaultValue : boolean;
        static readonly TRUE_TEXT : Internal.TextComponent;
        static readonly FALSE_TEXT : Internal.TextComponent;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : (arg0: boolean) => void;
        value : boolean;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon);
        set currentValue(v: boolean);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ProfilerMeasured {
    }
    interface IntSet extends Internal.IntCollection, Internal.Set<number> {
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        remove(arg0: number): boolean
        remove(arg0: any): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<any>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(): number[]
        toIntArray(arg0: number[]): number[]
        toArray(arg0: number[]): number[]
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: any): boolean
        add(arg0: number): boolean
        spliterator(): Internal.IntSpliterator
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: (arg0: any) => void): void
        containsAll(arg0: Internal.IntCollection): boolean
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: any) => boolean): boolean
        removeIf(arg0: java_.util.function_.IntPredicate): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        contains(arg0: any): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        equals(arg0: any): boolean
        retainAll(arg0: Internal.IntCollection): boolean
        retainAll(arg0: Internal.Collection<any>): boolean
        intParallelStream(): Internal.IntStream
    }
    abstract class IdScriptableObject extends Internal.ScriptableObject implements Internal.IdFunctionCall {
        getClass(): Internal.Class<any>
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: any): void
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getIds(): any[]
        getAllIds(): any[]
        put(name: string, start: Internal.Scriptable, value: any): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void
        put(index: number, start: Internal.Scriptable, value: any): void
        getDefaultValue(typeHint: Internal.Class<any>): any
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: any, attributes: number): void
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void
        hasPrototypeMap(): boolean
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        getExternalArrayLength(): any
        getAttributes(key: Internal.Symbol): number
        getAttributes(name: string): number
        getAttributes(index: number): number
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: any): any
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any
        static getPropertyIds(obj: Internal.Scriptable): any[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void
        getClassName(): string
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getTypeOf(): string
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        notifyAll(): void
        sealObject(): void
        setAttributes(name: string, attributes: number): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        delete(index: number): void
        notify(): void
        associateValue(key: any, value: any): any
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        hashCode(): number
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): any
        get(name: string, start: Internal.Scriptable): any
        get(index: number, start: Internal.Scriptable): any
        get(key: any): any
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any
        static getProperty(obj: Internal.Scriptable, name: string): any
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any
        static getProperty(obj: Internal.Scriptable, index: number): any
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string
        activatePrototypeMap(maxPrototypeId: number): void
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        defineConst(name: string, start: Internal.Scriptable): void
        equals(arg0: any): boolean
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        toString(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2IntMap$FastEntrySet extends Internal.ObjectSet<Internal.Int2IntMap$Entry> {
        add(arg0: Internal.Int2IntMap$Entry): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<Internal.Int2IntMap$Entry>
        forEach(arg0: (arg0: Internal.Int2IntMap$Entry) => void): void
        containsAll(arg0: Internal.Collection<any>): boolean
        isEmpty(): boolean
        clear(): void
        fastIterator(): Internal.ObjectIterator<Internal.Int2IntMap$Entry>
        remove(arg0: any): boolean
        removeIf(arg0: (arg0: Internal.Int2IntMap$Entry) => boolean): boolean
        fastForEach(arg0: (arg0: Internal.Int2IntMap$Entry) => void): void
        removeAll(arg0: Internal.Collection<any>): boolean
        contains(arg0: any): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<Internal.Int2IntMap$Entry>
        size(): number
        addAll(arg0: Internal.Collection<Internal.Int2IntMap$Entry>): boolean
        stream(): Internal.Stream<Internal.Int2IntMap$Entry>
        hashCode(): number
        equals(arg0: any): boolean
        toArray<T_>(arg0: T_[]): T_[]
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[]
        toArray(): any[]
        parallelStream(): Internal.Stream<Internal.Int2IntMap$Entry>
        retainAll(arg0: Internal.Collection<any>): boolean
    }
    interface INBTSerializable <T> {
        serializeNBT(): T
        deserializeNBT(arg0: T): void
    }
    class EntityDataAccessor <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICitadelDataEntity {
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        getCitadelEntityData(): Internal.CompoundTag
    }
    abstract class ReentrantBlockableEventLoop <R> extends Internal.BlockableEventLoop<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        close(): void
        execute(arg0: Internal.Runnable): void
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeWrapperFactory <T> {
        wrap(arg0: any): T
    }
    interface DragSourceListener extends Internal.EventListener {
        dragEnter(arg0: Internal.DragSourceDragEvent): void
        dragDropEnd(arg0: Internal.DragSourceDropEvent): void
        dropActionChanged(arg0: Internal.DragSourceDragEvent): void
        dragOver(arg0: Internal.DragSourceDragEvent): void
        dragExit(arg0: Internal.DragSourceEvent): void
    }
    interface Function7 <T1, T2, T3, T4, T5, T6, T7, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7): R
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6, arg1: T7) => R>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function4<T4, T5, T6, T7, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function3<T5, T6, T7, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function5<T3, T4, T5, T6, T7, R>
        curry(): (arg0: T1) => Internal.Function6<T2, T3, T4, T5, T6, T7, R>
    }
    class MenuBar extends Internal.MenuComponent implements Internal.MenuContainer, Internal.Accessible {
        setName(arg0: string): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        notifyAll(): void
        shortcuts(): Internal.Enumeration<Internal.MenuShortcut>
        notify(): void
        remove(arg0: Internal.MenuComponent): void
        remove(arg0: number): void
        getShortcutMenuItem(arg0: Internal.MenuShortcut): Internal.MenuItem
        hashCode(): number
        getMenu(arg0: number): Internal.Menu
        getMenuCount(): number
        setFont(arg0: java_.awt.Font): void
        add(arg0: Internal.Menu): Internal.Menu
        getParent(): Internal.MenuContainer
        dispatchEvent(arg0: Internal.AWTEvent): void
        deleteShortcut(arg0: Internal.MenuShortcut): void
        getAccessibleContext(): Internal.AccessibleContext
        countMenus(): number
        postEvent(arg0: Internal.Event): boolean
        getHelpMenu(): Internal.Menu
        addNotify(): void
        equals(arg0: any): boolean
        removeNotify(): void
        toString(): string
        getFont(): java_.awt.Font
        setHelpMenu(arg0: Internal.Menu): void
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get menuCount(): number;
        get name(): string;
        get helpMenu(): Internal.Menu;
        get class(): Internal.Class<any>;
        get font(): java_.awt.Font;
        set name(arg0: string);
        set helpMenu(arg0: Internal.Menu);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessorSoundType {
        botania_getBreakSound(): Internal.SoundEvent
    }
    interface Long2ObjectMap <V> extends Internal.Long2ObjectFunction<V>, Internal.Map<number, V> {
        long2ObjectEntrySet(): Internal.ObjectSet<Internal.Long2ObjectMap$Entry<V>>
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: any, arg1: V): V
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): V
        computeIfAbsent(arg0: number, arg1: Internal.LongFunction<V>): V
        computeIfAbsent(arg0: number, arg1: (arg0: number) => V): V
        values(): Internal.Collection<any>
        values(): Internal.ObjectCollection<V>
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        replace(arg0: number, arg1: V): V
        replace(arg0: number, arg1: V, arg2: V): boolean
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): V
        replaceAll(arg0: (arg0: number, arg1: V) => V): void
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any
        containsValue(arg0: any): boolean
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        put(arg0: any, arg1: any): any
        put(arg0: number, arg1: V): V
        put(arg0: number, arg1: V): V
        remove(arg0: number, arg1: any): boolean
        remove(arg0: any): V
        remove(arg0: number): V
        remove(arg0: any, arg1: any): boolean
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        compute(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        hashCode(): number
        putAll(arg0: Internal.Map<number, V>): void
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        merge(arg0: number, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: any): V
        get(arg0: number): V
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any
        keySet(): Internal.Set<any>
        keySet(): Internal.LongSet
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any
        apply(arg0: number): V
        apply(arg0: number): V
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>
        containsKey(arg0: any): boolean
        containsKey(arg0: number): boolean
        forEach(arg0: (arg0: number, arg1: V) => void): void
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: V) => V): V
        size(): number
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V
        equals(arg0: any): boolean
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any
        putIfAbsent(arg0: number, arg1: V): V
        putIfAbsent(arg0: number, arg1: V): V
    }
    interface MatrixWrite {
        flywheel$writeUnsafe(arg0: number): void
        flywheel$write(arg0: Internal.VecBuffer): void
    }
}
declare namespace corgitaco.enhancedcelestials.mixin.access {
    interface ChunkAccess {
        getLevel(): net.minecraft.world.level.Level
    }
}
declare namespace java_.util.function_ {
    interface IntPredicate {
        or(arg0: java_.util.function_.IntPredicate): java_.util.function_.IntPredicate
        test(arg0: number): boolean
        and(arg0: java_.util.function_.IntPredicate): java_.util.function_.IntPredicate
        negate(): java_.util.function_.IntPredicate
    }
    interface Function <T, R> {
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        apply(arg0: T): R
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
    }
    interface LongPredicate {
        or(arg0: java_.util.function_.LongPredicate): java_.util.function_.LongPredicate
        test(arg0: number): boolean
        and(arg0: java_.util.function_.LongPredicate): java_.util.function_.LongPredicate
        negate(): java_.util.function_.LongPredicate
    }
    interface IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        accept(arg0: number): void
    }
    interface IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number
    }
}
declare namespace net.blay09.mods.balm.mixin {
    interface AbstractContainerScreenAccessor {
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean
        getHoveredSlot(): Internal.Slot
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void
        getImageWidth(): number
        getLeftPos(): number
        getTopPos(): number
        getImageHeight(): number
    }
}
declare namespace net.minecraft.world.level {
    abstract class Level extends Internal.CapabilityProvider<any> implements Internal.LevelAccessor, Internal.AutoCloseable, Internal.IForgeLevel, Internal.EnhancedCelestialsWorldData, Internal.IBlockEntityLevel, Internal.LevelKJS {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>
        notifyAll(): void
        redirect$bnp000$getRedstonePowerAsCallFromNeighbours(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction): number
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void
        notify(): void
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void
        handler$bnp000$updateComparatorOutputLevel(arg0: BlockPos, arg1: Internal.Block, arg2: Internal.CallbackInfo): void
        invalidateCaps(): void
        getLunarContext(): Internal.LunarContext
        hashCode(): number
        increaseMaxEntityRadius(arg0: number): number
        handler$zom000$addFreshBlockEntities_HammerLib(arg0: Internal.Collection<any>, arg1: Internal.CallbackInfo): void
        close(): void
        unloadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean
        handler$zom000$tickBlockEntities_HammerLib(arg0: Internal.CallbackInfo): void
        loadBlockEntity_HammerLib(arg0: Internal.BlockEntity): void
        getMaxEntityRadius(): number
        asKJS(): any
        reviveCaps(): void
        getLoadedBlockEntities_HammerLib(): Internal.List<any>
        equals(arg0: any): boolean
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
        toString(): string
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext
        redirect$bbn000$redirectTick(blockEntity: Internal.TickingBlockEntity): void
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        get loadedBlockEntities_HammerLib(): Internal.List<any>;
        set lunarContext(arg0: Internal.LunarContext);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace vazkii.botania.mixin.client {
    interface AccessorMinecraft {
        getItemColors(): Internal.ItemColors
    }
}
declare namespace java_.awt {
    class Font implements Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getName(): string
        getMaxCharBounds(arg0: Internal.FontRenderContext): Internal.Rectangle2D
        isTransformed(): boolean
        isPlain(): boolean
        notifyAll(): void
        getMissingGlyphCode(): number
        static decode(arg0: string): java_.awt.Font
        notify(): void
        isItalic(): boolean
        getFontName(): string
        getFontName(arg0: Internal.Locale): string
        getStyle(): number
        hashCode(): number
        getAvailableAttributes(): Internal.AttributedCharacterIterator$Attribute[]
        getBaselineFor(arg0: string): number
        getLineMetrics(arg0: string, arg1: Internal.FontRenderContext): Internal.LineMetrics
        getLineMetrics(arg0: string, arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.LineMetrics
        getLineMetrics(arg0: string[], arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.LineMetrics
        getLineMetrics(arg0: Internal.CharacterIterator, arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.LineMetrics
        static createFonts(arg0: Internal.InputStream): java_.awt.Font[]
        static createFonts(arg0: Internal.File): java_.awt.Font[]
        getSize2D(): number
        hasUniformLineMetrics(): boolean
        getTransform(): Internal.AffineTransform
        getStringBounds(arg0: string[], arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.Rectangle2D
        getStringBounds(arg0: string, arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.Rectangle2D
        getStringBounds(arg0: string, arg1: Internal.FontRenderContext): Internal.Rectangle2D
        getStringBounds(arg0: Internal.CharacterIterator, arg1: number, arg2: number, arg3: Internal.FontRenderContext): Internal.Rectangle2D
        canDisplay(arg0: string): boolean
        canDisplay(arg0: number): boolean
        getAttributes(): Internal.Map<Internal.TextAttribute, any>
        deriveFont(arg0: Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>): java_.awt.Font
        deriveFont(arg0: number, arg1: number): java_.awt.Font
        deriveFont(arg0: number): java_.awt.Font
        deriveFont(arg0: Internal.AffineTransform): java_.awt.Font
        deriveFont(arg0: number, arg1: Internal.AffineTransform): java_.awt.Font
        deriveFont(arg0: number): java_.awt.Font
        getPSName(): string
        hasLayoutAttributes(): boolean
        isBold(): boolean
        getNumGlyphs(): number
        canDisplayUpTo(arg0: Internal.CharacterIterator, arg1: number, arg2: number): number
        canDisplayUpTo(arg0: string): number
        canDisplayUpTo(arg0: string[], arg1: number, arg2: number): number
        getItalicAngle(): number
        getSize(): number
        createGlyphVector(arg0: Internal.FontRenderContext, arg1: number[]): Internal.GlyphVector
        createGlyphVector(arg0: Internal.FontRenderContext, arg1: string): Internal.GlyphVector
        createGlyphVector(arg0: Internal.FontRenderContext, arg1: string[]): Internal.GlyphVector
        createGlyphVector(arg0: Internal.FontRenderContext, arg1: Internal.CharacterIterator): Internal.GlyphVector
        getFamily(arg0: Internal.Locale): string
        getFamily(): string
        static textRequiresLayout(arg0: string[], arg1: number, arg2: number): boolean
        equals(arg0: any): boolean
        toString(): string
        static getFont(arg0: string, arg1: java_.awt.Font): java_.awt.Font
        static getFont(arg0: string): java_.awt.Font
        static getFont(arg0: Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>): java_.awt.Font
        static createFont(arg0: number, arg1: Internal.InputStream): java_.awt.Font
        static createFont(arg0: number, arg1: Internal.File): java_.awt.Font
        layoutGlyphVector(arg0: Internal.FontRenderContext, arg1: string[], arg2: number, arg3: number, arg4: number): Internal.GlyphVector
        static readonly PLAIN : 0;
        static readonly ITALIC : 2;
        static readonly CENTER_BASELINE : 1;
        static readonly HANGING_BASELINE : 2;
        static readonly DIALOG : "Dialog";
        static readonly MONOSPACED : "Monospaced";
        static readonly DIALOG_INPUT : "DialogInput";
        static readonly LAYOUT_NO_LIMIT_CONTEXT : 4;
        static readonly LAYOUT_RIGHT_TO_LEFT : 1;
        static readonly SANS_SERIF : "SansSerif";
        static readonly SERIF : "Serif";
        static readonly TRUETYPE_FONT : 0;
        static readonly ROMAN_BASELINE : 0;
        static readonly LAYOUT_NO_START_CONTEXT : 2;
        static readonly LAYOUT_LEFT_TO_RIGHT : 0;
        static readonly BOLD : 1;
        static readonly TYPE1_FONT : 1;
        get italicAngle(): number;
        get numGlyphs(): number;
        get bold(): boolean;
        get availableAttributes(): Internal.AttributedCharacterIterator$Attribute[];
        get italic(): boolean;
        get size2D(): number;
        get fontName(): string;
        get transform(): Internal.AffineTransform;
        get size(): number;
        get plain(): boolean;
        get name(): string;
        get transformed(): boolean;
        get missingGlyphCode(): number;
        get style(): number;
        get attributes(): Internal.Map<Internal.TextAttribute, any>;
        get pSName(): string;
        get family(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Color implements Internal.Paint, Internal.Serializable {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        static decode(arg0: string): java_.awt.Color
        createContext(arg0: Internal.ColorModel, arg1: Internal.Rectangle, arg2: Internal.Rectangle2D, arg3: Internal.AffineTransform, arg4: Internal.RenderingHints): Internal.PaintContext
        notify(): void
        getAlpha(): number
        getColorComponents(arg0: number[]): number[]
        getColorComponents(arg0: Internal.ColorSpace, arg1: number[]): number[]
        darker(): java_.awt.Color
        getRed(): number
        getRGBComponents(arg0: number[]): number[]
        hashCode(): number
        getComponents(arg0: Internal.ColorSpace, arg1: number[]): number[]
        getComponents(arg0: number[]): number[]
        static RGBtoHSB(arg0: number, arg1: number, arg2: number, arg3: number[]): number[]
        getRGB(): number
        static getHSBColor(arg0: number, arg1: number, arg2: number): java_.awt.Color
        brighter(): java_.awt.Color
        static getColor(arg0: string, arg1: number): java_.awt.Color
        static getColor(arg0: string, arg1: java_.awt.Color): java_.awt.Color
        static getColor(arg0: string): java_.awt.Color
        static HSBtoRGB(arg0: number, arg1: number, arg2: number): number
        getColorSpace(): Internal.ColorSpace
        getBlue(): number
        getRGBColorComponents(arg0: number[]): number[]
        getTransparency(): number
        getGreen(): number
        equals(arg0: any): boolean
        toString(): string
        static readonly lightGray : java_.awt.Color;
        static readonly magenta : java_.awt.Color;
        static readonly GRAY : java_.awt.Color;
        static readonly pink : java_.awt.Color;
        static readonly BLUE : java_.awt.Color;
        static readonly yellow : java_.awt.Color;
        static readonly cyan : java_.awt.Color;
        static readonly red : java_.awt.Color;
        static readonly gray : java_.awt.Color;
        static readonly PINK : java_.awt.Color;
        static readonly white : java_.awt.Color;
        static readonly TRANSLUCENT : 3;
        static readonly BLACK : java_.awt.Color;
        static readonly ORANGE : java_.awt.Color;
        static readonly WHITE : java_.awt.Color;
        static readonly green : java_.awt.Color;
        static readonly black : java_.awt.Color;
        static readonly BITMASK : 2;
        static readonly GREEN : java_.awt.Color;
        static readonly RED : java_.awt.Color;
        static readonly orange : java_.awt.Color;
        static readonly LIGHT_GRAY : java_.awt.Color;
        static readonly blue : java_.awt.Color;
        static readonly OPAQUE : 1;
        static readonly darkGray : java_.awt.Color;
        static readonly MAGENTA : java_.awt.Color;
        static readonly YELLOW : java_.awt.Color;
        static readonly DARK_GRAY : java_.awt.Color;
        static readonly CYAN : java_.awt.Color;
        get colorSpace(): Internal.ColorSpace;
        get alpha(): number;
        get transparency(): number;
        get rGB(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Container extends java_.awt.Component {
        getLocation(arg0: Internal.Point): Internal.Point
        getLocation(): Internal.Point
        requestFocusInWindow(): boolean
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause): boolean
        isOpaque(): boolean
        paint(arg0: Internal.Graphics): void
        getInputMethodListeners(): Internal.InputMethodListener[]
        setLayout(arg0: Internal.LayoutManager): void
        mouseDown(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getInputMethodRequests(): Internal.InputMethodRequests
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        removeAll(): void
        getMinimumSize(): Internal.Dimension
        getAlignmentY(): number
        getAlignmentX(): number
        dispatchEvent(arg0: Internal.AWTEvent): void
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void
        postEvent(arg0: Internal.Event): boolean
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point): boolean
        size(): Internal.Dimension
        enableInputMethods(arg0: boolean): void
        mouseUp(arg0: Internal.Event, arg1: number, arg2: number): boolean
        removeContainerListener(arg0: Internal.ContainerListener): void
        addComponentListener(arg0: Internal.ComponentListener): void
        setName(arg0: string): void
        removeInputMethodListener(arg0: Internal.InputMethodListener): void
        removeHierarchyListener(arg0: Internal.HierarchyListener): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getHeight(): number
        getIgnoreRepaint(): boolean
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior
        removeMouseWheelListener(arg0: Internal.MouseWheelListener): void
        applyComponentOrientation(arg0: Internal.ComponentOrientation): void
        validate(): void
        getParent(): java_.awt.Container
        isMinimumSizeSet(): boolean
        setComponentOrientation(arg0: Internal.ComponentOrientation): void
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void
        setBounds(arg0: Internal.Rectangle): void
        isValidateRoot(): boolean
        addNotify(): void
        addInputMethodListener(arg0: Internal.InputMethodListener): void
        toString(): string
        getFocusCycleRootAncestor(): java_.awt.Container
        setFocusTraversalPolicyProvider(arg0: boolean): void
        getName(): string
        countComponents(): number
        isFocusTraversable(): boolean
        inside(arg0: number, arg1: number): boolean
        nextFocus(): void
        getInputContext(): Internal.InputContext
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>
        isCursorSet(): boolean
        getMouseWheelListeners(): Internal.MouseWheelListener[]
        getComponents(): java_.awt.Component[]
        removeMouseMotionListener(arg0: Internal.MouseMotionListener): void
        doLayout(): void
        setVisible(arg0: boolean): void
        add(arg0: java_.awt.Component, arg1: number): java_.awt.Component
        add(arg0: string, arg1: java_.awt.Component): java_.awt.Component
        add(arg0: java_.awt.Component, arg1: any): void
        add(arg0: java_.awt.Component, arg1: any, arg2: number): void
        add(arg0: java_.awt.Component): java_.awt.Component
        add(arg0: Internal.PopupMenu): void
        removeKeyListener(arg0: Internal.KeyListener): void
        setFocusCycleRoot(arg0: boolean): void
        isVisible(): boolean
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        setDropTarget(arg0: Internal.DropTarget): void
        list(arg0: Internal.PrintStream, arg1: number): void
        list(arg0: Internal.PrintWriter, arg1: number): void
        list(arg0: Internal.PrintStream): void
        list(): void
        list(arg0: Internal.PrintWriter): void
        revalidate(): void
        removeNotify(): void
        gotFocus(arg0: Internal.Event, arg1: any): boolean
        handleEvent(arg0: Internal.Event): boolean
        notifyAll(): void
        isForegroundSet(): boolean
        show(): void
        show(arg0: boolean): void
        update(arg0: Internal.Graphics): void
        isFocusTraversalPolicySet(): boolean
        setMaximumSize(arg0: Internal.Dimension): void
        remove(arg0: number): void
        remove(arg0: java_.awt.Component): void
        remove(arg0: Internal.MenuComponent): void
        addMouseWheelListener(arg0: Internal.MouseWheelListener): void
        imageUpdate(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        checkImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): number
        checkImage(arg0: Internal.Image, arg1: Internal.ImageObserver): number
        getLayout(): Internal.LayoutManager
        addKeyListener(arg0: Internal.KeyListener): void
        getContainerListeners(): Internal.ContainerListener[]
        hashCode(): number
        getComponentListeners(): Internal.ComponentListener[]
        isMaximumSizeSet(): boolean
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        getCursor(): Internal.Cursor
        createImage(arg0: number, arg1: number): Internal.Image
        createImage(arg0: Internal.ImageProducer): Internal.Image
        mouseMove(arg0: Internal.Event, arg1: number, arg2: number): boolean
        areFocusTraversalKeysSet(arg0: number): boolean
        getKeyListeners(): Internal.KeyListener[]
        layout(): void
        getBaseline(arg0: number, arg1: number): number
        print(arg0: Internal.Graphics): void
        paintComponents(arg0: Internal.Graphics): void
        getFocusListeners(): Internal.FocusListener[]
        resize(arg0: number, arg1: number): void
        resize(arg0: Internal.Dimension): void
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities): Internal.VolatileImage
        location(): Internal.Point
        lostFocus(arg0: Internal.Event, arg1: any): boolean
        getDropTarget(): Internal.DropTarget
        keyDown(arg0: Internal.Event, arg1: number): boolean
        getLocale(): Internal.Locale
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[]
        getBounds(arg0: Internal.Rectangle): Internal.Rectangle
        getBounds(): Internal.Rectangle
        setPreferredSize(arg0: Internal.Dimension): void
        enable(): void
        enable(arg0: boolean): void
        getMousePosition(arg0: boolean): Internal.Point
        getMousePosition(): Internal.Point
        action(arg0: Internal.Event, arg1: any): boolean
        addContainerListener(arg0: Internal.ContainerListener): void
        setComponentZOrder(arg0: java_.awt.Component, arg1: number): void
        firePropertyChange(arg0: string, arg1: string, arg2: string): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        addMouseMotionListener(arg0: Internal.MouseMotionListener): void
        getComponentOrientation(): Internal.ComponentOrientation
        setFocusable(arg0: boolean): void
        getTreeLock(): any
        isBackgroundSet(): boolean
        addHierarchyListener(arg0: Internal.HierarchyListener): void
        findComponentAt(arg0: number, arg1: number): java_.awt.Component
        findComponentAt(arg0: Internal.Point): java_.awt.Component
        setEnabled(arg0: boolean): void
        isLightweight(): boolean
        isEnabled(): boolean
        minimumSize(): Internal.Dimension
        bounds(): Internal.Rectangle
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void
        repaint(): void
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void
        repaint(arg0: number): void
        getMouseMotionListeners(): Internal.MouseMotionListener[]
        setMinimumSize(arg0: Internal.Dimension): void
        transferFocus(): void
        printComponents(arg0: Internal.Graphics): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaximumSize(): Internal.Dimension
        getLocationOnScreen(): Internal.Point
        keyUp(arg0: Internal.Event, arg1: number): boolean
        getWidth(): number
        notify(): void
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy): void
        paintAll(arg0: Internal.Graphics): void
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set<Internal.AWTKeyStroke>): void
        hasFocus(): boolean
        isPreferredSizeSet(): boolean
        isDoubleBuffered(): boolean
        getPropertyChangeListeners(): Internal.PropertyChangeListener[]
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[]
        getColorModel(): Internal.ColorModel
        isValid(): boolean
        getInsets(): Internal.Insets
        getFocusTraversalKeysEnabled(): boolean
        hide(): void
        getPreferredSize(): Internal.Dimension
        disable(): void
        equals(arg0: any): boolean
        prepareImage(arg0: Internal.Image, arg1: Internal.ImageObserver): boolean
        prepareImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        isFocusable(): boolean
        getClass(): Internal.Class<any>
        insets(): Internal.Insets
        setMixingCutoutShape(arg0: Internal.Shape): void
        mouseExit(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getHierarchyListeners(): Internal.HierarchyListener[]
        isShowing(): boolean
        mouseEnter(arg0: Internal.Event, arg1: number, arg2: number): boolean
        mouseDrag(arg0: Internal.Event, arg1: number, arg2: number): boolean
        preferredSize(): Internal.Dimension
        getMouseListeners(): Internal.MouseListener[]
        setFont(arg0: java_.awt.Font): void
        deliverEvent(arg0: Internal.Event): void
        getForeground(): java_.awt.Color
        getComponentCount(): number
        isAncestorOf(arg0: java_.awt.Component): boolean
        setCursor(arg0: Internal.Cursor): void
        getFont(): java_.awt.Font
        getGraphicsConfiguration(): Internal.GraphicsConfiguration
        isDisplayable(): boolean
        getComponent(arg0: number): java_.awt.Component
        setLocale(arg0: Internal.Locale): void
        removeComponentListener(arg0: Internal.ComponentListener): void
        requestFocus(arg0: Internal.FocusEvent$Cause): void
        requestFocus(): void
        locate(arg0: number, arg1: number): java_.awt.Component
        addFocusListener(arg0: Internal.FocusListener): void
        getComponentAt(arg0: Internal.Point): java_.awt.Component
        getComponentAt(arg0: number, arg1: number): java_.awt.Component
        isFocusCycleRoot(): boolean
        isFocusCycleRoot(arg0: java_.awt.Container): boolean
        setFocusTraversalKeysEnabled(arg0: boolean): void
        getComponentZOrder(arg0: java_.awt.Component): number
        setBackground(arg0: java_.awt.Color): void
        printAll(arg0: Internal.Graphics): void
        getToolkit(): Internal.Toolkit
        transferFocusUpCycle(): void
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        isFontSet(): boolean
        setLocation(arg0: Internal.Point): void
        setLocation(arg0: number, arg1: number): void
        isFocusTraversalPolicyProvider(): boolean
        getGraphics(): Internal.Graphics
        removeFocusListener(arg0: Internal.FocusListener): void
        setIgnoreRepaint(arg0: boolean): void
        transferFocusBackward(): void
        move(arg0: number, arg1: number): void
        transferFocusDownCycle(): void
        setForeground(arg0: java_.awt.Color): void
        invalidate(): void
        getAccessibleContext(): Internal.AccessibleContext
        isFocusOwner(): boolean
        getSize(): Internal.Dimension
        getSize(arg0: Internal.Dimension): Internal.Dimension
        getX(): number
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        getY(): number
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy
        removeMouseListener(arg0: Internal.MouseListener): void
        getBackground(): java_.awt.Color
        addMouseListener(arg0: Internal.MouseListener): void
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): java_.awt.Container;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get visible(): boolean;
        get displayable(): boolean;
        get maximumSizeSet(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): boolean;
        get componentCount(): number;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): java_.awt.Container;
        get focusCycleRoot(): boolean;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get containerListeners(): Internal.ContainerListener[];
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get colorModel(): Internal.ColorModel;
        get class(): Internal.Class<any>;
        get keyListeners(): Internal.KeyListener[];
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get validateRoot(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): java_.awt.Font;
        set cursor(arg0: Internal.Cursor);
        set visible(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation);
        set dropTarget(arg0: Internal.DropTarget);
        set focusable(arg0: boolean);
        set foreground(arg0: java_.awt.Color);
        set locale(arg0: Internal.Locale);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy);
        set background(arg0: java_.awt.Color);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Component implements Internal.ImageObserver, Internal.MenuContainer, Internal.Serializable {
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[]
        getLocation(arg0: Internal.Point): Internal.Point
        getLocation(): Internal.Point
        requestFocusInWindow(): boolean
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause): boolean
        isOpaque(): boolean
        paint(arg0: Internal.Graphics): void
        getInputMethodListeners(): Internal.InputMethodListener[]
        mouseDown(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getInputMethodRequests(): Internal.InputMethodRequests
        getBounds(arg0: Internal.Rectangle): Internal.Rectangle
        getBounds(): Internal.Rectangle
        setPreferredSize(arg0: Internal.Dimension): void
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        enable(): void
        enable(arg0: boolean): void
        getMinimumSize(): Internal.Dimension
        getMousePosition(): Internal.Point
        action(arg0: Internal.Event, arg1: any): boolean
        getAlignmentY(): number
        getAlignmentX(): number
        firePropertyChange(arg0: string, arg1: string, arg2: string): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        firePropertyChange(arg0: string, arg1: number, arg2: number): void
        dispatchEvent(arg0: Internal.AWTEvent): void
        addMouseMotionListener(arg0: Internal.MouseMotionListener): void
        getComponentOrientation(): Internal.ComponentOrientation
        setFocusable(arg0: boolean): void
        getTreeLock(): any
        isBackgroundSet(): boolean
        addHierarchyListener(arg0: Internal.HierarchyListener): void
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void
        postEvent(arg0: Internal.Event): boolean
        setEnabled(arg0: boolean): void
        contains(arg0: number, arg1: number): boolean
        contains(arg0: Internal.Point): boolean
        isLightweight(): boolean
        size(): Internal.Dimension
        enableInputMethods(arg0: boolean): void
        mouseUp(arg0: Internal.Event, arg1: number, arg2: number): boolean
        minimumSize(): Internal.Dimension
        isEnabled(): boolean
        bounds(): Internal.Rectangle
        addComponentListener(arg0: Internal.ComponentListener): void
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void
        repaint(): void
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void
        repaint(arg0: number): void
        getMouseMotionListeners(): Internal.MouseMotionListener[]
        setMinimumSize(arg0: Internal.Dimension): void
        transferFocus(): void
        setName(arg0: string): void
        getListeners<T_>(arg0: Internal.Class<T_>): T_[]
        removeInputMethodListener(arg0: Internal.InputMethodListener): void
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getMaximumSize(): Internal.Dimension
        removeHierarchyListener(arg0: Internal.HierarchyListener): void
        getLocationOnScreen(): Internal.Point
        keyUp(arg0: Internal.Event, arg1: number): boolean
        getWidth(): number
        notify(): void
        getFontMetrics(arg0: java_.awt.Font): Internal.FontMetrics
        getHeight(): number
        paintAll(arg0: Internal.Graphics): void
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set<Internal.AWTKeyStroke>): void
        getIgnoreRepaint(): boolean
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior
        removeMouseWheelListener(arg0: Internal.MouseWheelListener): void
        hasFocus(): boolean
        applyComponentOrientation(arg0: Internal.ComponentOrientation): void
        isPreferredSizeSet(): boolean
        validate(): void
        getParent(): java_.awt.Container
        isDoubleBuffered(): boolean
        isMinimumSizeSet(): boolean
        getPropertyChangeListeners(): Internal.PropertyChangeListener[]
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[]
        getColorModel(): Internal.ColorModel
        setComponentOrientation(arg0: Internal.ComponentOrientation): void
        isValid(): boolean
        getFocusTraversalKeysEnabled(): boolean
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void
        setBounds(arg0: Internal.Rectangle): void
        hide(): void
        getPreferredSize(): Internal.Dimension
        addNotify(): void
        disable(): void
        equals(arg0: any): boolean
        addInputMethodListener(arg0: Internal.InputMethodListener): void
        prepareImage(arg0: Internal.Image, arg1: Internal.ImageObserver): boolean
        prepareImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): boolean
        toString(): string
        getFocusCycleRootAncestor(): java_.awt.Container
        isFocusable(): boolean
        getClass(): Internal.Class<any>
        getName(): string
        isFocusTraversable(): boolean
        setMixingCutoutShape(arg0: Internal.Shape): void
        inside(arg0: number, arg1: number): boolean
        nextFocus(): void
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>
        mouseExit(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getInputContext(): Internal.InputContext
        getHierarchyListeners(): Internal.HierarchyListener[]
        isCursorSet(): boolean
        isShowing(): boolean
        mouseEnter(arg0: Internal.Event, arg1: number, arg2: number): boolean
        mouseDrag(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getMouseWheelListeners(): Internal.MouseWheelListener[]
        preferredSize(): Internal.Dimension
        getMouseListeners(): Internal.MouseListener[]
        setFont(arg0: java_.awt.Font): void
        removeMouseMotionListener(arg0: Internal.MouseMotionListener): void
        doLayout(): void
        add(arg0: Internal.PopupMenu): void
        setVisible(arg0: boolean): void
        removeKeyListener(arg0: Internal.KeyListener): void
        isVisible(): boolean
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        list(arg0: Internal.PrintStream, arg1: number): void
        list(arg0: Internal.PrintStream): void
        list(): void
        list(arg0: Internal.PrintWriter): void
        list(arg0: Internal.PrintWriter, arg1: number): void
        setDropTarget(arg0: Internal.DropTarget): void
        deliverEvent(arg0: Internal.Event): void
        getForeground(): java_.awt.Color
        revalidate(): void
        removeNotify(): void
        setCursor(arg0: Internal.Cursor): void
        getFont(): java_.awt.Font
        getGraphicsConfiguration(): Internal.GraphicsConfiguration
        isDisplayable(): boolean
        setLocale(arg0: Internal.Locale): void
        removeComponentListener(arg0: Internal.ComponentListener): void
        gotFocus(arg0: Internal.Event, arg1: any): boolean
        requestFocus(arg0: Internal.FocusEvent$Cause): void
        requestFocus(): void
        locate(arg0: number, arg1: number): java_.awt.Component
        addFocusListener(arg0: Internal.FocusListener): void
        handleEvent(arg0: Internal.Event): boolean
        notifyAll(): void
        isForegroundSet(): boolean
        getComponentAt(arg0: number, arg1: number): java_.awt.Component
        getComponentAt(arg0: Internal.Point): java_.awt.Component
        show(): void
        show(arg0: boolean): void
        update(arg0: Internal.Graphics): void
        setMaximumSize(arg0: Internal.Dimension): void
        isFocusCycleRoot(arg0: java_.awt.Container): boolean
        setFocusTraversalKeysEnabled(arg0: boolean): void
        setBackground(arg0: java_.awt.Color): void
        remove(arg0: Internal.MenuComponent): void
        printAll(arg0: Internal.Graphics): void
        addMouseWheelListener(arg0: Internal.MouseWheelListener): void
        getToolkit(): Internal.Toolkit
        imageUpdate(arg0: Internal.Image, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        transferFocusUpCycle(): void
        checkImage(arg0: Internal.Image, arg1: number, arg2: number, arg3: Internal.ImageObserver): number
        checkImage(arg0: Internal.Image, arg1: Internal.ImageObserver): number
        setSize(arg0: Internal.Dimension): void
        setSize(arg0: number, arg1: number): void
        isFontSet(): boolean
        addKeyListener(arg0: Internal.KeyListener): void
        setLocation(arg0: Internal.Point): void
        setLocation(arg0: number, arg1: number): void
        hashCode(): number
        getComponentListeners(): Internal.ComponentListener[]
        getGraphics(): Internal.Graphics
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener): void
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener): void
        isMaximumSizeSet(): boolean
        removeFocusListener(arg0: Internal.FocusListener): void
        setIgnoreRepaint(arg0: boolean): void
        transferFocusBackward(): void
        getCursor(): Internal.Cursor
        move(arg0: number, arg1: number): void
        createImage(arg0: number, arg1: number): Internal.Image
        createImage(arg0: Internal.ImageProducer): Internal.Image
        areFocusTraversalKeysSet(arg0: number): boolean
        mouseMove(arg0: Internal.Event, arg1: number, arg2: number): boolean
        getKeyListeners(): Internal.KeyListener[]
        setForeground(arg0: java_.awt.Color): void
        invalidate(): void
        getAccessibleContext(): Internal.AccessibleContext
        isFocusOwner(): boolean
        layout(): void
        getSize(): Internal.Dimension
        getSize(arg0: Internal.Dimension): Internal.Dimension
        print(arg0: Internal.Graphics): void
        getBaseline(arg0: number, arg1: number): number
        getX(): number
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener): void
        getY(): number
        getFocusListeners(): Internal.FocusListener[]
        resize(arg0: number, arg1: number): void
        resize(arg0: Internal.Dimension): void
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities): Internal.VolatileImage
        location(): Internal.Point
        lostFocus(arg0: Internal.Event, arg1: any): boolean
        removeMouseListener(arg0: Internal.MouseListener): void
        getDropTarget(): Internal.DropTarget
        keyDown(arg0: Internal.Event, arg1: number): boolean
        getBackground(): java_.awt.Color
        getLocale(): Internal.Locale
        addMouseListener(arg0: Internal.MouseListener): void
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): java_.awt.Container;
        get inputContext(): Internal.InputContext;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get dropTarget(): Internal.DropTarget;
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get visible(): boolean;
        get displayable(): boolean;
        get focusable(): boolean;
        get maximumSizeSet(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): boolean;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): java_.awt.Container;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get maximumSize(): Internal.Dimension;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get locationOnScreen(): Internal.Point;
        get colorModel(): Internal.ColorModel;
        get cursorSet(): boolean;
        get class(): Internal.Class<any>;
        get keyListeners(): Internal.KeyListener[];
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get backgroundSet(): boolean;
        get focusListeners(): Internal.FocusListener[];
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): java_.awt.Font;
        set cursor(arg0: Internal.Cursor);
        set visible(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation);
        set dropTarget(arg0: Internal.DropTarget);
        set focusable(arg0: boolean);
        set foreground(arg0: java_.awt.Color);
        set locale(arg0: Internal.Locale);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape);
        set background(arg0: java_.awt.Color);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension);
        set font(arg0: java_.awt.Font);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace org.apache.logging.log4j.util {
    interface Supplier <T> {
        get(): T
    }
}
declare namespace org.apache.logging.log4j.message {
    interface Message extends Internal.Serializable {
        getParameters(): any[]
        getFormattedMessage(): string
        getFormat(): string
        getThrowable(): Internal.Throwable
    }
}
declare namespace io.netty.channel {
    interface Channel extends Internal.AttributeMap, Internal.ChannelOutboundInvoker, Internal.Comparable<io.netty.channel.Channel> {
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        disconnect(): Internal.ChannelFuture
        parent(): io.netty.channel.Channel
        metadata(): Internal.ChannelMetadata
        newProgressivePromise(): Internal.ChannelProgressivePromise
        eventLoop(): Internal.EventLoop
        compareTo(arg0: io.netty.channel.Channel): number
        isWritable(): boolean
        isActive(): boolean
        unsafe(): Internal.Channel$Unsafe
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        writeAndFlush(arg0: any): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        flush(): io.netty.channel.Channel
        flush(): Internal.ChannelOutboundInvoker
        bytesBeforeWritable(): number
        id(): Internal.ChannelId
        attr<T_>(arg0: Internal.AttributeKey<T_>): Internal.Attribute<T_>
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: any): Internal.ChannelFuture
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        remoteAddress(): Internal.SocketAddress
        newPromise(): Internal.ChannelPromise
        read(): io.netty.channel.Channel
        read(): Internal.ChannelOutboundInvoker
        bytesBeforeUnwritable(): number
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        hasAttr<T_>(arg0: Internal.AttributeKey<T_>): boolean
        pipeline(): Internal.ChannelPipeline
        isOpen(): boolean
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        closeFuture(): Internal.ChannelFuture
        localAddress(): Internal.SocketAddress
        isRegistered(): boolean
        alloc(): Internal.ByteBufAllocator
        config(): Internal.ChannelConfig
    }
}
declare namespace de.teamlapen.vampirism.mixin {
    interface LivingEntityAccessor {
        invokeGetExperiencePoints_vampirism(arg0: Internal.Player): number
    }
}
declare namespace net.minecraft.world.entity.ai.attributes {
    class Attribute extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        getRegistryType(): Internal.Class<net.minecraft.world.entity.ai.attributes.Attribute>
        getRegistryName(): ResourceLocation
        toString(): string
        setRegistryName(arg0: ResourceLocation): any
        setRegistryName(arg0: ResourceLocation): net.minecraft.world.entity.ai.attributes.Attribute
        setRegistryName(arg0: string): net.minecraft.world.entity.ai.attributes.Attribute
        setRegistryName(arg0: string, arg1: string): net.minecraft.world.entity.ai.attributes.Attribute
        notify(): void
        readonly delegate : () => net.minecraft.world.entity.ai.attributes.Attribute;
        get registryType(): Internal.Class<net.minecraft.world.entity.ai.attributes.Attribute>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace com.mojang.datafixers.util {
    class Unit extends Internal.Enum<any> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        static valueOf(arg0: string): com.mojang.datafixers.util.Unit
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_
        notifyAll(): void
        static values(): com.mojang.datafixers.util.Unit[]
        compareTo(arg0: any): number
        compareTo(arg0: com.mojang.datafixers.util.Unit): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<com.mojang.datafixers.util.Unit>>
        notify(): void
        getDeclaringClass(): Internal.Class<com.mojang.datafixers.util.Unit>
        hashCode(): number
        equals(arg0: any): boolean
        name(): string
        toString(): string
        ordinal(): number
        static readonly INSTANCE : com.mojang.datafixers.util.Unit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<com.mojang.datafixers.util.Unit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Pair <F, S> implements Internal.App<Internal.Pair$Mu<S>, F> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        swap(): com.mojang.datafixers.util.Pair<S, Internal.Pair$Mu<S>>
        notifyAll(): void
        notify(): void
        mapFirst<F2_>(arg0: (arg0: Internal.Pair$Mu<S>) => F2_): com.mojang.datafixers.util.Pair<F2_, S>
        static unbox<F_, S_>(arg0: Internal.App<Internal.Pair$Mu<S_>, F_>): com.mojang.datafixers.util.Pair<F_, S_>
        getFirst(): Internal.Pair$Mu<S>
        hashCode(): number
        static toMap<F_, S_>(): Internal.Collector<com.mojang.datafixers.util.Pair<F_, S_>, any, Internal.Map<F_, S_>>
        static of<F_, S_>(arg0: F_, arg1: S_): com.mojang.datafixers.util.Pair<F_, S_>
        equals(arg0: any): boolean
        getSecond(): S
        toString(): string
        mapSecond<S2_>(arg0: (arg0: S) => S2_): com.mojang.datafixers.util.Pair<Internal.Pair$Mu<S>, S2_>
        get class(): Internal.Class<any>;
        get first(): Internal.Pair$Mu<S>;
        get second(): S;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace net.minecraft.world.level.block.state.properties {
    abstract class Property <T> {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace net.minecraft.client.resources.model {
    class Material {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace dev.ftb.mods.ftblibrary.ui {
    class Widget implements Internal.IScreenWrapper {
        static isMouseButtonDown(button: Internal.MouseButton): boolean
        closeGui(openPrevScreen: boolean): void
        closeGui(): void
        getClass(): Internal.Class<any>
        setY(v: number): void
        collidesWith(x: number, y: number, w: number, h: number): boolean
        setX(v: number): void
        shouldDraw(): boolean
        acceptGhostIngredient(ingredient: any): void
        isGhostIngredientTarget(ingredient: any): boolean
        run(): void
        getGui(): Internal.BaseScreen
        mousePressed(button: Internal.MouseButton): boolean
        setPos(x: number, y: number): void
        getTitle(): Internal.Component
        static getClipboardString(): string
        static isCtrlKeyDown(): boolean
        updateMouseOver(mouseX: number, mouseY: number): void
        getScreen(): com.mojang.blaze3d.platform.Window
        getMouseY(): number
        onClosed(): void
        isMouseOver(): boolean
        getMouseX(): number
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key): boolean
        openGui(): void
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget
        tick(): void
        setHeight(v: number): void
        addMouseOverText(list: Internal.TooltipList): void
        playClickSound(): void
        handleClick(click: string): boolean
        handleClick(scheme: string, path: string): boolean
        isEnabled(): boolean
        charTyped(c: string, modifiers: Internal.KeyModifiers): boolean
        mouseDoubleClicked(button: Internal.MouseButton): boolean
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        mouseScrolled(scroll: number): boolean
        notifyAll(): void
        shouldAddMouseOverText(): boolean
        openAfter(runnable: Internal.Runnable): Internal.Runnable
        closeContextMenu(): void
        notify(): void
        mouseReleased(button: Internal.MouseButton): void
        setSize(w: number, h: number): void
        hashCode(): number
        getPartialTicks(): number
        openGuiLater(): void
        static isKeyDown(key: number): boolean
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key): void
        static setClipboardString(string: string): void
        static isShiftKeyDown(): boolean
        getCursor(): Internal.CursorType
        getWidgetType(): Internal.WidgetType
        draw(matrixStack: Internal.PoseStack, theme: Internal.Theme, x: number, y: number, w: number, h: number): void
        checkMouseOver(mouseX: number, mouseY: number): boolean
        setWidth(v: number): void
        openContextMenu(panel: Internal.Panel): void
        getX(): number
        getY(): number
        equals(arg0: any): boolean
        toString(): string
        getIngredientUnderMouse(): any
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): com.mojang.blaze3d.platform.Window;
        get title(): Internal.Component;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get partialTicks(): number;
        set clipboardString(string: string);
        set x(v: number);
        set y(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace net.blay09.mods.kleeslabs.mixin {
    interface LevelRendererAccessor {
    }
}
declare namespace net.minecraftforge.eventbus.api {
    class Event {
        setCanceled(arg0: boolean): void
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        isCanceled(): boolean
        setResult(arg0: Internal.Event$Result): void
        notifyAll(): void
        hasResult(): boolean
        notify(): void
        getListenerList(): Internal.ListenerList
        hashCode(): number
        equals(arg0: any): boolean
        getResult(): Internal.Event$Result
        toString(): string
        isCancelable(): boolean
        getPhase(): Internal.EventPriority
        setPhase(arg0: Internal.EventPriority): void
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace dev.architectury.fluid {
    class FluidStack {
        getClass(): Internal.Class<any>
        getRawFluidSupplier(): () => Internal.Fluid
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        getRawFluid(): Internal.Fluid
        getName(): Internal.Component
        notifyAll(): void
        getOrCreateChildTag(childName: string): Internal.CompoundTag
        notify(): void
        static empty(): dev.architectury.fluid.FluidStack
        getChildTag(childName: string): Internal.CompoundTag
        hashCode(): number
        static create(stack: dev.architectury.fluid.FluidStack, amount: number): dev.architectury.fluid.FluidStack
        static create(fluid: () => Internal.Fluid, amount: number): dev.architectury.fluid.FluidStack
        static create(fluid: () => Internal.Fluid, amount: number, tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        static create(fluid: Internal.Fluid, amount: number): dev.architectury.fluid.FluidStack
        static create(fluid: Internal.Fluid, amount: number, tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        setTag(tag: Internal.CompoundTag): void
        copy(): dev.architectury.fluid.FluidStack
        setAmount(amount: number): void
        write(tag: Internal.CompoundTag): Internal.CompoundTag
        write(buf: Internal.FriendlyByteBuf): void
        getAmount(): number
        removeChildTag(childName: string): void
        grow(amount: number): void
        static read(tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        static read(buf: Internal.FriendlyByteBuf): dev.architectury.fluid.FluidStack
        hasTag(): boolean
        shrink(amount: number): void
        getTranslationKey(): string
        isEmpty(): boolean
        getTag(): Internal.CompoundTag
        isFluidStackEqual(other: dev.architectury.fluid.FluidStack): boolean
        static bucketAmount(): number
        getOrCreateTag(): Internal.CompoundTag
        equals(o: any): boolean
        getFluid(): Internal.Fluid
        toString(): string
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get rawFluidSupplier(): () => Internal.Fluid;
        get translationKey(): string;
        get name(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set amount(amount: number);
        set tag(tag: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace org.objectweb.asm {
    class Type {
        getDescriptor(): string
        static getDescriptor(arg0: Internal.Class<any>): string
        getClass(): Internal.Class<any>
        getElementType(): org.objectweb.asm.Type
        getArgumentTypes(): org.objectweb.asm.Type[]
        static getArgumentTypes(arg0: string): org.objectweb.asm.Type[]
        static getArgumentTypes(arg0: Internal.Method): org.objectweb.asm.Type[]
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        notifyAll(): void
        static getArgumentsAndReturnSizes(arg0: string): number
        getArgumentsAndReturnSizes(): number
        notify(): void
        getSort(): number
        getDimensions(): number
        getSize(): number
        static getMethodDescriptor(arg0: org.objectweb.asm.Type, arg1: org.objectweb.asm.Type[]): string
        static getMethodDescriptor(arg0: Internal.Method): string
        static getReturnType(arg0: string): org.objectweb.asm.Type
        getReturnType(): org.objectweb.asm.Type
        static getReturnType(arg0: Internal.Method): org.objectweb.asm.Type
        getInternalName(): string
        static getInternalName(arg0: Internal.Class<any>): string
        static getType(arg0: string): org.objectweb.asm.Type
        static getType(arg0: Internal.Class<any>): org.objectweb.asm.Type
        static getType(arg0: Internal.Constructor<any>): org.objectweb.asm.Type
        static getType(arg0: Internal.Method): org.objectweb.asm.Type
        hashCode(): number
        equals(arg0: any): boolean
        static getObjectType(arg0: string): org.objectweb.asm.Type
        static getConstructorDescriptor(arg0: Internal.Constructor<any>): string
        static getMethodType(arg0: string): org.objectweb.asm.Type
        static getMethodType(arg0: org.objectweb.asm.Type, arg1: org.objectweb.asm.Type[]): org.objectweb.asm.Type
        toString(): string
        getClassName(): string
        getOpcode(arg0: number): number
        static readonly CHAR_TYPE : org.objectweb.asm.Type;
        static readonly FLOAT : 6;
        static readonly DOUBLE_TYPE : org.objectweb.asm.Type;
        static readonly ARRAY : 9;
        static readonly LONG_TYPE : org.objectweb.asm.Type;
        static readonly BYTE_TYPE : org.objectweb.asm.Type;
        static readonly CHAR : 2;
        static readonly VOID_TYPE : org.objectweb.asm.Type;
        static readonly OBJECT : 10;
        static readonly BOOLEAN_TYPE : org.objectweb.asm.Type;
        static readonly FLOAT_TYPE : org.objectweb.asm.Type;
        static readonly BOOLEAN : 1;
        static readonly INT : 5;
        static readonly SHORT : 4;
        static readonly BYTE : 3;
        static readonly METHOD : 11;
        static readonly SHORT_TYPE : org.objectweb.asm.Type;
        static readonly DOUBLE : 8;
        static readonly VOID : 0;
        static readonly LONG : 7;
        static readonly INT_TYPE : org.objectweb.asm.Type;
        get argumentsAndReturnSizes(): number;
        get internalName(): string;
        get size(): number;
        get className(): string;
        get descriptor(): string;
        get argumentTypes(): org.objectweb.asm.Type[];
        get sort(): number;
        get class(): Internal.Class<any>;
        get elementType(): org.objectweb.asm.Type;
        get returnType(): org.objectweb.asm.Type;
        get dimensions(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace dev.ftb.mods.ftblibrary.ui.input {
    class Key {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        deselectAll(): boolean
        cut(): boolean
        notifyAll(): void
        is(k: number): boolean
        paste(): boolean
        notify(): void
        selectAll(): boolean
        getInputMapping(): Internal.InputConstants$Key
        backspace(): boolean
        esc(): boolean
        hashCode(): number
        equals(arg0: any): boolean
        toString(): string
        copy(): boolean
        enter(): boolean
        escOrInventory(): boolean
        readonly keyCode : number;
        readonly modifiers : Internal.KeyModifiers;
        readonly scanCode : number;
        get inputMapping(): Internal.InputConstants$Key;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace com.jozufozu.flywheel.api {
    interface Material <D> {
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction, arg3: () => Internal.PoseStack): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState): Internal.Instancer<D>
        getModel(arg0: Internal.BlockState): Internal.Instancer<D>
        model(arg0: any, arg1: () => Internal.Model): Internal.Instancer<D>
    }
}
declare namespace net.minecraft.world.level.entity {
    interface EntityAccess {
    }
}
declare namespace java_.util.concurrent {
    interface ScheduledFuture <V> extends Internal.Delayed, java_.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        getDelay(arg0: Internal.TimeUnit): number
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        compareTo(arg0: Internal.Delayed): number
        isDone(): boolean
    }
    interface Future <V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        get(): V
        get(arg0: number, arg1: Internal.TimeUnit): V
        isDone(): boolean
    }
    interface Callable <V> {
        call(): V
    }
}
declare namespace it.unimi.dsi.fastutil.longs {
    interface LongConsumer extends Internal.Consumer<number>, Internal.LongConsumer {
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        andThen(arg0: Internal.LongConsumer): (arg0: any) => void
        andThen(arg0: (arg0: number) => void): (arg0: number) => void
        andThen(arg0: (arg0: any) => void): (arg0: any) => void
        accept(arg0: any): void
        accept(arg0: number): void
        accept(arg0: number): void
    }
}
declare namespace net.minecraft.tags {
    interface Tag <T> {
    }
}
declare namespace dev.latvian.mods.rhino {
    interface Function extends Internal.Scriptable, Internal.Callable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        hasInstance(arg0: Internal.Scriptable): boolean
        setParentScope(arg0: Internal.Scriptable): void
        getIds(): any[]
        construct(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: any[]): Internal.Scriptable
        getAllIds(): any[]
        delete(arg0: string): void
        delete(arg0: number): void
        put(arg0: string, arg1: Internal.Scriptable, arg2: any): void
        put(arg0: number, arg1: Internal.Scriptable, arg2: any): void
        getDefaultValue(arg0: Internal.Class<any>): any
        setPrototype(arg0: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any
        get(arg0: number, arg1: Internal.Scriptable): any
        get(arg0: string, arg1: Internal.Scriptable): any
        has(arg0: string, arg1: Internal.Scriptable): boolean
        has(arg0: number, arg1: Internal.Scriptable): boolean
        getClassName(): string
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean
        getParentScope(): Internal.Scriptable
    }
}
declare namespace net.minecraft.core {
    abstract class RegistryAccess implements Internal.NoFogDynamicRegistryManagerExtensions {
        getClass(): Internal.Class<any>
        wait(arg0: number, arg1: number): void
        wait(): void
        wait(arg0: number): void
        hashCode(): number
        notifyAll(): void
        equals(arg0: any): boolean
        toString(): string
        notify(): void
        no_fog_get(key: Internal.ResourceKey<any>): Internal.MappedRegistry<any>
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace Document {
    class ArsNouveauRecipes {
        enchanting_apparatus(output: string, reagent: Internal.IngredientJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.IngredientJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.IngredientJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.IngredientJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.ItemStackJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.ItemStackJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: string, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: string, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: string, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: string, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: object, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: object, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: object, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: string, reagent: object, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.IngredientJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.IngredientJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.IngredientJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.IngredientJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.ItemStackJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.ItemStackJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: string, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: string, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: string, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: string, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: object, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: object, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: object, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: Internal.ItemStackJS, reagent: object, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.IngredientJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.IngredientJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.IngredientJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.IngredientJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.ItemStackJS, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.ItemStackJS, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: string, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: string, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: string, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: string, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: object, inputs: string[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: object, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: object, inputs: object[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchanting_apparatus(output: object, reagent: object, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchantment(enchantment: string, level: number, inputs: string[]): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.IngredientJS[]): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: object[]): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.ItemStackJS[]): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: string[], mana: number): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.IngredientJS[], mana: number): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: object[], mana: number): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.ItemStackJS[], mana: number): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: string, input: Internal.ItemStackJS, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: string, input: string, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: string, input: object, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: Internal.ItemStackJS, input: Internal.ItemStackJS, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: Internal.ItemStackJS, input: string, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: Internal.ItemStackJS, input: object, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: object, input: Internal.ItemStackJS, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: object, input: string, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: object, input: object, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
    }
    class CreateRecipes {
        /**
        * Creates a recipe for Crushing Wheels.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        crushing(outputs: object[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        crushing(outputs: object[], input: string): Internal.ProcessingRecipeJS;
        crushing(outputs: object[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        crushing(outputs: object[], input: object): Internal.ProcessingRecipeJS;
        crushing(outputs: string[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        crushing(outputs: string[], input: string): Internal.ProcessingRecipeJS;
        crushing(outputs: string[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        crushing(outputs: string[], input: object): Internal.ProcessingRecipeJS;
        crushing(outputs: Internal.ItemStackJS[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        crushing(outputs: Internal.ItemStackJS[], input: string): Internal.ProcessingRecipeJS;
        crushing(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        crushing(outputs: Internal.ItemStackJS[], input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Millstone.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        milling(outputs: object[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        milling(outputs: object[], input: string): Internal.ProcessingRecipeJS;
        milling(outputs: object[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        milling(outputs: object[], input: object): Internal.ProcessingRecipeJS;
        milling(outputs: string[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        milling(outputs: string[], input: string): Internal.ProcessingRecipeJS;
        milling(outputs: string[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        milling(outputs: string[], input: object): Internal.ProcessingRecipeJS;
        milling(outputs: Internal.ItemStackJS[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        milling(outputs: Internal.ItemStackJS[], input: string): Internal.ProcessingRecipeJS;
        milling(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        milling(outputs: Internal.ItemStackJS[], input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Compacting.
        */
        compacting(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mixing.
        */
        mixing(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Pressing.
        *
        * Pressing uses Depot or Belt as container, and can only have 1 item slot as input.
        *
        * Pressing is available as an Assembly step.
        */
        pressing(output: string, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        pressing(output: string, input: string): Internal.ProcessingRecipeJS;
        pressing(output: string, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        pressing(output: string, input: object): Internal.ProcessingRecipeJS;
        pressing(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        pressing(output: Internal.ItemStackJS, input: string): Internal.ProcessingRecipeJS;
        pressing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        pressing(output: Internal.ItemStackJS, input: object): Internal.ProcessingRecipeJS;
        pressing(output: object, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        pressing(output: object, input: string): Internal.ProcessingRecipeJS;
        pressing(output: object, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        pressing(output: object, input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Deploying.
        *
        * Deploying is available as an Assembly step.
        */
        deploying(output: string, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        deploying(output: string, input: string): Internal.ProcessingRecipeJS;
        deploying(output: string, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        deploying(output: string, input: object): Internal.ProcessingRecipeJS;
        deploying(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        deploying(output: Internal.ItemStackJS, input: string): Internal.ProcessingRecipeJS;
        deploying(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        deploying(output: Internal.ItemStackJS, input: object): Internal.ProcessingRecipeJS;
        deploying(output: object, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        deploying(output: object, input: string): Internal.ProcessingRecipeJS;
        deploying(output: object, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        deploying(output: object, input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Cutting.
        *
        * Cutting is available as an Assembly step.
        */
        cutting(output: string, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        cutting(output: string, input: string): Internal.ProcessingRecipeJS;
        cutting(output: string, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        cutting(output: string, input: object): Internal.ProcessingRecipeJS;
        cutting(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        cutting(output: Internal.ItemStackJS, input: string): Internal.ProcessingRecipeJS;
        cutting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        cutting(output: Internal.ItemStackJS, input: object): Internal.ProcessingRecipeJS;
        cutting(output: object, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        cutting(output: object, input: string): Internal.ProcessingRecipeJS;
        cutting(output: object, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        cutting(output: object, input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Filling.
        *
        * Filling is available as an Assembly step.
        */
        filling(output: string, input: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        filling(output: Internal.ItemStackJS, input: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        filling(output: object, input: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sequenced Assembly.
        *
        * The sequnce must use recipes which is available for Assembly.
        */
        sequenced_assembly(output: string[], input: Internal.ItemStackJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: string[], input: string, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: string[], input: Internal.IngredientJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: string[], input: object, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: object[], input: Internal.ItemStackJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: object[], input: string, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: object[], input: Internal.IngredientJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: object[], input: object, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: Internal.ItemStackJS[], input: Internal.ItemStackJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: Internal.ItemStackJS[], input: string, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: Internal.ItemStackJS[], input: Internal.IngredientJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        sequenced_assembly(output: Internal.ItemStackJS[], input: object, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        /**
        * Creates a recipe for Splashing.
        */
        splashing(output: string[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        splashing(output: string[], input: string): Internal.ProcessingRecipeJS;
        splashing(output: string[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        splashing(output: string[], input: object): Internal.ProcessingRecipeJS;
        splashing(output: object[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        splashing(output: object[], input: string): Internal.ProcessingRecipeJS;
        splashing(output: object[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        splashing(output: object[], input: object): Internal.ProcessingRecipeJS;
        splashing(output: Internal.ItemStackJS[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        splashing(output: Internal.ItemStackJS[], input: string): Internal.ProcessingRecipeJS;
        splashing(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        splashing(output: Internal.ItemStackJS[], input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Haunting.
        */
        haunting(output: string[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        haunting(output: string[], input: string): Internal.ProcessingRecipeJS;
        haunting(output: string[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        haunting(output: string[], input: object): Internal.ProcessingRecipeJS;
        haunting(output: object[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        haunting(output: object[], input: string): Internal.ProcessingRecipeJS;
        haunting(output: object[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        haunting(output: object[], input: object): Internal.ProcessingRecipeJS;
        haunting(output: Internal.ItemStackJS[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        haunting(output: Internal.ItemStackJS[], input: string): Internal.ProcessingRecipeJS;
        haunting(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        haunting(output: Internal.ItemStackJS[], input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sandpaper Polishing.
        */
        sandpaper_polishing(output: string, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: string, input: string): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: string, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: string, input: object): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: Internal.ItemStackJS, input: string): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: Internal.ItemStackJS, input: object): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: object, input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: object, input: string): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: object, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        sandpaper_polishing(output: object, input: object): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mechanical Crafting.
        */
        mechanical_crafting(output: string, pattern: string[], items: Internal.Map<string, object>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: string, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: string, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: string, pattern: string[], items: Internal.Map<string, string>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, object>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, string>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: object, pattern: string[], items: Internal.Map<string, object>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: object, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: object, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ProcessingRecipeJS;
        mechanical_crafting(output: object, pattern: string[], items: Internal.Map<string, string>): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Emptying.
        */
        emptying(output: Type.ItemStackOrFluid[], input: Internal.ItemStackJS): Internal.ProcessingRecipeJS;
        emptying(output: Type.ItemStackOrFluid[], input: string): Internal.ProcessingRecipeJS;
        emptying(output: Type.ItemStackOrFluid[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        emptying(output: Type.ItemStackOrFluid[], input: object): Internal.ProcessingRecipeJS;
    }
    class RecipeHolder {
        /**
        * All recipes from Create.
        */
        readonly create: Document.CreateRecipes;
        /**
        * All recipes from Minecraft.
        */
        readonly minecraft: Document.MinecraftRecipes;
        /**
        * The builtin support for Integrated Dynamics is not complete in KubeJS.
        *
        * If you need Basin or Mechanical Basin, please use event.custom() .
        */
        readonly integrateddynamics: Document.IntegratedDynamicsRecipes;
        ars_nouveau: Document.ArsNouveauRecipes;
        botania: Document.BotaniaRecipes;
        cucumber: Document.CucumberRecipes;
        extendedcrafting: Document.ExtendedCraftingRecipes;
    }
    class CucumberRecipes {
        shaped_no_mirror(output: string, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: string, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: string, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: string, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: object, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: object, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: object, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_no_mirror(output: object, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
    }
    class BotaniaRecipes {
        runic_altar(output: string, inputs: string[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: Internal.IngredientJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: object[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: Internal.ItemStackJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: string[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: object[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: string[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: Internal.IngredientJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: object[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: Internal.ItemStackJS[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: string[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: Internal.IngredientJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: object[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: string, inputs: Internal.ItemStackJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: string[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: object[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: string[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: Internal.IngredientJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: object[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: object, inputs: Internal.ItemStackJS[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
    }
    class IntegratedDynamicsRecipes {
        /**
        * Adds a recipe of Squeezer.
        *
        * @param output The outputs, **NOTE:** The first item in output must not have a chance.
        */
        squeezer(outputs: object[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: object[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: object[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: object[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: string[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: string[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: string[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: string[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: Internal.ItemStackJS[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: Internal.ItemStackJS[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        squeezer(outputs: Internal.ItemStackJS[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        /**
        * Adds a recipe of Mechanical Squeezer.
        *
        * @param output The outputs, **NOTE:** The first item in output must not have a chance.
        */
        mechanical_squeezer(outputs: object[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: object[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: object[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: object[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: string[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: string[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: string[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: string[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: Internal.ItemStackJS[], input: Internal.ItemStackJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: Internal.ItemStackJS[], input: string): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
        mechanical_squeezer(outputs: Internal.ItemStackJS[], input: object): dev.latvian.kubejs.recipe.mod.IDSqueezerRecipeJS;
    }
    class MinecraftRecipes {
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: string, input: string): Internal.CookingRecipeJS;
        smelting(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: string, input: object): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        smelting(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smelting(output: object, input: string): Internal.CookingRecipeJS;
        smelting(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smelting(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: string, input: string): Internal.CookingRecipeJS;
        smoking(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: string, input: object): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        smoking(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        smoking(output: object, input: string): Internal.CookingRecipeJS;
        smoking(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        smoking(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: string, input: string): Internal.CookingRecipeJS;
        blasting(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: string, input: object): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        blasting(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        blasting(output: object, input: string): Internal.CookingRecipeJS;
        blasting(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        blasting(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        crafting_shaped(output: string, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        crafting_shaped(output: string, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: string, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: string, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        crafting_shaped(output: object, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        crafting_shaped(output: object, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: object, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        crafting_shaped(output: object, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        crafting_shapeless(output: string, inputs: string[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: string, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: string, inputs: object[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: string, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: Internal.ItemStackJS, inputs: string[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: Internal.ItemStackJS, inputs: object[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: object, inputs: string[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: object, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: object, inputs: object[]): Internal.ShapelessRecipeJS;
        crafting_shapeless(output: object, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        camefire_cooking(output: string, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        camefire_cooking(output: string, input: string): Internal.CookingRecipeJS;
        camefire_cooking(output: string, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        camefire_cooking(output: string, input: object): Internal.CookingRecipeJS;
        camefire_cooking(output: Internal.ItemStackJS, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        camefire_cooking(output: Internal.ItemStackJS, input: string): Internal.CookingRecipeJS;
        camefire_cooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        camefire_cooking(output: Internal.ItemStackJS, input: object): Internal.CookingRecipeJS;
        camefire_cooking(output: object, input: Internal.ItemStackJS): Internal.CookingRecipeJS;
        camefire_cooking(output: object, input: string): Internal.CookingRecipeJS;
        camefire_cooking(output: object, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        camefire_cooking(output: object, input: object): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: string, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: string, inputs: object): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: Internal.ItemStackJS, inputs: object): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: Internal.ItemStackJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: string): Internal.StonecuttingRecipeJS;
        stonecutting(output: object, inputs: object): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: string, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: string, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: Internal.ItemStackJS, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: object, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.ItemStackJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: Internal.IngredientJS, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: object): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: string): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
        smithing(output: object, base: string, addition: Internal.ItemStackJS): Internal.SmithingRecipeJS;
    }
    class ExtendedCraftingRecipes {
        shaped_table(output: string, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_table(output: string, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_table(output: string, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_table(output: string, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped_table(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_table(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_table(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_table(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shaped_table(output: object, pattern: string[], items: Internal.Map<string, object>): Internal.ShapedRecipeJS;
        shaped_table(output: object, pattern: string[], items: Internal.Map<string, Internal.ItemStackJS>): Internal.ShapedRecipeJS;
        shaped_table(output: object, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        shaped_table(output: object, pattern: string[], items: Internal.Map<string, string>): Internal.ShapedRecipeJS;
        shapeless_table(output: string, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: string, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: string, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: string, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: Internal.ItemStackJS, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: Internal.ItemStackJS, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: Internal.ItemStackJS, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: object, inputs: string[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: object, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: object, inputs: object[]): Internal.ShapelessRecipeJS;
        shapeless_table(output: object, inputs: Internal.ItemStackJS[]): Internal.ShapelessRecipeJS;
    }
}
declare namespace Type {
    type ItemStackOrFluid = Internal.ItemStackJS | Internal.FluidStackJS;
    type IngredientOrFluid = Internal.IngredientJS | Internal.FluidStackJS;
}
declare namespace TSDoc {
}
